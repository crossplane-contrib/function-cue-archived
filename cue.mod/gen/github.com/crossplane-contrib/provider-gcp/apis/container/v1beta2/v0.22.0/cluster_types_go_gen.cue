// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane-contrib/provider-gcp/apis/container/v1beta2

// nolint:gocritic,golint // Deprecation comment format false positives.
package v1beta2

#ClusterStateUnspecified:  "STATUS_UNSPECIFIED"
#ClusterStateProvisioning: "PROVISIONING"
#ClusterStateRunning:      "RUNNING"
#ClusterStateReconciling:  "RECONCILING"
#ClusterStateStopping:     "STOPPING"
#ClusterStateError:        "ERROR"
#ClusterStateDegraded:     "DEGRADED"

#DefaultNumberOfNodes: int64 & 1

// ClusterParameters define the desired state of a Google Kubernetes Engine
// cluster. Most of its fields are direct mirror of GCP Cluster object.
// See https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster
#ClusterParameters: {
	// Location: The name of the Google Compute
	// Engine
	// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
	// or
	// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) in
	// which
	// the cluster resides.
	// +immutable
	location: string @go(Location)

	// AddonsConfig: Configurations for the various addons available to run
	// in the cluster.
	// +optional
	addonsConfig?: null | #AddonsConfig @go(AddonsConfig,*AddonsConfig)

	// AuthenticatorGroupsConfig: Configuration controlling RBAC group
	// membership information.
	// +optional
	// +immutable
	authenticatorGroupsConfig?: null | #AuthenticatorGroupsConfig @go(AuthenticatorGroupsConfig,*AuthenticatorGroupsConfig)

	// Autopilot: Autopilot configuration for the cluster.
	// +optional
	// +immutable
	autopilot?: null | #Autopilot @go(Autopilot,*Autopilot)

	// Autoscaling: Cluster-level autoscaling configuration.
	// +optional
	autoscaling?: null | #ClusterAutoscaling @go(Autoscaling,*ClusterAutoscaling)

	// BinaryAuthorization: Configuration for Binary Authorization.
	// +optional
	binaryAuthorization?: null | #BinaryAuthorization @go(BinaryAuthorization,*BinaryAuthorization)

	// ClusterIpv4Cidr: The IP address range of the container pods in this
	// cluster,
	// in
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `10.96.0.0/14`). Leave blank to have
	// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
	// +optional
	// +immutable
	clusterIpv4Cidr?: null | string @go(ClusterIpv4Cidr,*string)

	// ConfidentialNodes: Configuration of Confidential Nodes
	// +optional
	// +immutable
	confidentialNodes?: null | #ConfidentialNodes @go(ConfidentialNodes,*ConfidentialNodes)

	// DatabaseEncryption: Configuration of etcd encryption.
	// +optional
	databaseEncryption?: null | #DatabaseEncryption @go(DatabaseEncryption,*DatabaseEncryption)

	// DefaultMaxPodsConstraint: The default constraint on the maximum
	// number of pods that can be run
	// simultaneously on a node in the node pool of this cluster. Only
	// honored
	// if cluster created with IP Alias support.
	// +optional
	// +immutable
	defaultMaxPodsConstraint?: null | #MaxPodsConstraint @go(DefaultMaxPodsConstraint,*MaxPodsConstraint)

	// Description: An optional description of this cluster.
	// +optional
	// +immutable
	description?: null | string @go(Description,*string)

	// EnableKubernetesAlpha: Kubernetes alpha features are enabled on this
	// cluster. This includes alpha API groups (e.g. v1alpha1) and features that
	// may not be production ready in the kubernetes version of the master and
	// nodes. The cluster has no SLA for uptime and master/node upgrades are
	// disabled. Alpha enabled clusters are automatically deleted thirty days
	// after creation.
	// +optional
	// +immutable
	enableKubernetesAlpha?: null | bool @go(EnableKubernetesAlpha,*bool)

	// EnableTpu: Enable the ability to use Cloud TPUs in this cluster.
	// +optional
	// +immutable
	enableTpu?: null | bool @go(EnableTpu,*bool)

	// InitialClusterVersion: The initial Kubernetes version for this
	// cluster.  Valid versions are those
	// found in validMasterVersions returned by getServerConfig.  The
	// version can
	// be upgraded over time; such upgrades are reflected
	// in
	// currentMasterVersion and currentNodeVersion.
	//
	// Users may specify either explicit versions offered by
	// Kubernetes Engine or version aliases, which have the following
	// behavior:
	//
	// - "latest": picks the highest valid Kubernetes version
	// - "1.X": picks the highest valid patch+gke.N patch in the 1.X
	// version
	// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
	// - "1.X.Y-gke.N": picks an explicit Kubernetes version
	// - "","-": picks the default Kubernetes version
	// +optional
	// +immutable
	initialClusterVersion?: null | string @go(InitialClusterVersion,*string)

	// IPAllocationPolicy: Configuration for cluster IP allocation.
	// +optional
	// +immutable
	ipAllocationPolicy?: null | #IPAllocationPolicy @go(IPAllocationPolicy,*IPAllocationPolicy)

	// LabelFingerprint: The fingerprint of the set of labels for this
	// cluster.
	// +optional
	// +immutable
	labelFingerprint?: null | string @go(LabelFingerprint,*string)

	// LegacyAbac: Configuration for the legacy ABAC authorization mode.
	// +optional
	legacyAbac?: null | #LegacyAbac @go(LegacyAbac,*LegacyAbac)

	// Locations: The list of Google Compute
	// Engine
	// [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's
	// nodes
	// should be located.
	// +optional
	locations?: [...string] @go(Locations,[]string)

	// LoggingService: The logging service the cluster should use to write
	// logs.
	// Currently available options:
	//
	// * "logging.googleapis.com/kubernetes" - the Google Cloud
	// Logging
	// service with Kubernetes-native resource model in Stackdriver
	// * `logging.googleapis.com` - the Google Cloud Logging service.
	// * `none` - no logs will be exported from the cluster.
	// * if left as an empty string,`logging.googleapis.com` will be used.
	// +optional
	loggingService?: null | string @go(LoggingService,*string)

	// MaintenancePolicy: Configure the maintenance policy for this cluster.
	// +optional
	maintenancePolicy?: null | #MaintenancePolicySpec @go(MaintenancePolicy,*MaintenancePolicySpec)

	// MasterAuth: The authentication information for accessing the master
	// endpoint.
	// If unspecified, the defaults are used:
	// For clusters before v1.12, if master_auth is unspecified, `username`
	// will
	// be set to "admin", a random password will be generated, and a
	// client
	// certificate will be issued.
	// +optional
	masterAuth?: null | #MasterAuth @go(MasterAuth,*MasterAuth)

	// MasterAuthorizedNetworksConfig: The configuration options for master
	// authorized networks feature.
	// +optional
	masterAuthorizedNetworksConfig?: null | #MasterAuthorizedNetworksConfig @go(MasterAuthorizedNetworksConfig,*MasterAuthorizedNetworksConfig)

	// MonitoringService: The monitoring service the cluster should use to
	// write metrics.
	// Currently available options:
	//
	// * `monitoring.googleapis.com` - the Google Cloud Monitoring
	// service.
	// * `none` - no metrics will be exported from the cluster.
	// * if left as an empty string, `monitoring.googleapis.com` will be
	// used.
	// +optional
	monitoringService?: null | string @go(MonitoringService,*string)

	// Network: The name of the Google Compute
	// Engine
	// [network](https://cloud.google.com/vpc/docs/vpc#vpc_networks_and_subnets) to which
	// the
	// cluster is connected. If left unspecified, the `default` network
	// will be used.
	// +optional
	// +immutable
	network?: null | string @go(Network,*string)

	// NetworkConfig: Configuration for cluster networking.
	// +optional
	networkConfig?: null | #NetworkConfigSpec @go(NetworkConfig,*NetworkConfigSpec)

	// NetworkPolicy: Configuration options for the NetworkPolicy feature.
	// +optional
	networkPolicy?: null | #NetworkPolicy @go(NetworkPolicy,*NetworkPolicy)

	// NotificationConfig: Notification configuration of the cluster.
	notificationConfig?: null | #NotificationConfig @go(NotificationConfig,*NotificationConfig)

	// PrivateClusterConfig: Configuration for private cluster.
	// +optional
	privateClusterConfig?: null | #PrivateClusterConfigSpec @go(PrivateClusterConfig,*PrivateClusterConfigSpec)

	// ReleaseChannel: Release channel configuration.
	releaseChannel?: null | #ReleaseChannel @go(ReleaseChannel,*ReleaseChannel)

	// ResourceLabels: The resource labels for the cluster to use to
	// annotate any related
	// Google Compute Engine resources.
	// +optional
	resourceLabels?: {[string]: string} @go(ResourceLabels,map[string]string)

	// ResourceUsageExportConfig: Configuration for exporting resource
	// usages. Resource usage export is
	// disabled when this config is unspecified.
	// +optional
	resourceUsageExportConfig?: null | #ResourceUsageExportConfig @go(ResourceUsageExportConfig,*ResourceUsageExportConfig)

	// Subnetwork: The name of the Google Compute
	// Engine
	// [subnetwork](https://cloud.google.com/vpc/docs/subnets) to which the
	// cluster is connected.
	// +optional
	// +immutable
	subnetwork?: null | string @go(Subnetwork,*string)

	// VerticalPodAutoscaling: Cluster-level Vertical Pod Autoscaling
	// configuration.
	// +optional
	verticalPodAutoscaling?: null | #VerticalPodAutoscaling @go(VerticalPodAutoscaling,*VerticalPodAutoscaling)

	// WorkloadIdentityConfig: Configuration for the use of Kubernetes
	// Service Accounts in GCP IAM
	// policies.
	// +optional
	workloadIdentityConfig?: null | #WorkloadIdentityConfig @go(WorkloadIdentityConfig,*WorkloadIdentityConfig)
}

// ClusterObservation is used to show the observed state of the GKE cluster resource on GCP.
#ClusterObservation: {
	// Conditions: Which conditions caused the current cluster state.
	conditions?: [...null | #StatusCondition] @go(Conditions,[]*StatusCondition)

	// CreateTime: The time the cluster was created,
	// in
	// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	createTime?: string @go(CreateTime)

	// CurrentMasterVersion: The current software version of
	// the master endpoint.
	currentMasterVersion?: string @go(CurrentMasterVersion)

	// CurrentNodeCount:  The number of nodes currently in the
	// cluster. Deprecated.
	// Call Kubernetes API directly to retrieve node information.
	currentNodeCount?: int64 @go(CurrentNodeCount)

	// CurrentNodeVersion: Deprecated,
	// use
	// [NodePools.version](/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools)
	// instead. The current version of the node software components. If they
	// are
	// currently at multiple versions because they're in the process of
	// being
	// upgraded, this reflects the minimum version of all nodes.
	currentNodeVersion?: string @go(CurrentNodeVersion)

	// Endpoint: The IP address of this cluster's master
	// endpoint.
	// The endpoint can be accessed from the internet
	// at
	// `https://username:password@endpoint/`.
	//
	// See the `masterAuth` property of this resource for username
	// and
	// password information.
	endpoint?: string @go(Endpoint)

	// ExpireTime: The time the cluster will be
	// automatically
	// deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text
	// format.
	expireTime?: string @go(ExpireTime)

	// Location: The name of the Google Compute
	// Engine
	// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
	// or
	// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) in
	// which
	// the cluster resides.
	location: string @go(Location)

	// MaintenancePolicy: Configure the maintenance policy for this cluster.
	maintenancePolicy?: null | #MaintenancePolicyStatus @go(MaintenancePolicy,*MaintenancePolicyStatus)

	// NetworkConfig: Configuration for cluster networking.
	networkConfig?: null | #NetworkConfigStatus @go(NetworkConfig,*NetworkConfigStatus)

	// NodeIpv4CidrSize: The size of the address space on each
	// node for hosting
	// containers. This is provisioned from within the
	// `container_ipv4_cidr`
	// range. This field will only be set when cluster is in route-based
	// network
	// mode.
	nodeIpv4CidrSize?: int64 @go(NodeIpv4CidrSize)

	// PrivateClusterConfig: Configuration for private cluster.
	privateClusterConfig?: null | #PrivateClusterConfigStatus @go(PrivateClusterConfig,*PrivateClusterConfigStatus)

	// NodePools: The node pools associated with this cluster.
	// This field should not be set if "node_config" or "initial_node_count"
	// are
	// specified.
	nodePools?: [...null | #NodePoolClusterStatus] @go(NodePools,[]*NodePoolClusterStatus)

	// SelfLink: Server-defined URL for the resource.
	selfLink?: string @go(SelfLink)

	// ServicesIpv4Cidr: The IP address range of the
	// Kubernetes services in
	// this cluster,
	// in
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `1.2.3.4/29`). Service addresses are
	// typically put in the last `/16` from the container CIDR.
	servicesIpv4Cidr?: string @go(ServicesIpv4Cidr)

	// Status: The current status of this cluster.
	//
	// Possible values:
	//   "STATUS_UNSPECIFIED" - Not set.
	//   "PROVISIONING" - The PROVISIONING state indicates the cluster is
	// being created.
	//   "RUNNING" - The RUNNING state indicates the cluster has been
	// created and is fully
	// usable.
	//   "RECONCILING" - The RECONCILING state indicates that some work is
	// actively being done on
	// the cluster, such as upgrading the master or node software. Details
	// can
	// be found in the `statusMessage` field.
	//   "STOPPING" - The STOPPING state indicates the cluster is being
	// deleted.
	//   "ERROR" - The ERROR state indicates the cluster may be unusable.
	// Details
	// can be found in the `statusMessage` field.
	//   "DEGRADED" - The DEGRADED state indicates the cluster requires user
	// action to restore
	// full functionality. Details can be found in the `statusMessage`
	// field.
	status?: string @go(Status)

	// StatusMessage: Additional information about the current
	// status of this
	// cluster, if available.
	statusMessage?: string @go(StatusMessage)

	// TpuIpv4CidrBlock: The IP address range of the Cloud
	// TPUs in this cluster,
	// in
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `1.2.3.4/29`).
	tpuIpv4CidrBlock?: string @go(TpuIpv4CidrBlock)

	// Zone: The name of the Google Compute
	// Engine
	// [zone](https://cloud.google.com/compute/docs/zones#available) in which the
	// cluster
	// resides.
	// This field is deprecated, use location instead.
	zone?: string @go(Zone)
}

// AddonsConfig is configuration for the addons that can be automatically
// spun up in the
// cluster, enabling additional functionality.
#AddonsConfig: {
	// CloudRunConfig: Configuration for the Cloud Run addon. The
	// `IstioConfig` addon must be
	// enabled in order to enable Cloud Run addon. This option can only be
	// enabled at cluster creation time.
	// +optional
	cloudRunConfig?: null | #CloudRunConfig @go(CloudRunConfig,*CloudRunConfig)

	// ConfigConnectorConfig: Configuration for the ConfigConnector add-on,
	// a Kubernetes extension to manage hosted GCP services through the
	// Kubernetes API
	// +optional
	configConnectorConfig?: null | #ConfigConnectorConfig @go(ConfigConnectorConfig,*ConfigConnectorConfig)

	// DNSCacheConfig: Configuration for NodeLocalDNS, a dns cache running
	// on cluster nodes
	// +optional
	dnsCacheConfig?: null | #DNSCacheConfig @go(DNSCacheConfig,*DNSCacheConfig)

	// GCEPersistentDiskCSIDriverConfig: Configuration for the GCP Compute
	// Persistent Disk CSI driver.
	// +optional
	gcePersistentDiskCsiDriverConfig?: null | #GCEPersistentDiskCSIDriverConfig @go(GCEPersistentDiskCSIDriverConfig,*GCEPersistentDiskCSIDriverConfig)

	// HorizontalPodAutoscaling: Configuration for the horizontal pod
	// autoscaling feature, which increases or decreases the number of replica
	// pods a replication controller has based on the resource usage of the
	// existing pods.
	// +optional
	horizontalPodAutoscaling?: null | #HorizontalPodAutoscaling @go(HorizontalPodAutoscaling,*HorizontalPodAutoscaling)

	// HTTpLoadBalancing: Configuration for the HTTP (L7) load balancing
	// controller addon, which
	// makes it easy to set up HTTP load balancers for services in a
	// cluster.
	// +optional
	httpLoadBalancing?: null | #HTTPLoadBalancing @go(HTTPLoadBalancing,*HTTPLoadBalancing)

	// KubernetesDashboard: Configuration for the Kubernetes Dashboard.
	// This addon is deprecated, and will be disabled in 1.15. It is
	// recommended
	// to use the Cloud Console to manage and monitor your Kubernetes
	// clusters,
	// workloads and applications. For more information,
	// see:
	// https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards
	// +optional
	kubernetesDashboard?: null | #KubernetesDashboard @go(KubernetesDashboard,*KubernetesDashboard)

	// NetworkPolicyConfig: Configuration for NetworkPolicy. This only
	// tracks whether the addon is enabled or not on the Master, it does not
	// track whether network policy is enabled for the nodes.
	// +optional
	networkPolicyConfig?: null | #NetworkPolicyConfig @go(NetworkPolicyConfig,*NetworkPolicyConfig)
}

// GCEPersistentDiskCSIDriverConfig is configuration for the GCE PD CSI driver.
// This option can only be enabled at cluster creation time.
#GCEPersistentDiskCSIDriverConfig: {
	// Enabled: Whether the GCE PD CSI driver is enabled for this cluster.
	enabled: bool @go(Enabled)
}

// DNSCacheConfig is configuration for NodeLocal DNSCache.
#DNSCacheConfig: {
	// Enabled: Whether NodeLocal DNSCache is enabled for this cluster.
	enabled: bool @go(Enabled)
}

// CloudRunConfig is configuration options for the Cloud Run feature.
#CloudRunConfig: {
	// Disabled: Whether Cloud Run addon is enabled for this cluster.
	disabled: bool @go(Disabled)

	// LoadBalancerType: Which load balancer type is installed for Cloud
	// Run.
	//
	// Possible values:
	//   "LOAD_BALANCER_TYPE_UNSPECIFIED" - Load balancer type for Cloud Run
	// is unspecified.
	//   "LOAD_BALANCER_TYPE_EXTERNAL" - Install external load balancer for
	// Cloud Run.
	//   "LOAD_BALANCER_TYPE_INTERNAL" - Install internal load balancer for
	// Cloud Run.
	// +optional
	loadBalancerType?: null | string @go(LoadBalancerType,*string)
}

// ConfigConnectorConfig is configuration options for the Config Connector
// add-on.
#ConfigConnectorConfig: {
	// Enabled: Whether Cloud Connector is enabled for this cluster.
	enabled: bool @go(Enabled)
}

// HorizontalPodAutoscaling is configuration options for the horizontal
// pod autoscaling feature, which
// increases or decreases the number of replica pods a replication
// controller
// has based on the resource usage of the existing pods.
#HorizontalPodAutoscaling: {
	// Disabled: Whether the Horizontal Pod Autoscaling feature is enabled
	// in the cluster.
	// When enabled, it ensures that a Heapster pod is running in the
	// cluster,
	// which is also used by the Cloud Monitoring service.
	disabled: bool @go(Disabled)
}

// HTTPLoadBalancing is configuration options for the HTTP (L7) load
// balancing controller addon,
// which makes it easy to set up HTTP load balancers for services in a
// cluster.
#HTTPLoadBalancing: {
	// Disabled: Whether the HTTP Load Balancing controller is enabled in
	// the cluster.
	// When enabled, it runs a small pod in the cluster that manages the
	// load
	// balancers.
	disabled: bool @go(Disabled)
}

// KubernetesDashboard is configuration for the Kubernetes Dashboard.
#KubernetesDashboard: {
	// Disabled: Whether the Kubernetes Dashboard is enabled for this
	// cluster.
	disabled: bool @go(Disabled)
}

// NetworkPolicyConfig is configuration for NetworkPolicy. This only
// tracks whether the addon
// is enabled or not on the Master, it does not track whether network
// policy
// is enabled for the nodes.
#NetworkPolicyConfig: {
	// Disabled: Whether NetworkPolicy is enabled for this cluster.
	disabled: bool @go(Disabled)
}

// AuthenticatorGroupsConfig is configuration for returning group
// information from authenticators.
#AuthenticatorGroupsConfig: {
	// Enabled: Whether this cluster should return group membership
	// lookups
	// during authentication using a group of security groups.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// SecurityGroup: The name of the security group-of-groups to be used.
	// Only relevant
	// if enabled = true.
	// +optional
	securityGroup?: null | string @go(SecurityGroup,*string)
}

// Autopilot is configuration for Autopilot mode.
#Autopilot: {
	// Enabled: Enable Autopilot
	enabled: bool @go(Enabled)
}

// ClusterAutoscaling contains global, per-cluster
// information
// required by Cluster Autoscaler to automatically adjust
// the size of the cluster and create/delete
// node pools based on the current needs.
#ClusterAutoscaling: {
	// AutoprovisioningLocations: The list of Google Compute Engine
	// [zones](https://cloud.google.com/compute/docs/zones#available)
	// in which the NodePool's nodes can be created by NAP.
	autoprovisioningLocations?: [...string] @go(AutoprovisioningLocations,[]string)

	// AutoprovisioningNodePoolDefaults: AutoprovisioningNodePoolDefaults
	// contains defaults for a node pool
	// created by NAP.
	autoprovisioningNodePoolDefaults?: null | #AutoprovisioningNodePoolDefaults @go(AutoprovisioningNodePoolDefaults,*AutoprovisioningNodePoolDefaults)

	// EnableNodeAutoprovisioning: Enables automatic node pool creation and
	// deletion.
	// +optional
	enableNodeAutoprovisioning?: null | bool @go(EnableNodeAutoprovisioning,*bool)

	// ResourceLimits: Contains global constraints regarding minimum and
	// maximum
	// amount of resources in the cluster.
	resourceLimits?: [...null | #ResourceLimit] @go(ResourceLimits,[]*ResourceLimit)
}

// AutoprovisioningNodePoolDefaults contains
// defaults for a node pool created
// by NAP.
#AutoprovisioningNodePoolDefaults: {
	// BootDiskKmsKey: The Customer Managed Encryption Key used to encrypt
	// the boot disk attached to each node in the node pool. This should be
	// of the form
	// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cr
	// yptoKeys/[KEY_NAME]. For more information about protecting resources
	// with Cloud KMS Keys please see:
	// https://cloud.google.com/compute/docs/disks/customer-managed-encryption
	// +optional
	bootDiskKmsKey?: null | string @go(BootDiskKMSKey,*string)

	// DiskSizeGb: Size of the disk attached to each node, specified in GB.
	// The smallest allowed disk size is 10GB. If unspecified, the default
	// disk size is 100GB.
	// +optional
	diskSizeGb?: null | int64 @go(DiskSizeGb,*int64)

	// DiskType: Type of the disk attached to each node (e.g. 'pd-standard',
	// 'pd-ssd' or 'pd-balanced') If unspecified, the default disk type is
	// 'pd-standard'
	// +optional
	diskType?: null | string @go(DiskType,*string)

	// Management: Specifies the node management options for NAP created
	// node-pools.
	management?: null | #NodeManagement @go(Management,*NodeManagement)

	// MinCpuPlatform: Minimum CPU platform to be used for NAP created node
	// pools. The instance may be scheduled on the specified or newer CPU
	// platform. Applicable values are the friendly names of CPU platforms,
	// such as minCpuPlatform: Intel Haswell or minCpuPlatform: Intel Sandy
	// Bridge. For more information, read how to specify min CPU platform
	// (https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
	// To unset the min cpu platform field pass "automatic" as field value.
	// +optional
	minCpuPlatform?: null | string @go(MinCPUPlatform,*string)

	// OauthScopes: Scopes that are used by NAP when creating node pools. If
	// oauth_scopes are
	// specified, service_account should be empty.
	oauthScopes?: [...string] @go(OauthScopes,[]string)

	// ServiceAccount: The Google Cloud Platform Service Account to be used
	// by the node VMs. If
	// service_account is specified, scopes should be empty.
	// +optional
	serviceAccount?: null | string @go(ServiceAccount,*string)

	// ShieldedInstanceConfig: Shielded Instance options.
	// +optional
	shieldedInstanceConfig?: null | #ShieldedInstanceConfig @go(ShieldedInstanceConfig,*ShieldedInstanceConfig)

	// UpgradeSettings: Specifies the upgrade settings for NAP created node
	// pools
	// +optional
	upgradeSettings?: null | #UpgradeSettings @go(UpgradeSettings,*UpgradeSettings)
}

// NodeManagement defines the set of node management services turned on for the
// node pool.
#NodeManagement: {
	// AutoRepair: A flag that specifies whether the node auto-repair is
	// enabled for the node pool. If enabled, the nodes in this node pool
	// will be monitored and, if they fail health checks too many times, an
	// automatic repair action will be triggered.
	// +optional
	autoRepair?: null | bool @go(AutoRepair,*bool)

	// AutoUpgrade: A flag that specifies whether node auto-upgrade is
	// enabled for the node pool. If enabled, node auto-upgrade helps keep
	// the nodes in your node pool up to date with the latest release
	// version of Kubernetes.
	// +optional
	autoUpgrade?: null | bool @go(AutoUpgrade,*bool)
}

// ShieldedInstanceConfig is a set of Shielded Instance options.
#ShieldedInstanceConfig: {
	// EnableIntegrityMonitoring: Defines whether the instance has integrity
	// monitoring enabled. Enables monitoring and attestation of the boot
	// integrity of the instance. The attestation is performed against the
	// integrity policy baseline. This baseline is initially derived from
	// the implicitly trusted boot image when the instance is created.
	// +optional
	enableIntegrityMonitoring?: null | bool @go(EnableIntegrityMonitoring,*bool)

	// EnableSecureBoot: Defines whether the instance has Secure Boot
	// enabled. Secure Boot helps ensure that the system only runs authentic
	// software by verifying the digital signature of all boot components,
	// and halting the boot process if signature verification fails.
	// +optional
	enableSecureBoot?: null | bool @go(EnableSecureBoot,*bool)
}

// ResourceLimit contains information about amount of some resource in
// the cluster.
// For memory, value should be in GB.
#ResourceLimit: {
	// Maximum: Maximum amount of the resource in the cluster.
	maximum?: null | int64 @go(Maximum,*int64)

	// Minimum: Minimum amount of the resource in the cluster.
	minimum?: null | int64 @go(Minimum,*int64)

	// ResourceType: Resource name "cpu", "memory" or gpu-specific string.
	resourceType?: null | string @go(ResourceType,*string)
}

// UpgradeSettings control the level of parallelism and the level of disruption
// caused by an upgrade. maxUnavailable controls the number of nodes that can be
// simultaneously unavailable. maxSurge controls the number of additional nodes
// that can be added to the node pool temporarily for the time of the upgrade to
// increase the number of available nodes. (maxUnavailable + maxSurge)
// determines the level of parallelism (how many nodes are being upgraded at the
// same time). Note: upgrades inevitably introduce some disruption since
// workloads need to be moved from old nodes to new, upgraded ones. Even if
// maxUnavailable=0, this holds true. (Disruption stays within the limits of
// PodDisruptionBudget, if it is configured.) Consider a hypothetical node pool
// with 5 nodes having maxSurge=2, maxUnavailable=1. This means the upgrade
// process upgrades 3 nodes simultaneously. It creates 2 additional (upgraded)
// nodes, then it brings down 3 old (not yet upgraded) nodes at the same time.
// This ensures that there are always at least 4 nodes available.
#UpgradeSettings: {
	// MaxSurge: The maximum number of nodes that can be created beyond the
	// current size of the node pool during the upgrade process.
	// +optional
	maxSurge?: null | int64 @go(MaxSurge,*int64)

	// MaxUnavailable: The maximum number of nodes that can be
	// simultaneously unavailable during the upgrade process. A node is
	// considered available if its status is Ready.
	// +optional
	maxUnavailable?: null | int64 @go(MaxUnavailable,*int64)
}

// BinaryAuthorization is configuration for Binary Authorization.
#BinaryAuthorization: {
	// Enabled: Enable Binary Authorization for this cluster. If enabled,
	// all container
	// images will be validated by Google Binauthz.
	enabled: bool @go(Enabled)
}

// ConfidentialNodes is configuration for Confidential Nodes.
#ConfidentialNodes: {
	// Enabled: Whether Confidential Nodes feature is enabled for all nodes
	// in this cluster.
	enabled: bool @go(Enabled)
}

// DatabaseEncryption is configuration of etcd encryption.
#DatabaseEncryption: {
	// KeyName: Name of CloudKMS key to use for the encryption of secrets in
	// etcd.
	// Ex.
	// projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-ke
	// y
	// +optional
	keyName?: null | string @go(KeyName,*string)

	// State: Denotes the state of etcd encryption.
	//
	// Possible values:
	//   "UNKNOWN" - Should never be set
	//   "ENCRYPTED" - Secrets in etcd are encrypted.
	//   "DECRYPTED" - Secrets in etcd are stored in plain text (at etcd
	// level) - this is
	// unrelated to Google Compute Engine level full disk encryption.
	// +optional
	state?: null | string @go(State,*string)
}

// ReleaseChannel indicates which release channel a cluster is subscribed to.
// Release channels are arranged in order of risk. When a cluster is subscribed
// to a release channel, Google maintains both the master version and the node
// version. Node auto-upgrade defaults to true and cannot be disabled.
#ReleaseChannel: {
	// Channel: channel specifies which release channel the cluster is
	// subscribed to.
	//
	// Possible values:
	//   "UNSPECIFIED" - No channel specified.
	//   "RAPID" - RAPID channel is offered on an early access basis for
	// customers who want to test new releases. WARNING: Versions available in
	// the RAPID Channel may be subject to unresolved issues with no known
	// workaround and are not subject to any SLAs.
	//   "REGULAR" - Clusters subscribed to REGULAR receive versions that
	// are considered GA quality. REGULAR is intended for production users who
	// want to take advantage of new features.
	//   "STABLE" - Clusters subscribed to STABLE receive versions that are
	// known to be stable and reliable in production.
	channel: string @go(Channel)
}

// NotificationConfig is the configuration of notifications.
#NotificationConfig: {
	// Pubsub: Notification config for Pub/Sub.
	pubsub: #PubSub @go(Pubsub)
}

// PubSub specific notification config.
#PubSub: {
	// Enabled: Enable notifications for Pub/Sub.
	enabled: bool @go(Enabled)

	// Topic: The desired Pub/Sub topic to which notifications will be sent
	// by GKE. Format is `projects/{project}/topics/{topic}`.
	topic: string @go(Topic)
}

// StatusCondition describes why a cluster or a node
// pool has a certain status
// (e.g., ERROR or DEGRADED).
#StatusCondition: {
	// Code: Machine-friendly representation of the condition
	//
	// Possible values:
	//   "UNKNOWN" - UNKNOWN indicates a generic condition.
	//   "GCE_STOCKOUT" - GCE_STOCKOUT indicates a Google Compute Engine
	// stockout.
	//   "GKE_SERVICE_ACCOUNT_DELETED" - GKE_SERVICE_ACCOUNT_DELETED
	// indicates that the user deleted their robot
	// service account.
	//   "GCE_QUOTA_EXCEEDED" - Google Compute Engine quota was exceeded.
	//   "SET_BY_OPERATOR" - Cluster state was manually changed by an SRE
	// due to a system logic error.
	// More codes TBA
	code?: string @go(Code)

	// Message: Human-friendly representation of the condition
	message?: string @go(Message)
}

// MaxPodsConstraint defines constraints applied to pods.
#MaxPodsConstraint: {
	// MaxPodsPerNode: Constraint enforced on the max num of pods per node.
	maxPodsPerNode: int64 @go(MaxPodsPerNode)
}

// IPAllocationPolicy is configuration for controlling how IPs are
// allocated in the cluster.
#IPAllocationPolicy: {
	// ClusterIpv4CidrBlock: The IP address range for the cluster pod IPs. If
	// this field is set, then `cluster.cluster_ipv4_cidr` must be left blank.
	//
	// This field is only applicable when `use_ip_aliases` is true.
	//
	// Set to blank to have a range chosen with the default size.
	//
	// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
	// netmask.
	//
	// Set to a
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
	// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
	// to use.
	// +optional
	clusterIpv4CidrBlock?: null | string @go(ClusterIpv4CidrBlock,*string)

	// ClusterSecondaryRangeName: The name of the secondary range to be used
	// for the cluster CIDR
	// block.  The secondary range will be used for pod IP
	// addresses. This must be an existing secondary range associated
	// with the cluster subnetwork.
	//
	// This field is only applicable with use_ip_aliases is true
	// and
	// create_subnetwork is false.
	// +optional
	clusterSecondaryRangeName?: null | string @go(ClusterSecondaryRangeName,*string)

	// CreateSubnetwork: Whether a new subnetwork will be created
	// automatically for the cluster.
	//
	// This field is only applicable when `use_ip_aliases` is true.
	// +optional
	createSubnetwork?: null | bool @go(CreateSubnetwork,*bool)

	// NodeIpv4CidrBlock: The IP address range of the instance IPs in this
	// cluster.
	//
	// This is applicable only if `create_subnetwork` is true.
	//
	// Set to blank to have a range chosen with the default size.
	//
	// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
	// netmask.
	//
	// Set to a
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
	// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
	// to use.
	// +optional
	nodeIpv4CidrBlock?: null | string @go(NodeIpv4CidrBlock,*string)

	// ServicesIpv4CidrBlock: The IP address range of the services IPs in this
	// cluster. If blank, a range will be automatically chosen with the default
	// size.
	//
	// This field is only applicable when `use_ip_aliases` is true.
	//
	// Set to blank to have a range chosen with the default size.
	//
	// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
	// netmask.
	//
	// Set to a
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
	// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
	// to use.
	// +optional
	servicesIpv4CidrBlock?: null | string @go(ServicesIpv4CidrBlock,*string)

	// ServicesSecondaryRangeName: The name of the secondary range to be
	// used as for the services
	// CIDR block.  The secondary range will be used for service
	// ClusterIPs. This must be an existing secondary range associated
	// with the cluster subnetwork.
	//
	// This field is only applicable with use_ip_aliases is true
	// and
	// create_subnetwork is false.
	// +optional
	servicesSecondaryRangeName?: null | string @go(ServicesSecondaryRangeName,*string)

	// SubnetworkName: A custom subnetwork name to be used if
	// `create_subnetwork` is true.  If
	// this field is empty, then an automatic name will be chosen for the
	// new
	// subnetwork.
	// +optional
	subnetworkName?: null | string @go(SubnetworkName,*string)

	// TpuIpv4CidrBlock: The IP address range of the Cloud TPUs in this cluster.
	// If unspecified, a range will be automatically chosen with the default
	// size.
	//
	// This field is only applicable when `use_ip_aliases` is true.
	//
	// If unspecified, the range will use the default size.
	//
	// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
	// netmask.
	//
	// Set to a
	// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
	//
	// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
	// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
	// to use.
	// +optional
	tpuIpv4CidrBlock?: null | string @go(TpuIpv4CidrBlock,*string)

	// UseIPAliases: Whether alias IPs will be used for pod IPs in the
	// cluster.
	// +optional
	useIpAliases?: null | bool @go(UseIPAliases,*bool)

	// UseRoutes: Whether routes will be used for pod IPs in the cluster.
	// This is used in conjunction with use_ip_aliases. It cannot be true if
	// use_ip_aliases is true. If both use_ip_aliases and use_routes are
	// false, then the server picks the default IP allocation mode
	useRoutes?: null | bool @go(UseRoutes,*bool)
}

// LegacyAbac is configuration for the legacy Attribute Based Access
// Control authorization
// mode.
#LegacyAbac: {
	// Enabled: Whether the ABAC authorizer is enabled for this cluster.
	// When enabled,
	// identities in the system, including service accounts, nodes,
	// and
	// controllers, will have statically granted permissions beyond
	// those
	// provided by the RBAC configuration or IAM.
	enabled: bool @go(Enabled)
}

// MaintenancePolicySpec defines the maintenance policy
// to be used for the cluster.
#MaintenancePolicySpec: {
	// Window: Specifies the maintenance window in which maintenance may be
	// performed.
	window: #MaintenanceWindowSpec @go(Window)
}

// MaintenanceWindowSpec defines the maintenance window
// to be used for the cluster.
#MaintenanceWindowSpec: {
	// DailyMaintenanceWindow: DailyMaintenanceWindow specifies a daily
	// maintenance operation window.
	// +optional
	dailyMaintenanceWindow?: null | #DailyMaintenanceWindowSpec @go(DailyMaintenanceWindow,*DailyMaintenanceWindowSpec)

	// MaintenanceExclusions: Exceptions to maintenance window.
	// Non-emergency maintenance should not occur in these windows.
	// +optional
	maintenanceExclusions?: {[string]: #TimeWindow} @go(MaintenanceExclusions,map[string]TimeWindow)

	// RecurringWindow: RecurringWindow specifies some number of recurring
	// time periods for maintenance to occur. The time windows may be
	// overlapping. If no maintenance windows are set, maintenance can occur
	// at any time.
	// +optional
	recurringWindow?: null | #RecurringTimeWindow @go(RecurringWindow,*RecurringTimeWindow)
}

// DailyMaintenanceWindowSpec is the time window specified for daily maintenance
// operations.
#DailyMaintenanceWindowSpec: {
	// StartTime: Time within the maintenance window to start the
	// maintenance operations.
	// Time format should be in
	// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
	// format "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
	startTime: string @go(StartTime)
}

// TimeWindow is a window of time.
#TimeWindow: {
	// EndTime: The time that the window ends. The end time should take
	// place after the start time.
	endTime?: string @go(EndTime)

	// StartTime: The time that the window first starts.
	startTime?: string @go(StartTime)
}

// RecurringTimeWindow is a recurring window of time.
#RecurringTimeWindow: {
	// Recurrence: An RRULE
	// (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how this
	// window reccurs. They go on for the span of time between the start and
	// end time. For example, to have something repeat every weekday, you'd
	// use: `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR` To repeat some window daily
	// (equivalent to the DailyMaintenanceWindow): `FREQ=DAILY` For the
	// first weekend of every month: `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU`
	// This specifies how frequently the window starts. Eg, if you wanted to
	// have a 9-5 UTC-4 window every weekday, you'd use something like: “`
	// start time = 2019-01-01T09:00:00-0400 end time =
	// 2019-01-01T17:00:00-0400 recurrence =
	// FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR “` Windows can span multiple days.
	// Eg, to make the window encompass every weekend from midnight Saturday
	// till the last minute of Sunday UTC: “` start time =
	// 2019-01-05T00:00:00Z end time = 2019-01-07T23:59:00Z recurrence =
	// FREQ=WEEKLY;BYDAY=SA “` Note the start and end time's specific dates
	// are largely arbitrary except to specify duration of the window and
	// when it first starts. The FREQ values of HOURLY, MINUTELY, and
	// SECONDLY are not supported.
	recurrence?: null | string @go(Recurrence,*string)

	// Window: The window of the first recurrence.
	window?: null | #TimeWindow @go(Window,*TimeWindow)
}

// MaintenancePolicyStatus defines the maintenance policy
// to be used for the cluster.
#MaintenancePolicyStatus: {
	// Window: Specifies the maintenance window in which maintenance may be
	// performed.
	window?: #MaintenanceWindowStatus @go(Window)
}

// MaintenanceWindowStatus defines the maintenance window
// to be used for the cluster.
#MaintenanceWindowStatus: {
	// DailyMaintenanceWindow: DailyMaintenanceWindow specifies a daily
	// maintenance operation window.
	dailyMaintenanceWindow?: #DailyMaintenanceWindowStatus @go(DailyMaintenanceWindow)
}

// DailyMaintenanceWindowStatus is the observed time window for daily
// maintenance operations.
#DailyMaintenanceWindowStatus: {
	// Duration: Duration of the time window, automatically
	// chosen to be
	// smallest possible in the given scenario.
	// Duration will be in
	// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
	// format "PTnHnMnS".
	duration?: string @go(Duration)
}

// MasterAuth is the authentication information for accessing the master endpoint.
// Authentication can be done using HTTP basic auth or using client
// certificates.
#MasterAuth: {
	// ClientCertificateConfig: Configuration for client certificate
	// authentication on the cluster. For
	// clusters before v1.12, if no configuration is specified, a
	// client
	// certificate is issued.
	// +optional
	clientCertificateConfig?: null | #ClientCertificateConfig @go(ClientCertificateConfig,*ClientCertificateConfig)

	// Username: The username to use for HTTP basic authentication to the
	// master endpoint.
	// For clusters v1.6.0 and later, basic authentication can be disabled
	// by
	// leaving username unspecified (or setting it to the empty string).
	// +optional
	username?: null | string @go(Username,*string)
}

// ClientCertificateConfig is configuration for client certificates on the
// cluster.
#ClientCertificateConfig: {
	// IssueClientCertificate: Issue a client certificate.
	// +immutable
	issueClientCertificate: bool @go(IssueClientCertificate)
}

// MasterAuthorizedNetworksConfig is configuration options for the master
// authorized networks feature. Enabled
// master authorized networks will disallow all external traffic to
// access
// Kubernetes master through HTTPS except traffic from the given CIDR
// blocks,
// Google Compute Engine Public IPs and Google Prod IPs.
#MasterAuthorizedNetworksConfig: {
	// CidrBlocks: cidr_blocks define up to 50 external networks that could
	// access
	// Kubernetes master through HTTPS.
	// +optional
	cidrBlocks?: [...null | #CidrBlock] @go(CidrBlocks,[]*CidrBlock)

	// Enabled: Whether or not master authorized networks is enabled.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)
}

// CidrBlock contains an optional name and one CIDR block.
#CidrBlock: {
	// CidrBlock: cidr_block must be specified in CIDR notation.
	cidrBlock: string @go(CidrBlock)

	// DisplayName: display_name is an optional field for users to identify
	// CIDR blocks.
	// +optional
	displayName?: null | string @go(DisplayName,*string)
}

// NetworkConfigSpec reports the relative names of network &
// subnetwork.
#NetworkConfigSpec: {
	// DatapathProvider: The desired datapath provider for this cluster. By
	// default, uses the IPTables-based kube-proxy implementation.
	//
	// Possible values:
	//   "DATAPATH_PROVIDER_UNSPECIFIED" - Default value.
	//   "LEGACY_DATAPATH" - Use the IPTables implementation based on
	// kube-proxy.
	//   "ADVANCED_DATAPATH" - Use the eBPF based GKE Dataplane V2 with
	// additional features. See the [GKE Dataplane V2
	// documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2) for more.
	// +optional
	datapathProvider?: null | string @go(DatapathProvider,*string)

	// DefaultSnatStatus: Whether the cluster disables default in-node sNAT
	// rules. In-node sNAT rules will be disabled when default_snat_status
	// is disabled. When disabled is set to false, default IP masquerade
	// rules will be applied to the nodes to prevent sNAT on cluster
	// internal traffic.
	// +optional
	defaultSnatStatus?: null | #DefaultSnatStatus @go(DefaultSnatStatus,*DefaultSnatStatus)

	// EnableIntraNodeVisibility: Whether Intra-node visibility is enabled
	// for this cluster.
	// This makes same node pod to pod traffic visible for VPC network.
	// +optional
	enableIntraNodeVisibility?: null | bool @go(EnableIntraNodeVisibility,*bool)

	// PrivateIpv6GoogleAccess: The desired state of IPv6 connectivity to
	// Google Services. By default, no private IPv6 access to or from Google
	// Services (all access will be via IPv4)
	//
	// Possible values:
	//   "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" - Default value. Same as
	// DISABLED
	//   "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED" - No private access to or
	// from Google Services
	//   "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE" - Enables private IPv6
	// access to Google Services from GKE
	//   "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL" - Enables priate IPv6
	// access to and from Google Services
	// +optional
	privateIpv6GoogleAccess?: null | string @go(PrivateIpv6GoogleAccess,*string)

	// DNSConfig contains the desired set of options for configuring clusterDNS.
	// +optional
	dnsConfig?: null | #DnsConfig @go(DnsConfig,*DnsConfig)
}

// DefaultSnatStatus contains the desired state of whether default sNAT should
// be disabled on the cluster.
#DefaultSnatStatus: {
	// Disabled: Disables cluster default sNAT rules.
	disabled: bool @go(Disabled)
}

// DnsConfig contains the desired set of options for configuring clusterDNS.
#DnsConfig: {
	// ClusterDns indicates which in-cluster DNS provider should be used.
	// Possible values:
	//   "PROVIDER_UNSPECIFIED" - indicates the default value.
	//   "PLATFORM_DEFAULT" - indicates using the GKE default DNS
	//  provider(kube-dns) for DNS resolution.
	//   "CLOUD_DNS" - indicates using CloudDNS for DNS resolution.
	// +kubebuilder:validation:Enum=PROVIDER_UNSPECIFIED;PLATFORM_DEFAULT;CLOUD_DNS
	// +optional
	clusterDns?: null | string @go(ClusterDns,*string)

	// ClusterDnsScope indicates the scope of access to cluster DNS records.
	// Possible Values:
	//   "DNS_SCOPE_UNSPECIFIED" - indicates the default value,
	//  will be inferred as cluster scope.
	//   "VPC_SCOPE" - indicates that DNS records are accessible from within the VPC.
	// +kubebuilder:validation:Enum=DNS_SCOPE_UNSPECIFIED;VPC_SCOPE
	// +optional
	clusterDnsScope?: null | string @go(ClusterDnsScope,*string)

	// ClusterDnsDomain is the suffix used for all cluster service records.
	// +optional
	clusterDnsDomain?: null | string @go(ClusterDnsDomain,*string)
}

// NetworkConfigStatus reports the relative names of network &
// subnetwork.
#NetworkConfigStatus: {
	// Network: The relative name of the Google Compute
	// Engine
	// network(https://cloud.google.com/vpc/docs/vpc#vpc_networks_and_subnets) to which
	// the cluster is connected.
	// Example: projects/my-project/global/networks/my-network
	network?: string @go(Network)

	// Subnetwork: The relative name of the Google Compute
	// Engine
	// [subnetwork](https://cloud.google.com/vpc/docs/vpc) to which the cluster is
	// connected.
	// Example:
	// projects/my-project/regions/us-central1/subnetworks/my-subnet
	subnetwork?: string @go(Subnetwork)
}

// NetworkPolicy is configuration options for the NetworkPolicy
// feature.
// https://kubernetes.io/docs/concepts/services-networking/netwo
// rkpolicies/
#NetworkPolicy: {
	// Enabled: Whether network policy is enabled on the cluster.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// Provider: The selected network policy provider.
	//
	// Possible values:
	//   "PROVIDER_UNSPECIFIED" - Not set
	//   "CALICO" - Tigera (Calico Felix).
	// +optional
	provider?: null | string @go(Provider,*string)
}

// PrivateClusterConfigSpec is configuration options for private clusters.
#PrivateClusterConfigSpec: {
	// EnablePrivateEndpoint: Whether the master's internal IP address is
	// used as the cluster endpoint.
	// +optional
	enablePrivateEndpoint?: null | bool @go(EnablePrivateEndpoint,*bool)

	// EnablePrivateNodes: Whether nodes have internal IP addresses only. If
	// enabled, all nodes are
	// given only RFC 1918 private addresses and communicate with the master
	// via
	// private networking.
	// +optional
	enablePrivateNodes?: null | bool @go(EnablePrivateNodes,*bool)

	// MasterGlobalAccessConfig: Controls master global access settings.
	// +optional
	masterGlobalAccessConfig?: null | #PrivateClusterMasterGlobalAccessConfig @go(MasterGlobalAccessConfig,*PrivateClusterMasterGlobalAccessConfig)

	// MasterIpv4CidrBlock: The IP range in CIDR notation to use for the
	// hosted master network. This
	// range will be used for assigning internal IP addresses to the master
	// or
	// set of masters, as well as the ILB VIP. This range must not overlap
	// with
	// any other ranges in use within the cluster's network.
	// +optional
	masterIpv4CidrBlock?: null | string @go(MasterIpv4CidrBlock,*string)
}

// PrivateClusterMasterGlobalAccessConfig is Configuration for controlling
// master global access settings.
#PrivateClusterMasterGlobalAccessConfig: {
	// Enabled: Whenever master is accessible globally or not.
	enabled: bool @go(Enabled)
}

// PrivateClusterConfigStatus is configuration options for private clusters.
#PrivateClusterConfigStatus: {
	// PrivateEndpoint: The internal IP address of this
	// cluster's master endpoint.
	privateEndpoint?: string @go(PrivateEndpoint)

	// PublicEndpoint: The external IP address of this
	// cluster's master endpoint.
	publicEndpoint?: string @go(PublicEndpoint)
}

// ResourceUsageExportConfig is configuration for exporting cluster
// resource usages.
#ResourceUsageExportConfig: {
	// BigqueryDestination: Configuration to use BigQuery as usage export
	// destination.
	// +optional
	bigqueryDestination?: null | #BigQueryDestination @go(BigqueryDestination,*BigQueryDestination)

	// ConsumptionMeteringConfig: Configuration to enable resource
	// consumption metering.
	// +optional
	consumptionMeteringConfig?: null | #ConsumptionMeteringConfig @go(ConsumptionMeteringConfig,*ConsumptionMeteringConfig)

	// EnableNetworkEgressMetering: Whether to enable network egress
	// metering for this cluster. If enabled, a
	// daemonset will be created in the cluster to meter network egress
	// traffic.
	// +optional
	enableNetworkEgressMetering?: null | bool @go(EnableNetworkEgressMetering,*bool)
}

// BigQueryDestination is parameters for using BigQuery as the destination
// of resource usage export.
#BigQueryDestination: {
	// DatasetId: The ID of a BigQuery Dataset.
	datasetId: string @go(DatasetID)
}

// ConsumptionMeteringConfig is parameters for controlling consumption
// metering.
#ConsumptionMeteringConfig: {
	// Enabled: Whether to enable consumption metering for this cluster. If
	// enabled, a
	// second BigQuery table will be created to hold resource
	// consumption
	// records.
	enabled: bool @go(Enabled)
}

// VerticalPodAutoscaling contains global,
// per-cluster information
// required by Vertical Pod Autoscaler to automatically adjust
// the resources of pods controlled by it.
#VerticalPodAutoscaling: {
	// Enabled: Enables vertical pod autoscaling.
	enabled: bool @go(Enabled)
}

// WorkloadIdentityConfig is configuration for the use of Kubernetes
// Service Accounts in GCP IAM
// policies.
#WorkloadIdentityConfig: {
	// WorkloadPool: The workload pool to attach all Kubernetes service
	// accounts to.
	workloadPool?: string @go(WorkloadPool)
}

// NodePoolClusterStatus is a subset of information about NodePools associated
// with a GKE cluster.
#NodePoolClusterStatus: {
	// Autoscaling: Autoscaler configuration for this NodePool. Autoscaler
	// is enabled
	// only if a valid configuration is present.
	autoscaling?: null | #NodePoolAutoscalingClusterStatus @go(Autoscaling,*NodePoolAutoscalingClusterStatus)

	// Conditions: Which conditions caused the current node pool state.
	conditions?: [...null | #StatusCondition] @go(Conditions,[]*StatusCondition)

	// Config: The node configuration of the pool.
	config?: null | #NodeConfigClusterStatus @go(Config,*NodeConfigClusterStatus)

	// InitialNodeCount: The initial node count for the pool. You must
	// ensure that your
	// Compute Engine <a href="https://cloud.google.com/compute/quotas">resource
	// quota</a>
	// is sufficient for this number of instances. You must also have
	// available
	// firewall and routes quota.
	initialNodeCount?: int64 @go(InitialNodeCount)

	// InstanceGroupUrls: The resource URLs of the [managed
	// instance
	// groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
	// associated with this node pool.
	instanceGroupUrls?: [...string] @go(InstanceGroupUrls,[]string)

	// Locations: The list of Google Compute Engine
	// [zones](https://cloud.google.com/compute/docs/regions-zones#available)
	// in which the NodePool's nodes should be located.
	locations?: [...string] @go(Locations,[]string)

	// Management: NodeManagement configuration for this NodePool.
	management?: null | #NodeManagementClusterStatus @go(Management,*NodeManagementClusterStatus)

	// MaxPodsConstraint: The constraint on the maximum number of pods that
	// can be run
	// simultaneously on a node in the node pool.
	maxPodsConstraint?: null | #MaxPodsConstraint @go(MaxPodsConstraint,*MaxPodsConstraint)

	// Name: The name of the node pool.
	name?: string @go(Name)

	// PodIpv4CidrSize: The pod CIDR block size per node in
	// this node pool.
	podIpv4CidrSize?: int64 @go(PodIpv4CidrSize)

	// SelfLink: Server-defined URL for the resource.
	selfLink?: string @go(SelfLink)

	// Status: The status of the nodes in this pool instance.
	//
	// Possible values:
	//   "STATUS_UNSPECIFIED" - Not set.
	//   "PROVISIONING" - The PROVISIONING state indicates the node pool is
	// being created.
	//   "RUNNING" - The RUNNING state indicates the node pool has been
	// created
	// and is fully usable.
	//   "RUNNING_WITH_ERROR" - The RUNNING_WITH_ERROR state indicates the
	// node pool has been created
	// and is partially usable. Some error state has occurred and
	// some
	// functionality may be impaired. Customer may need to reissue a
	// request
	// or trigger a new update.
	//   "RECONCILING" - The RECONCILING state indicates that some work is
	// actively being done on
	// the node pool, such as upgrading node software. Details can
	// be found in the `statusMessage` field.
	//   "STOPPING" - The STOPPING state indicates the node pool is being
	// deleted.
	//   "ERROR" - The ERROR state indicates the node pool may be unusable.
	// Details
	// can be found in the `statusMessage` field.
	status?: string @go(Status)

	// StatusMessage: Additional information about the current
	// status of this
	// node pool instance, if available.
	statusMessage?: string @go(StatusMessage)

	// Version: The version of the Kubernetes of this node.
	version?: string @go(Version)
}

// NodePoolAutoscalingClusterStatus contains information required by cluster
// autoscaler to adjust the size of the node pool to the current cluster usage.
#NodePoolAutoscalingClusterStatus: {
	// Autoprovisioned: Can this node pool be deleted automatically.
	autoprovisioned?: bool @go(Autoprovisioned)

	// Enabled: Is autoscaling enabled for this node pool.
	enabled?: bool @go(Enabled)

	// MaxNodeCount: Maximum number of nodes in the NodePool. Must be >=
	// min_node_count. There
	// has to enough quota to scale up the cluster.
	maxNodeCount?: int64 @go(MaxNodeCount)

	// MinNodeCount: Minimum number of nodes in the NodePool. Must be >= 1
	// and <=
	// max_node_count.
	minNodeCount?: int64 @go(MinNodeCount)
}

// NodeConfigClusterStatus is the configuration of the node pool.
#NodeConfigClusterStatus: {
	// Accelerators: A list of hardware accelerators to be attached to each
	// node.
	// See https://cloud.google.com/compute/docs/gpus for more information
	// about
	// support for GPUs.
	accelerators?: [...null | #AcceleratorConfigClusterStatus] @go(Accelerators,[]*AcceleratorConfigClusterStatus)

	// DiskSizeGb: Size of the disk attached to each node, specified in
	// GB.
	// The smallest allowed disk size is 10GB.
	//
	// If unspecified, the default disk size is 100GB.
	diskSizeGb?: int64 @go(DiskSizeGb)

	// DiskType: Type of the disk attached to each node (e.g. 'pd-standard'
	// or 'pd-ssd')
	//
	// If unspecified, the default disk type is 'pd-standard'
	diskType?: string @go(DiskType)

	// ImageType: The image type to use for this node. Note that for a given
	// image type,
	// the latest version of it will be used.
	imageType?: string @go(ImageType)

	// Labels: The map of Kubernetes labels (key/value pairs) to be applied
	// to each node.
	// These will added in addition to any default label(s) that
	// Kubernetes may apply to the node.
	// In case of conflict in label keys, the applied set may differ
	// depending on
	// the Kubernetes version -- it's best to assume the behavior is
	// undefined
	// and conflicts should be avoided.
	// For more information, including usage and the valid values,
	// see:
	// https://kubernetes.io/docs/concepts/overview/working-with-objects
	// /labels/
	labels?: {[string]: string} @go(Labels,map[string]string)

	// LocalSsdCount: The number of local SSD disks to be attached to the
	// node.
	//
	// The limit for this value is dependant upon the maximum number
	// of
	// disks available on a machine per zone.
	// See:
	// https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_l
	// imits
	// for more information.
	localSsdCount?: int64 @go(LocalSsdCount)

	// MachineType: The name of a Google Compute Engine
	// [machine
	// type](https://cloud.google.com/compute/docs/machine-types) (e.g.
	// `n1-standard-1`).
	//
	// If unspecified, the default machine type is
	// `n1-standard-1`.
	machineType?: string @go(MachineType)

	// Metadata: The metadata key/value pairs assigned to instances in the
	// cluster.
	//
	// Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128
	// bytes
	// in length. These are reflected as part of a URL in the metadata
	// server.
	// Additionally, to avoid ambiguity, keys must not conflict with any
	// other
	// metadata keys for the project or be one of the reserved keys:
	//  "cluster-location"
	//  "cluster-name"
	//  "cluster-uid"
	//  "configure-sh"
	//  "containerd-configure-sh"
	//  "enable-oslogin"
	//  "gci-ensure-gke-docker"
	//  "gci-update-strategy"
	//  "instance-template"
	//  "kube-env"
	//  "startup-script"
	//  "user-data"
	//  "disable-address-manager"
	//  "windows-startup-script-ps1"
	//  "common-psm1"
	//  "k8s-node-setup-psm1"
	//  "install-ssh-psm1"
	//  "user-profile-psm1"
	//  "serial-port-logging-enable"
	// Values are free-form strings, and only have meaning as interpreted
	// by
	// the image running in the instance. The only restriction placed on
	// them is
	// that each value's size must be less than or equal to 32 KB.
	//
	// The total size of all keys and values must be less than 512 KB.
	metadata?: {[string]: string} @go(Metadata,map[string]string)

	// MinCpuPlatform: Minimum CPU platform to be used by this instance. The
	// instance may be
	// scheduled on the specified or newer CPU platform. Applicable values
	// are the
	// friendly names of CPU platforms, such as
	// <code>minCpuPlatform: &quot;Intel Haswell&quot;</code>
	// or
	// <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For
	// more
	// information, read [how to specify min
	// CPU
	// platform](https://cloud.google.com/compute/docs/instances/specify-
	// min-cpu-platform)
	minCpuPlatform?: string @go(MinCPUPlatform)

	// OauthScopes: The set of Google API scopes to be made available on all
	// of the
	// node VMs under the "default" service account.
	//
	// The following scopes are recommended, but not required, and by
	// default are
	// not included:
	//
	// * `https://www.googleapis.com/auth/compute` is required for
	// mounting
	// persistent storage on your nodes.
	// * `https://www.googleapis.com/auth/devstorage.read_only` is required
	// for
	// communicating with **gcr.io**
	// (the [Google Container Registry](/container-registry/)).
	//
	// If unspecified, no scopes are added, unless Cloud Logging or
	// Cloud
	// Monitoring are enabled, in which case their required scopes will be
	// added.
	oauthScopes?: [...string] @go(OauthScopes,[]string)

	// Preemptible: Whether the nodes are created as preemptible VM
	// instances.
	// See:
	// https://cloud.google.com/compute/docs/instances/preemptible for
	// more
	// inforamtion about preemptible VM instances.
	preemptible?: bool @go(Preemptible)

	// SandboxConfig: Sandbox configuration for this node.
	sandboxConfig?: null | #SandboxConfigClusterStatus @go(SandboxConfig,*SandboxConfigClusterStatus)

	// ServiceAccount: The Google Cloud Platform Service Account to be used
	// by the node VMs. If
	// no Service Account is specified, the "default" service account is
	// used.
	serviceAccount?: string @go(ServiceAccount)

	// ShieldedInstanceConfig: Shielded Instance options.
	shieldedInstanceConfig?: null | #ShieldedInstanceConfigClusterStatus @go(ShieldedInstanceConfig,*ShieldedInstanceConfigClusterStatus)

	// Tags: The list of instance tags applied to all nodes. Tags are used
	// to identify
	// valid sources or targets for network firewalls and are specified
	// by
	// the client during cluster or node pool creation. Each tag within the
	// list
	// must comply with RFC1035.
	tags?: [...string] @go(Tags,[]string)

	// Taints: List of kubernetes taints to be applied to each node.
	//
	// For more information, including usage and the valid values,
	// see:
	// https://kubernetes.io/docs/concepts/configuration/taint-and-toler
	// ation/
	taints?: [...null | #NodeTaintClusterStatus] @go(Taints,[]*NodeTaintClusterStatus)
}

// AcceleratorConfigClusterStatus represents a Hardware
// Accelerator request.
#AcceleratorConfigClusterStatus: {
	// AcceleratorCount: The number of the accelerator cards exposed to an
	// instance.
	acceleratorCount?: int64 @go(AcceleratorCount)

	// AcceleratorType: The accelerator type resource name. List of
	// supported accelerators
	// [here](https://cloud.google.com/compute/docs/gpus/#Introduction)
	acceleratorType?: string @go(AcceleratorType)
}

// SandboxConfigClusterStatus contains configurations of the sandbox to use for
// the node.
#SandboxConfigClusterStatus: {
	// Type: Type of the sandbox to use for the node (e.g. 'gvisor')
	type?: string @go(Type)
}

// ShieldedInstanceConfigClusterStatus is a set of Shielded Instance options.
#ShieldedInstanceConfigClusterStatus: {
	// EnableIntegrityMonitoring: Defines whether the instance has integrity
	// monitoring enabled.
	//
	// Enables monitoring and attestation of the boot integrity of the
	// instance.
	// The attestation is performed against the integrity policy baseline.
	// This
	// baseline is initially derived from the implicitly trusted boot image
	// when
	// the instance is created.
	enableIntegrityMonitoring?: bool @go(EnableIntegrityMonitoring)

	// EnableSecureBoot: Defines whether the instance has Secure Boot
	// enabled.
	//
	// Secure Boot helps ensure that the system only runs authentic software
	// by
	// verifying the digital signature of all boot components, and halting
	// the
	// boot process if signature verification fails.
	enableSecureBoot?: bool @go(EnableSecureBoot)
}

// NodeTaintClusterStatus is a Kubernetes taint is comprised of three fields:
// key, value, and effect. Effect can only be one of three types:  NoSchedule,
// PreferNoSchedule or NoExecute.
#NodeTaintClusterStatus: {
	// Effect: Effect for taint.
	//
	// Possible values:
	//   "EFFECT_UNSPECIFIED" - Not set
	//   "NO_SCHEDULE" - NoSchedule
	//   "PREFER_NO_SCHEDULE" - PreferNoSchedule
	//   "NO_EXECUTE" - NoExecute
	effect?: string @go(Effect)

	// Key: Key for taint.
	key?: string @go(Key)

	// Value: Value for taint.
	value?: string @go(Value)
}

// NodeManagementClusterStatus defines the set of node management services
// turned on for the node pool.
#NodeManagementClusterStatus: {
	// AutoRepair: Whether the nodes will be automatically repaired.
	autoRepair?: bool @go(AutoRepair)

	// AutoUpgrade: Whether the nodes will be automatically upgraded.
	autoUpgrade?: bool @go(AutoUpgrade)

	// UpgradeOptions: Specifies the Auto Upgrade knobs for the node pool.
	upgradeOptions?: null | #AutoUpgradeOptionsClusterStatus @go(UpgradeOptions,*AutoUpgradeOptionsClusterStatus)
}

// AutoUpgradeOptionsClusterStatus defines the set of options for the user to
// control how the Auto Upgrades will proceed.
#AutoUpgradeOptionsClusterStatus: {
	// AutoUpgradeStartTime: This field is set when upgrades
	// are about to commence
	// with the approximate start time for the upgrades,
	// in
	// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
	autoUpgradeStartTime?: string @go(AutoUpgradeStartTime)

	// Description: This field is set when upgrades are about
	// to commence
	// with the description of the upgrade.
	description?: string @go(Description)
}

// A ClusterSpec defines the desired state of a Cluster.
#ClusterSpec: {
	forProvider: #ClusterParameters @go(ForProvider)
}

// A ClusterStatus represents the observed state of a Cluster.
#ClusterStatus: {
	atProvider?: #ClusterObservation @go(AtProvider)
}

// A Cluster is a managed resource that represents a Google Kubernetes Engine
// cluster.
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="STATE",type="string",JSONPath=".status.atProvider.status"
// +kubebuilder:printcolumn:name="ENDPOINT",type="string",JSONPath=".status.atProvider.endpoint"
// +kubebuilder:printcolumn:name="LOCATION",type="string",JSONPath=".spec.forProvider.location"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#Cluster: {
	spec:    #ClusterSpec   @go(Spec)
	status?: #ClusterStatus @go(Status)
}

// ClusterList contains a list of Cluster items
#ClusterList: {
	items: [...#Cluster] @go(Items,[]Cluster)
}
