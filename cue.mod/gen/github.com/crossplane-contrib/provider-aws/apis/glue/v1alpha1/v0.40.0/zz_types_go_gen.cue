// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane-contrib/provider-aws/apis/glue/v1alpha1

package v1alpha1

// +kubebuilder:skipversion
#Action: {
	arguments?: {[string]: null | string} @go(Arguments,map[string]*string)
	crawlerName?: null | string @go(CrawlerName,*string)
	jobName?:     null | string @go(JobName,*string)

	// Specifies configuration properties of a notification.
	notificationProperty?:  null | #NotificationProperty @go(NotificationProperty,*NotificationProperty)
	securityConfiguration?: null | string                @go(SecurityConfiguration,*string)
	timeout?:               null | int64                 @go(Timeout,*int64)
}

// +kubebuilder:skipversion
#Aggregate: {
	aggs?: [...null | #AggregateOperation] @go(Aggs,[]*AggregateOperation)
	groups?: [...[...null | string]] @go(Groups,[][]*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#AggregateOperation: {
	aggFunc?: null | string @go(AggFunc,*string)
	column?: [...null | string] @go(Column,[]*string)
}

// +kubebuilder:skipversion
#ApplyMapping: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	mapping?: [...null | #Mapping] @go(Mapping,[]*Mapping)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#AthenaConnectorSource: {
	connectionName?:  null | string @go(ConnectionName,*string)
	connectionTable?: null | string @go(ConnectionTable,*string)
	connectionType?:  null | string @go(ConnectionType,*string)
	connectorName?:   null | string @go(ConnectorName,*string)
	name?:            null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	schemaName?: null | string @go(SchemaName,*string)
}

// +kubebuilder:skipversion
#AuditContext: {
	allColumnsRequested?: null | bool @go(AllColumnsRequested,*bool)
}

// +kubebuilder:skipversion
#BasicCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:  null | string @go(Name,*string)
	table?: null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#BatchStopJobRunError: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#BatchStopJobRunSuccessfulSubmission: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#Blueprint: {
	blueprintLocation?:        null | string @go(BlueprintLocation,*string)
	blueprintServiceLocation?: null | string @go(BlueprintServiceLocation,*string)
	description?:              null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#BlueprintRun: {
	workflowName?: null | string @go(WorkflowName,*string)
}

// +kubebuilder:skipversion
#CatalogEntry: {
	databaseName?: null | string @go(DatabaseName,*string)
	tableName?:    null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#CatalogImportStatus: {
	importCompleted?: null | bool   @go(ImportCompleted,*bool)
	importedBy?:      null | string @go(ImportedBy,*string)
}

// +kubebuilder:skipversion
#CatalogKafkaSource: {
	// Specifies options related to data preview for viewing a sample of your data.
	dataPreviewOptions?: null | #StreamingDataPreviewOptions @go(DataPreviewOptions,*StreamingDataPreviewOptions)
	database?:           null | string                       @go(Database,*string)
	detectSchema?:       null | bool                         @go(DetectSchema,*bool)
	name?:               null | string                       @go(Name,*string)

	// Additional options for streaming.
	streamingOptions?: null | #KafkaStreamingSourceOptions @go(StreamingOptions,*KafkaStreamingSourceOptions)
	table?:            null | string                       @go(Table,*string)
	windowSize?:       null | int64                        @go(WindowSize,*int64)
}

// +kubebuilder:skipversion
#CatalogKinesisSource: {
	// Specifies options related to data preview for viewing a sample of your data.
	dataPreviewOptions?: null | #StreamingDataPreviewOptions @go(DataPreviewOptions,*StreamingDataPreviewOptions)
	database?:           null | string                       @go(Database,*string)
	detectSchema?:       null | bool                         @go(DetectSchema,*bool)
	name?:               null | string                       @go(Name,*string)

	// Additional options for the Amazon Kinesis streaming data source.
	streamingOptions?: null | #KinesisStreamingSourceOptions @go(StreamingOptions,*KinesisStreamingSourceOptions)
	table?:            null | string                         @go(Table,*string)
	windowSize?:       null | int64                          @go(WindowSize,*int64)
}

// +kubebuilder:skipversion
#CatalogSchemaChangePolicy: {
	enableUpdateCatalog?: null | bool   @go(EnableUpdateCatalog,*bool)
	updateBehavior?:      null | string @go(UpdateBehavior,*string)
}

// +kubebuilder:skipversion
#CatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#CatalogTarget: {
	connectionName?:   null | string @go(ConnectionName,*string)
	databaseName?:     null | string @go(DatabaseName,*string)
	dlqEventQueueARN?: null | string @go(DlqEventQueueARN,*string)
	eventQueueARN?:    null | string @go(EventQueueARN,*string)
	tables?: [...null | string] @go(Tables,[]*string)
}

// +kubebuilder:skipversion
#Classifier_SDK: {
	// A classifier for custom CSV content.
	csvClassifier?: null | #CsvClassifier @go(CsvClassifier,*CsvClassifier)

	// A classifier that uses grok patterns.
	grokClassifier?: null | #GrokClassifier @go(GrokClassifier,*GrokClassifier)

	// A classifier for JSON content.
	jsonClassifier?: null | #JSONClassifier @go(JSONClassifier,*JSONClassifier)

	// A classifier for XML content.
	xmlClassifier?: null | #XMLClassifier @go(XMLClassifier,*XMLClassifier)
}

// +kubebuilder:skipversion
#CloudWatchEncryption: {
	cloudWatchEncryptionMode?: null | string @go(CloudWatchEncryptionMode,*string)
	kmsKeyARN?:                null | string @go(KMSKeyARN,*string)
}

// +kubebuilder:skipversion
#CodeGenConfigurationNode: {
	// Specifies a transform that groups rows by chosen fields and computes the
	// aggregated value by specified function.
	aggregate?: null | #Aggregate @go(Aggregate,*Aggregate)

	// Specifies a transform that maps data property keys in the data source to
	// data property keys in the data target. You can rename keys, modify the data
	// types for keys, and choose which keys to drop from the dataset.
	applyMapping?: null | #ApplyMapping @go(ApplyMapping,*ApplyMapping)

	// Specifies a connector to an Amazon Athena data source.
	athenaConnectorSource?: null | #AthenaConnectorSource @go(AthenaConnectorSource,*AthenaConnectorSource)

	// Specifies an Apache Kafka data store in the Data Catalog.
	catalogKafkaSource?: null | #CatalogKafkaSource @go(CatalogKafkaSource,*CatalogKafkaSource)

	// Specifies a Kinesis data source in the Glue Data Catalog.
	catalogKinesisSource?: null | #CatalogKinesisSource @go(CatalogKinesisSource,*CatalogKinesisSource)

	// Specifies a data store in the Glue Data Catalog.
	catalogSource?: null | #CatalogSource @go(CatalogSource,*CatalogSource)

	// Specifies a target that uses a Glue Data Catalog table.
	catalogTarget?: null | #BasicCatalogTarget @go(CatalogTarget,*BasicCatalogTarget)

	// Specifies a transform that uses custom code you provide to perform the data
	// transformation. The output is a collection of DynamicFrames.
	customCode?: null | #CustomCode @go(CustomCode,*CustomCode)

	// Specifies an Apache Kafka data store.
	directKafkaSource?: null | #DirectKafkaSource @go(DirectKafkaSource,*DirectKafkaSource)

	// Specifies a direct Amazon Kinesis data source.
	directKinesisSource?: null | #DirectKinesisSource @go(DirectKinesisSource,*DirectKinesisSource)

	// Specifies a transform that removes rows of repeating data from a data set.
	dropDuplicates?: null | #DropDuplicates @go(DropDuplicates,*DropDuplicates)

	// Specifies a transform that chooses the data property keys that you want to
	// drop.
	dropFields?: null | #DropFields @go(DropFields,*DropFields)

	// Specifies a transform that removes columns from the dataset if all values
	// in the column are 'null'. By default, Glue Studio will recognize null objects,
	// but some values such as empty strings, strings that are "null", -1 integers
	// or other placeholders such as zeros, are not automatically recognized as
	// nulls.
	dropNullFields?: null | #DropNullFields @go(DropNullFields,*DropNullFields)

	// Specifies the set of parameters needed to perform the dynamic transform.
	dynamicTransform?: null | #DynamicTransform @go(DynamicTransform,*DynamicTransform)

	// Specifies a DynamoDB data source in the Glue Data Catalog.
	dynamoDBCatalogSource?: null | #DynamoDBCatalogSource @go(DynamoDBCatalogSource,*DynamoDBCatalogSource)

	// Specifies your data quality evaluation criteria.
	evaluateDataQuality?: null | #EvaluateDataQuality @go(EvaluateDataQuality,*EvaluateDataQuality)

	// Specifies a transform that locates records in the dataset that have missing
	// values and adds a new field with a value determined by imputation. The input
	// data set is used to train the machine learning model that determines what
	// the missing value should be.
	fillMissingValues?: null | #FillMissingValues @go(FillMissingValues,*FillMissingValues)

	// Specifies a transform that splits a dataset into two, based on a filter condition.
	filter?: null | #Filter @go(Filter,*Filter)

	// Specifies the data store in the governed Glue Data Catalog.
	governedCatalogSource?: null | #GovernedCatalogSource @go(GovernedCatalogSource,*GovernedCatalogSource)

	// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
	governedCatalogTarget?: null | #GovernedCatalogTarget @go(GovernedCatalogTarget,*GovernedCatalogTarget)

	// Specifies a connector to a JDBC data source.
	jDBCConnectorSource?: null | #JDBCConnectorSource @go(JDBCConnectorSource,*JDBCConnectorSource)

	// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar
	// storage.
	jDBCConnectorTarget?: null | #JDBCConnectorTarget @go(JDBCConnectorTarget,*JDBCConnectorTarget)

	// Specifies a transform that joins two datasets into one dataset using a comparison
	// phrase on the specified data property keys. You can use inner, outer, left,
	// right, left semi, and left anti joins.
	join?: null | #Join @go(Join,*Join)

	// Specifies a transform that merges a DynamicFrame with a staging DynamicFrame
	// based on the specified primary keys to identify records. Duplicate records
	// (records with the same primary keys) are not de-duplicated.
	merge?: null | #Merge @go(Merge,*Merge)

	// Specifies a Microsoft SQL server data source in the Glue Data Catalog.
	microsoftSQLServerCatalogSource?: null | #MicrosoftSQLServerCatalogSource @go(MicrosoftSQLServerCatalogSource,*MicrosoftSQLServerCatalogSource)

	// Specifies a target that uses Microsoft SQL.
	microsoftSQLServerCatalogTarget?: null | #MicrosoftSQLServerCatalogTarget @go(MicrosoftSQLServerCatalogTarget,*MicrosoftSQLServerCatalogTarget)

	// Specifies a MySQL data source in the Glue Data Catalog.
	mySQLCatalogSource?: null | #MySQLCatalogSource @go(MySQLCatalogSource,*MySQLCatalogSource)

	// Specifies a target that uses MySQL.
	mySQLCatalogTarget?: null | #MySQLCatalogTarget @go(MySQLCatalogTarget,*MySQLCatalogTarget)

	// Specifies an Oracle data source in the Glue Data Catalog.
	oracleSQLCatalogSource?: null | #OracleSQLCatalogSource @go(OracleSQLCatalogSource,*OracleSQLCatalogSource)

	// Specifies a target that uses Oracle SQL.
	oracleSQLCatalogTarget?: null | #OracleSQLCatalogTarget @go(OracleSQLCatalogTarget,*OracleSQLCatalogTarget)

	// Specifies a transform that identifies, removes or masks PII data.
	pIIDetection?: null | #PIIDetection @go(PIIDetection,*PIIDetection)

	// Specifies a PostgresSQL data source in the Glue Data Catalog.
	postgreSQLCatalogSource?: null | #PostgreSQLCatalogSource @go(PostgreSQLCatalogSource,*PostgreSQLCatalogSource)

	// Specifies a target that uses Postgres SQL.
	postgreSQLCatalogTarget?: null | #PostgreSQLCatalogTarget @go(PostgreSQLCatalogTarget,*PostgreSQLCatalogTarget)

	// Specifies an Amazon Redshift data store.
	redshiftSource?: null | #RedshiftSource @go(RedshiftSource,*RedshiftSource)

	// Specifies a target that uses Amazon Redshift.
	redshiftTarget?: null | #RedshiftTarget @go(RedshiftTarget,*RedshiftTarget)

	// Specifies a Relational database data source in the Glue Data Catalog.
	relationalCatalogSource?: null | #RelationalCatalogSource @go(RelationalCatalogSource,*RelationalCatalogSource)

	// Specifies a transform that renames a single data property key.
	renameField?: null | #RenameField @go(RenameField,*RenameField)

	// Specifies an Amazon S3 data store in the Glue Data Catalog.
	s3CatalogSource?: null | #S3CatalogSource @go(S3CatalogSource,*S3CatalogSource)

	// Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.
	s3CatalogTarget?: null | #S3CatalogTarget @go(S3CatalogTarget,*S3CatalogTarget)

	// Specifies a command-separated value (CSV) data store stored in Amazon S3.
	s3CsvSource?: null | #S3CsvSource @go(S3CsvSource,*S3CsvSource)

	// Specifies a data target that writes to Amazon S3.
	s3DirectTarget?: null | #S3DirectTarget @go(S3DirectTarget,*S3DirectTarget)

	// Specifies a data target that writes to Amazon S3 in Apache Parquet columnar
	// storage.
	s3GlueParquetTarget?: null | #S3GlueParquetTarget @go(S3GlueParquetTarget,*S3GlueParquetTarget)

	// Specifies a JSON data store stored in Amazon S3.
	s3JSONSource?: null | #S3JSONSource @go(S3JSONSource,*S3JSONSource)

	// Specifies an Apache Parquet data store stored in Amazon S3.
	s3ParquetSource?: null | #S3ParquetSource @go(S3ParquetSource,*S3ParquetSource)

	// Specifies a transform that chooses the data property keys that you want to
	// keep.
	selectFields?: null | #SelectFields @go(SelectFields,*SelectFields)

	// Specifies a transform that chooses one DynamicFrame from a collection of
	// DynamicFrames. The output is the selected DynamicFrame
	selectFromCollection?: null | #SelectFromCollection @go(SelectFromCollection,*SelectFromCollection)

	// Specifies a connector to an Apache Spark data source.
	sparkConnectorSource?: null | #SparkConnectorSource @go(SparkConnectorSource,*SparkConnectorSource)

	// Specifies a target that uses an Apache Spark connector.
	sparkConnectorTarget?: null | #SparkConnectorTarget @go(SparkConnectorTarget,*SparkConnectorTarget)

	// Specifies a transform where you enter a SQL query using Spark SQL syntax
	// to transform the data. The output is a single DynamicFrame.
	sparkSQL?: null | #SparkSQL @go(SparkSQL,*SparkSQL)

	// Specifies a transform that writes samples of the data to an Amazon S3 bucket.
	spigot?: null | #Spigot @go(Spigot,*Spigot)

	// Specifies a transform that splits data property keys into two DynamicFrames.
	// The output is a collection of DynamicFrames: one with selected data property
	// keys, and one with the remaining data property keys.
	splitFields?: null | #SplitFields @go(SplitFields,*SplitFields)

	// Specifies a transform that combines the rows from two or more datasets into
	// a single result.
	union?: null | #Union @go(Union,*Union)
}

// +kubebuilder:skipversion
#CodeGenNodeArg: {
	param?: null | bool @go(Param,*bool)
}

// +kubebuilder:skipversion
#Column: {
	name?: null | string @go(Name,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#ColumnError: {
	columnName?: null | string @go(ColumnName,*string)
}

// +kubebuilder:skipversion
#ColumnImportance: {
	columnName?: null | string @go(ColumnName,*string)
}

// +kubebuilder:skipversion
#ColumnRowFilter: {
	columnName?: null | string @go(ColumnName,*string)
}

// +kubebuilder:skipversion
#ColumnStatistics: {
	columnName?: null | string @go(ColumnName,*string)
}

// +kubebuilder:skipversion
#Condition: {
	crawlerName?: null | string @go(CrawlerName,*string)
	jobName?:     null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#ConnectionInput: {
	connectionProperties?: {[string]: null | string} @go(ConnectionProperties,map[string]*string)
	connectionType?: null | string @go(ConnectionType,*string)
	description?:    null | string @go(Description,*string)
	matchCriteria?: [...null | string] @go(MatchCriteria,[]*string)
	name?: null | string @go(Name,*string)

	// Specifies the physical requirements for a connection.
	physicalConnectionRequirements?: null | #PhysicalConnectionRequirements @go(PhysicalConnectionRequirements,*PhysicalConnectionRequirements)
}

// +kubebuilder:skipversion
#ConnectionPasswordEncryption: {
	awsKMSKeyID?:                       null | string @go(AWSKMSKeyID,*string)
	returnConnectionPasswordEncrypted?: null | bool   @go(ReturnConnectionPasswordEncrypted,*bool)
}

// +kubebuilder:skipversion
#Connection_SDK: {
	connectionProperties?: {[string]: null | string} @go(ConnectionProperties,map[string]*string)
	connectionType?: null | string @go(ConnectionType,*string)
	description?:    null | string @go(Description,*string)
	lastUpdatedBy?:  null | string @go(LastUpdatedBy,*string)
	matchCriteria?: [...null | string] @go(MatchCriteria,[]*string)
	name?: null | string @go(Name,*string)

	// Specifies the physical requirements for a connection.
	physicalConnectionRequirements?: null | #PhysicalConnectionRequirements @go(PhysicalConnectionRequirements,*PhysicalConnectionRequirements)
}

// +kubebuilder:skipversion
#ConnectionsList: {
	connections?: [...null | string] @go(Connections,[]*string)
}

// +kubebuilder:skipversion
#Crawl: {
	errorMessage?: null | string @go(ErrorMessage,*string)
	logGroup?:     null | string @go(LogGroup,*string)
	logStream?:    null | string @go(LogStream,*string)
}

// +kubebuilder:skipversion
#CrawlerHistory: {
	errorMessage?:  null | string @go(ErrorMessage,*string)
	logGroup?:      null | string @go(LogGroup,*string)
	logStream?:     null | string @go(LogStream,*string)
	messagePrefix?: null | string @go(MessagePrefix,*string)
	summary?:       null | string @go(Summary,*string)
}

// +kubebuilder:skipversion
#CrawlerMetrics: {
	crawlerName?:     null | string @go(CrawlerName,*string)
	stillEstimating?: null | bool   @go(StillEstimating,*bool)
}

// +kubebuilder:skipversion
#CrawlerTargets: {
	catalogTargets?: [...null | #CatalogTarget] @go(CatalogTargets,[]*CatalogTarget)
	deltaTargets?: [...null | #DeltaTarget] @go(DeltaTargets,[]*DeltaTarget)
	dynamoDBTargets?: [...null | #DynamoDBTarget] @go(DynamoDBTargets,[]*DynamoDBTarget)
	jdbcTargets?: [...null | #JdbcTarget] @go(JdbcTargets,[]*JdbcTarget)
	mongoDBTargets?: [...null | #MongoDBTarget] @go(MongoDBTargets,[]*MongoDBTarget)
	s3Targets?: [...null | #S3Target] @go(S3Targets,[]*S3Target)
}

// +kubebuilder:skipversion
#Crawler_SDK: {
	classifiers?: [...null | string] @go(Classifiers,[]*string)
	configuration?:                null | string @go(Configuration,*string)
	crawlElapsedTime?:             null | int64  @go(CrawlElapsedTime,*int64)
	crawlerSecurityConfiguration?: null | string @go(CrawlerSecurityConfiguration,*string)
	databaseName?:                 null | string @go(DatabaseName,*string)
	description?:                  null | string @go(Description,*string)

	// Specifies Lake Formation configuration settings for the crawler.
	lakeFormationConfiguration?: null | #LakeFormationConfiguration @go(LakeFormationConfiguration,*LakeFormationConfiguration)

	// Status and error information about the most recent crawl.
	lastCrawl?: null | #LastCrawlInfo @go(LastCrawl,*LastCrawlInfo)

	// Specifies data lineage configuration settings for the crawler.
	lineageConfiguration?: null | #LineageConfiguration @go(LineageConfiguration,*LineageConfiguration)
	name?:                 null | string                @go(Name,*string)

	// When crawling an Amazon S3 data source after the first crawl is complete,
	// specifies whether to crawl the entire dataset again or to crawl only folders
	// that were added since the last crawler run. For more information, see Incremental
	// Crawls in Glue (https://docs.aws.amazon.com/glue/latest/dg/incremental-crawls.html)
	// in the developer guide.
	recrawlPolicy?: null | #RecrawlPolicy @go(RecrawlPolicy,*RecrawlPolicy)
	role?:          null | string         @go(Role,*string)

	// A scheduling object using a cron statement to schedule an event.
	schedule?: null | #Schedule @go(Schedule,*Schedule)

	// A policy that specifies update and deletion behaviors for the crawler.
	schemaChangePolicy?: null | #SchemaChangePolicy @go(SchemaChangePolicy,*SchemaChangePolicy)
	state?:              null | string              @go(State,*string)
	tablePrefix?:        null | string              @go(TablePrefix,*string)

	// Specifies data stores to crawl.
	targets?: null | #CrawlerTargets @go(Targets,*CrawlerTargets)
	version?: null | int64           @go(Version,*int64)
}

// +kubebuilder:skipversion
#CrawlsFilter: {
	fieldValue?: null | string @go(FieldValue,*string)
}

// +kubebuilder:skipversion
#CreateCsvClassifierRequest: {
	allowSingleColumn?:        null | bool   @go(AllowSingleColumn,*bool)
	containsHeader?:           null | string @go(ContainsHeader,*string)
	customDatatypeConfigured?: null | bool   @go(CustomDatatypeConfigured,*bool)
	customDatatypes?: [...null | string] @go(CustomDatatypes,[]*string)
	delimiter?:            null | string @go(Delimiter,*string)
	disableValueTrimming?: null | bool   @go(DisableValueTrimming,*bool)
	header?: [...null | string] @go(Header,[]*string)
	name?:        null | string @go(Name,*string)
	quoteSymbol?: null | string @go(QuoteSymbol,*string)
}

// +kubebuilder:skipversion
#CreateGrokClassifierRequest: {
	classification?: null | string @go(Classification,*string)
	customPatterns?: null | string @go(CustomPatterns,*string)
	grokPattern?:    null | string @go(GrokPattern,*string)
	name?:           null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#CreateJSONClassifierRequest: {
	jsonPath?: null | string @go(JSONPath,*string)
	name?:     null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#CreateXMLClassifierRequest: {
	classification?: null | string @go(Classification,*string)
	name?:           null | string @go(Name,*string)
	rowTag?:         null | string @go(RowTag,*string)
}

// +kubebuilder:skipversion
#CsvClassifier: {
	allowSingleColumn?:        null | bool   @go(AllowSingleColumn,*bool)
	containsHeader?:           null | string @go(ContainsHeader,*string)
	customDatatypeConfigured?: null | bool   @go(CustomDatatypeConfigured,*bool)
	customDatatypes?: [...null | string] @go(CustomDatatypes,[]*string)
	delimiter?:            null | string @go(Delimiter,*string)
	disableValueTrimming?: null | bool   @go(DisableValueTrimming,*bool)
	header?: [...null | string] @go(Header,[]*string)
	name?:        null | string @go(Name,*string)
	quoteSymbol?: null | string @go(QuoteSymbol,*string)
	version?:     null | int64  @go(Version,*int64)
}

// +kubebuilder:skipversion
#CustomCode: {
	className?: null | string @go(ClassName,*string)
	code?:      null | string @go(Code,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
}

// +kubebuilder:skipversion
#CustomEntityType: {
	name?:        null | string @go(Name,*string)
	regexString?: null | string @go(RegexString,*string)
}

// +kubebuilder:skipversion
#DQResultsPublishingOptions: {
	cloudWatchMetricsEnabled?: null | bool   @go(CloudWatchMetricsEnabled,*bool)
	evaluationContext?:        null | string @go(EvaluationContext,*string)
	resultsPublishingEnabled?: null | bool   @go(ResultsPublishingEnabled,*bool)
	resultsS3Prefix?:          null | string @go(ResultsS3Prefix,*string)
}

// +kubebuilder:skipversion
#DQStopJobOnFailureOptions: {
	stopJobOnFailureTiming?: null | string @go(StopJobOnFailureTiming,*string)
}

// +kubebuilder:skipversion
#DataLakePrincipal: {
	dataLakePrincipalIdentifier?: null | string @go(DataLakePrincipalIdentifier,*string)
}

// +kubebuilder:skipversion
#DataQualityEvaluationRunAdditionalRunOptions: {
	cloudWatchMetricsEnabled?: null | bool   @go(CloudWatchMetricsEnabled,*bool)
	resultsS3Prefix?:          null | string @go(ResultsS3Prefix,*string)
}

// +kubebuilder:skipversion
#DataQualityResult: {
	evaluationContext?: null | string @go(EvaluationContext,*string)
	jobName?:           null | string @go(JobName,*string)
	rulesetName?:       null | string @go(RulesetName,*string)
}

// +kubebuilder:skipversion
#DataQualityResultDescription: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#DataQualityResultFilterCriteria: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#DataQualityRuleResult: {
	description?:       null | string @go(Description,*string)
	evaluationMessage?: null | string @go(EvaluationMessage,*string)
	name?:              null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#DataQualityRulesetFilterCriteria: {
	description?: null | string @go(Description,*string)
	name?:        null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#DataQualityRulesetListDetails: {
	description?: null | string @go(Description,*string)
	name?:        null | string @go(Name,*string)
	ruleCount?:   null | int64  @go(RuleCount,*int64)
}

// +kubebuilder:skipversion
#DataQualityTargetTable: {
	databaseName?: null | string @go(DatabaseName,*string)
	tableName?:    null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#DatabaseIdentifier: {
	catalogID?:    null | string @go(CatalogID,*string)
	databaseName?: null | string @go(DatabaseName,*string)
}

// +kubebuilder:skipversion
#DatabaseInput: {
	createTableDefaultPermissions?: [...null | #PrincipalPermissions] @go(CreateTableDefaultPermissions,[]*PrincipalPermissions)
	description?: null | string @go(Description,*string)
	locationURI?: null | string @go(LocationURI,*string)
	name?:        null | string @go(Name,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)

	// A structure that describes a target database for resource linking.
	targetDatabase?: null | #DatabaseIdentifier @go(TargetDatabase,*DatabaseIdentifier)
}

// +kubebuilder:skipversion
#Database_SDK: {
	catalogID?: null | string @go(CatalogID,*string)
	createTableDefaultPermissions?: [...null | #PrincipalPermissions] @go(CreateTableDefaultPermissions,[]*PrincipalPermissions)
	description?: null | string @go(Description,*string)
	locationURI?: null | string @go(LocationURI,*string)
	name?:        null | string @go(Name,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)

	// A structure that describes a target database for resource linking.
	targetDatabase?: null | #DatabaseIdentifier @go(TargetDatabase,*DatabaseIdentifier)
}

// +kubebuilder:skipversion
#Datatype: {
	id?:    null | string @go(ID,*string)
	label?: null | string @go(Label,*string)
}

// +kubebuilder:skipversion
#DeltaTarget: {
	connectionName?:         null | string @go(ConnectionName,*string)
	createNativeDeltaTable?: null | bool   @go(CreateNativeDeltaTable,*bool)
	deltaTables?: [...null | string] @go(DeltaTables,[]*string)
	writeManifest?: null | bool @go(WriteManifest,*bool)
}

// +kubebuilder:skipversion
#DevEndpoint: {
	availabilityZone?:                   null | string @go(AvailabilityZone,*string)
	endpointName?:                       null | string @go(EndpointName,*string)
	extraJarsS3Path?:                    null | string @go(ExtraJarsS3Path,*string)
	extraPythonLibsS3Path?:              null | string @go(ExtraPythonLibsS3Path,*string)
	failureReason?:                      null | string @go(FailureReason,*string)
	glueVersion?:                        null | string @go(GlueVersion,*string)
	lastUpdateStatus?:                   null | string @go(LastUpdateStatus,*string)
	numberOfNodes?:                      null | int64  @go(NumberOfNodes,*int64)
	numberOfWorkers?:                    null | int64  @go(NumberOfWorkers,*int64)
	privateAddress?:                     null | string @go(PrivateAddress,*string)
	publicAddress?:                      null | string @go(PublicAddress,*string)
	publicKey?:                          null | string @go(PublicKey,*string)
	securityConfiguration?:              null | string @go(SecurityConfiguration,*string)
	status?:                             null | string @go(Status,*string)
	subnetID?:                           null | string @go(SubnetID,*string)
	vpcID?:                              null | string @go(VPCID,*string)
	workerType?:                         null | string @go(WorkerType,*string)
	yarnEndpointAddress?:                null | string @go(YarnEndpointAddress,*string)
	zeppelinRemoteSparkInterpreterPort?: null | int64  @go(ZeppelinRemoteSparkInterpreterPort,*int64)
}

// +kubebuilder:skipversion
#DevEndpointCustomLibraries: {
	extraJarsS3Path?:       null | string @go(ExtraJarsS3Path,*string)
	extraPythonLibsS3Path?: null | string @go(ExtraPythonLibsS3Path,*string)
}

// +kubebuilder:skipversion
#DirectKafkaSource: {
	// Specifies options related to data preview for viewing a sample of your data.
	dataPreviewOptions?: null | #StreamingDataPreviewOptions @go(DataPreviewOptions,*StreamingDataPreviewOptions)
	detectSchema?:       null | bool                         @go(DetectSchema,*bool)
	name?:               null | string                       @go(Name,*string)

	// Additional options for streaming.
	streamingOptions?: null | #KafkaStreamingSourceOptions @go(StreamingOptions,*KafkaStreamingSourceOptions)
	windowSize?:       null | int64                        @go(WindowSize,*int64)
}

// +kubebuilder:skipversion
#DirectKinesisSource: {
	// Specifies options related to data preview for viewing a sample of your data.
	dataPreviewOptions?: null | #StreamingDataPreviewOptions @go(DataPreviewOptions,*StreamingDataPreviewOptions)
	detectSchema?:       null | bool                         @go(DetectSchema,*bool)
	name?:               null | string                       @go(Name,*string)

	// Additional options for the Amazon Kinesis streaming data source.
	streamingOptions?: null | #KinesisStreamingSourceOptions @go(StreamingOptions,*KinesisStreamingSourceOptions)
	windowSize?:       null | int64                          @go(WindowSize,*int64)
}

// +kubebuilder:skipversion
#DirectSchemaChangePolicy: {
	database?:            null | string @go(Database,*string)
	enableUpdateCatalog?: null | bool   @go(EnableUpdateCatalog,*bool)
	table?:               null | string @go(Table,*string)
	updateBehavior?:      null | string @go(UpdateBehavior,*string)
}

// +kubebuilder:skipversion
#DropDuplicates: {
	columns?: [...[...null | string]] @go(Columns,[][]*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#DropFields: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	paths?: [...[...null | string]] @go(Paths,[][]*string)
}

// +kubebuilder:skipversion
#DropNullFields: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)

	// Represents whether certain values are recognized as null values for removal.
	nullCheckBoxList?: null | #NullCheckBoxList @go(NullCheckBoxList,*NullCheckBoxList)
	nullTextList?: [...null | #NullValueField] @go(NullTextList,[]*NullValueField)
}

// +kubebuilder:skipversion
#DynamicTransform: {
	functionName?: null | string @go(FunctionName,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	parameters?: [...null | #TransformConfigParameter] @go(Parameters,[]*TransformConfigParameter)
	path?:          null | string @go(Path,*string)
	transformName?: null | string @go(TransformName,*string)
	version?:       null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#DynamoDBCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#DynamoDBTarget: {
	path?:     null | string  @go(Path,*string)
	scanAll?:  null | bool    @go(ScanAll,*bool)
	scanRate?: null | float64 @go(ScanRate,*float64)
}

// +kubebuilder:skipversion
#Edge: {
	destinationID?: null | string @go(DestinationID,*string)
	sourceID?:      null | string @go(SourceID,*string)
}

// +kubebuilder:skipversion
#EncryptionAtRest: {
	sseAWSKMSKeyID?: null | string @go(SSEAWSKMSKeyID,*string)
}

// +kubebuilder:skipversion
#EncryptionConfiguration: {
	// Specifies how Amazon CloudWatch data should be encrypted.
	cloudWatchEncryption?: null | #CloudWatchEncryption @go(CloudWatchEncryption,*CloudWatchEncryption)

	// Specifies how job bookmark data should be encrypted.
	jobBookmarksEncryption?: null | #JobBookmarksEncryption @go(JobBookmarksEncryption,*JobBookmarksEncryption)
	s3Encryption?: [...null | #S3Encryption] @go(S3Encryption,[]*S3Encryption)
}

// +kubebuilder:skipversion
#ErrorDetail: {
	errorCode?:    null | string @go(ErrorCode,*string)
	errorMessage?: null | string @go(ErrorMessage,*string)
}

// +kubebuilder:skipversion
#EvaluateDataQuality: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:   null | string @go(Name,*string)
	output?: null | string @go(Output,*string)

	// Options to configure how your data quality evaluation results are published.
	publishingOptions?: null | #DQResultsPublishingOptions @go(PublishingOptions,*DQResultsPublishingOptions)
	ruleset?:           null | string                      @go(Ruleset,*string)

	// Options to configure how your job will stop if your data quality evaluation
	// fails.
	stopJobOnFailureOptions?: null | #DQStopJobOnFailureOptions @go(StopJobOnFailureOptions,*DQStopJobOnFailureOptions)
}

// +kubebuilder:skipversion
#ExecutionProperty: {
	maxConcurrentRuns?: null | int64 @go(MaxConcurrentRuns,*int64)
}

// +kubebuilder:skipversion
#ExportLabelsTaskRunProperties: {
	outputS3Path?: null | string @go(OutputS3Path,*string)
}

// +kubebuilder:skipversion
#FillMissingValues: {
	filledPath?:  null | string @go(FilledPath,*string)
	imputedPath?: null | string @go(ImputedPath,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#Filter: {
	filters?: [...null | #FilterExpression] @go(Filters,[]*FilterExpression)
	inputs?: [...null | string] @go(Inputs,[]*string)
	logicalOperator?: null | string @go(LogicalOperator,*string)
	name?:            null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#FilterExpression: {
	negated?:   null | bool   @go(Negated,*bool)
	operation?: null | string @go(Operation,*string)
	values?: [...null | #FilterValue] @go(Values,[]*FilterValue)
}

// +kubebuilder:skipversion
#FilterValue: {
	type_?: null | string @go(Type,*string)
	value?: [...null | string] @go(Value,[]*string)
}

// +kubebuilder:skipversion
#FindMatchesParameters: {
	enforceProvidedLabels?: null | bool @go(EnforceProvidedLabels,*bool)
}

// +kubebuilder:skipversion
#FindMatchesTaskRunProperties: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#GetConnectionsFilter: {
	connectionType?: null | string @go(ConnectionType,*string)
	matchCriteria?: [...null | string] @go(MatchCriteria,[]*string)
}

// +kubebuilder:skipversion
#GlueSchema: {
	columns?: [...null | #GlueStudioSchemaColumn] @go(Columns,[]*GlueStudioSchemaColumn)
}

// +kubebuilder:skipversion
#GlueStudioSchemaColumn: {
	name?:  null | string @go(Name,*string)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#GovernedCatalogSource: {
	// Specifies additional connection options for the Amazon S3 data store.
	additionalOptions?:  null | #S3SourceAdditionalOptions @go(AdditionalOptions,*S3SourceAdditionalOptions)
	database?:           null | string                     @go(Database,*string)
	name?:               null | string                     @go(Name,*string)
	partitionPredicate?: null | string                     @go(PartitionPredicate,*string)
	table?:              null | string                     @go(Table,*string)
}

// +kubebuilder:skipversion
#GovernedCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	partitionKeys?: [...[...null | string]] @go(PartitionKeys,[][]*string)

	// A policy that specifies update behavior for the crawler.
	schemaChangePolicy?: null | #CatalogSchemaChangePolicy @go(SchemaChangePolicy,*CatalogSchemaChangePolicy)
	table?:              null | string                     @go(Table,*string)
}

// +kubebuilder:skipversion
#GrokClassifier: {
	classification?: null | string @go(Classification,*string)
	customPatterns?: null | string @go(CustomPatterns,*string)
	grokPattern?:    null | string @go(GrokPattern,*string)
	name?:           null | string @go(Name,*string)
	version?:        null | int64  @go(Version,*int64)
}

// +kubebuilder:skipversion
#ImportLabelsTaskRunProperties: {
	inputS3Path?: null | string @go(InputS3Path,*string)
}

// +kubebuilder:skipversion
#JDBCConnectorOptions: {
	dataTypeMapping?: {[string]: null | string} @go(DataTypeMapping,map[string]*string)
	filterPredicate?: null | string @go(FilterPredicate,*string)
	jobBookmarkKeys?: [...null | string] @go(JobBookmarkKeys,[]*string)
	jobBookmarkKeysSortOrder?: null | string @go(JobBookmarkKeysSortOrder,*string)
	lowerBound?:               null | int64  @go(LowerBound,*int64)
	numPartitions?:            null | int64  @go(NumPartitions,*int64)
	partitionColumn?:          null | string @go(PartitionColumn,*string)
	upperBound?:               null | int64  @go(UpperBound,*int64)
}

// +kubebuilder:skipversion
#JDBCConnectorSource: {
	// Additional connection options for the connector.
	additionalOptions?: null | #JDBCConnectorOptions @go(AdditionalOptions,*JDBCConnectorOptions)
	connectionName?:    null | string                @go(ConnectionName,*string)
	connectionTable?:   null | string                @go(ConnectionTable,*string)
	connectionType?:    null | string                @go(ConnectionType,*string)
	connectorName?:     null | string                @go(ConnectorName,*string)
	name?:              null | string                @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	query?: null | string @go(Query,*string)
}

// +kubebuilder:skipversion
#JDBCConnectorTarget: {
	additionalOptions?: {[string]: null | string} @go(AdditionalOptions,map[string]*string)
	connectionName?:  null | string @go(ConnectionName,*string)
	connectionTable?: null | string @go(ConnectionTable,*string)
	connectionType?:  null | string @go(ConnectionType,*string)
	connectorName?:   null | string @go(ConnectorName,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
}

// +kubebuilder:skipversion
#JSONClassifier: {
	jsonPath?: null | string @go(JSONPath,*string)
	name?:     null | string @go(Name,*string)
	version?:  null | int64  @go(Version,*int64)
}

// +kubebuilder:skipversion
#JdbcTarget: {
	connectionName?: null | string @go(ConnectionName,*string)
	enableAdditionalMetadata?: [...null | string] @go(EnableAdditionalMetadata,[]*string)
	exclusions?: [...null | string] @go(Exclusions,[]*string)
	path?: null | string @go(Path,*string)
}

// +kubebuilder:skipversion
#JobBookmarkEntry: {
	attempt?: null | int64 @go(Attempt,*int64)
	run?:     null | int64 @go(Run,*int64)
	version?: null | int64 @go(Version,*int64)
}

// +kubebuilder:skipversion
#JobBookmarksEncryption: {
	jobBookmarksEncryptionMode?: null | string @go(JobBookmarksEncryptionMode,*string)
	kmsKeyARN?:                  null | string @go(KMSKeyARN,*string)
}

// +kubebuilder:skipversion
#JobCommand: {
	name?:           null | string @go(Name,*string)
	pythonVersion?:  null | string @go(PythonVersion,*string)
	scriptLocation?: null | string @go(ScriptLocation,*string)
}

// +kubebuilder:skipversion
#JobRun: {
	allocatedCapacity?: null | int64 @go(AllocatedCapacity,*int64)
	arguments?: {[string]: null | string} @go(Arguments,map[string]*string)
	dPUSeconds?:     null | float64 @go(DPUSeconds,*float64)
	executionClass?: null | string  @go(ExecutionClass,*string)
	glueVersion?:    null | string  @go(GlueVersion,*string)
	jobName?:        null | string  @go(JobName,*string)
	logGroupName?:   null | string  @go(LogGroupName,*string)
	maxCapacity?:    null | float64 @go(MaxCapacity,*float64)

	// Specifies configuration properties of a notification.
	notificationProperty?:  null | #NotificationProperty @go(NotificationProperty,*NotificationProperty)
	numberOfWorkers?:       null | int64                 @go(NumberOfWorkers,*int64)
	securityConfiguration?: null | string                @go(SecurityConfiguration,*string)
	timeout?:               null | int64                 @go(Timeout,*int64)
	triggerName?:           null | string                @go(TriggerName,*string)
	workerType?:            null | string                @go(WorkerType,*string)
}

// +kubebuilder:skipversion
#JobUpdate: {
	allocatedCapacity?: null | int64 @go(AllocatedCapacity,*int64)
	codeGenConfigurationNodes?: {[string]: null | #CodeGenConfigurationNode} @go(CodeGenConfigurationNodes,map[string]*CodeGenConfigurationNode)

	// Specifies code that runs when a job is run.
	command?: null | #JobCommand @go(Command,*JobCommand)

	// Specifies the connections used by a job.
	connections?: null | #ConnectionsList @go(Connections,*ConnectionsList)
	defaultArguments?: {[string]: null | string} @go(DefaultArguments,map[string]*string)
	description?:    null | string @go(Description,*string)
	executionClass?: null | string @go(ExecutionClass,*string)

	// An execution property of a job.
	executionProperty?: null | #ExecutionProperty @go(ExecutionProperty,*ExecutionProperty)
	glueVersion?:       null | string             @go(GlueVersion,*string)
	logURI?:            null | string             @go(LogURI,*string)
	maxCapacity?:       null | float64            @go(MaxCapacity,*float64)
	maxRetries?:        null | int64              @go(MaxRetries,*int64)
	nonOverridableArguments?: {[string]: null | string} @go(NonOverridableArguments,map[string]*string)

	// Specifies configuration properties of a notification.
	notificationProperty?:  null | #NotificationProperty @go(NotificationProperty,*NotificationProperty)
	numberOfWorkers?:       null | int64                 @go(NumberOfWorkers,*int64)
	role?:                  null | string                @go(Role,*string)
	securityConfiguration?: null | string                @go(SecurityConfiguration,*string)

	// The details for a source control configuration for a job, allowing synchronization
	// of job artifacts to or from a remote repository.
	sourceControlDetails?: null | #SourceControlDetails @go(SourceControlDetails,*SourceControlDetails)
	timeout?:              null | int64                 @go(Timeout,*int64)
	workerType?:           null | string                @go(WorkerType,*string)
}

// +kubebuilder:skipversion
#Job_SDK: {
	allocatedCapacity?: null | int64 @go(AllocatedCapacity,*int64)
	codeGenConfigurationNodes?: {[string]: null | #CodeGenConfigurationNode} @go(CodeGenConfigurationNodes,map[string]*CodeGenConfigurationNode)

	// Specifies code that runs when a job is run.
	command?: null | #JobCommand @go(Command,*JobCommand)

	// Specifies the connections used by a job.
	connections?: null | #ConnectionsList @go(Connections,*ConnectionsList)
	defaultArguments?: {[string]: null | string} @go(DefaultArguments,map[string]*string)
	description?:    null | string @go(Description,*string)
	executionClass?: null | string @go(ExecutionClass,*string)

	// An execution property of a job.
	executionProperty?: null | #ExecutionProperty @go(ExecutionProperty,*ExecutionProperty)
	glueVersion?:       null | string             @go(GlueVersion,*string)
	logURI?:            null | string             @go(LogURI,*string)
	maxCapacity?:       null | float64            @go(MaxCapacity,*float64)
	maxRetries?:        null | int64              @go(MaxRetries,*int64)
	name?:              null | string             @go(Name,*string)
	nonOverridableArguments?: {[string]: null | string} @go(NonOverridableArguments,map[string]*string)

	// Specifies configuration properties of a notification.
	notificationProperty?:  null | #NotificationProperty @go(NotificationProperty,*NotificationProperty)
	numberOfWorkers?:       null | int64                 @go(NumberOfWorkers,*int64)
	role?:                  null | string                @go(Role,*string)
	securityConfiguration?: null | string                @go(SecurityConfiguration,*string)

	// The details for a source control configuration for a job, allowing synchronization
	// of job artifacts to or from a remote repository.
	sourceControlDetails?: null | #SourceControlDetails @go(SourceControlDetails,*SourceControlDetails)
	timeout?:              null | int64                 @go(Timeout,*int64)
	workerType?:           null | string                @go(WorkerType,*string)
}

// +kubebuilder:skipversion
#Join: {
	columns?: [...null | #JoinColumn] @go(Columns,[]*JoinColumn)
	inputs?: [...null | string] @go(Inputs,[]*string)
	joinType?: null | string @go(JoinType,*string)
	name?:     null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#JoinColumn: {
	from?: null | string @go(From,*string)
	keys?: [...[...null | string]] @go(Keys,[][]*string)
}

// +kubebuilder:skipversion
#KafkaStreamingSourceOptions: {
	assign?:               null | string @go(Assign,*string)
	bootstrapServers?:     null | string @go(BootstrapServers,*string)
	classification?:       null | string @go(Classification,*string)
	connectionName?:       null | string @go(ConnectionName,*string)
	delimiter?:            null | string @go(Delimiter,*string)
	endingOffsets?:        null | string @go(EndingOffsets,*string)
	maxOffsetsPerTrigger?: null | int64  @go(MaxOffsetsPerTrigger,*int64)
	minPartitions?:        null | int64  @go(MinPartitions,*int64)
	numRetries?:           null | int64  @go(NumRetries,*int64)
	pollTimeoutMs?:        null | int64  @go(PollTimeoutMs,*int64)
	retryIntervalMs?:      null | int64  @go(RetryIntervalMs,*int64)
	securityProtocol?:     null | string @go(SecurityProtocol,*string)
	startingOffsets?:      null | string @go(StartingOffsets,*string)
	subscribePattern?:     null | string @go(SubscribePattern,*string)
	topicName?:            null | string @go(TopicName,*string)
}

// +kubebuilder:skipversion
#KeySchemaElement: {
	name?:  null | string @go(Name,*string)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#KinesisStreamingSourceOptions: {
	addIdleTimeBetweenReads?:  null | bool   @go(AddIdleTimeBetweenReads,*bool)
	avoidEmptyBatches?:        null | bool   @go(AvoidEmptyBatches,*bool)
	classification?:           null | string @go(Classification,*string)
	delimiter?:                null | string @go(Delimiter,*string)
	describeShardInterval?:    null | int64  @go(DescribeShardInterval,*int64)
	endpointURL?:              null | string @go(EndpointURL,*string)
	idleTimeBetweenReadsInMs?: null | int64  @go(IdleTimeBetweenReadsInMs,*int64)
	maxFetchRecordsPerShard?:  null | int64  @go(MaxFetchRecordsPerShard,*int64)
	maxFetchTimeInMs?:         null | int64  @go(MaxFetchTimeInMs,*int64)
	maxRecordPerRead?:         null | int64  @go(MaxRecordPerRead,*int64)
	maxRetryIntervalMs?:       null | int64  @go(MaxRetryIntervalMs,*int64)
	numRetries?:               null | int64  @go(NumRetries,*int64)
	retryIntervalMs?:          null | int64  @go(RetryIntervalMs,*int64)
	roleARN?:                  null | string @go(RoleARN,*string)
	roleSessionName?:          null | string @go(RoleSessionName,*string)
	startingPosition?:         null | string @go(StartingPosition,*string)
	streamARN?:                null | string @go(StreamARN,*string)
	streamName?:               null | string @go(StreamName,*string)
}

// +kubebuilder:skipversion
#LabelingSetGenerationTaskRunProperties: {
	outputS3Path?: null | string @go(OutputS3Path,*string)
}

// +kubebuilder:skipversion
#LakeFormationConfiguration: {
	accountID?:                   null | string @go(AccountID,*string)
	useLakeFormationCredentials?: null | bool   @go(UseLakeFormationCredentials,*bool)
}

// +kubebuilder:skipversion
#LastActiveDefinition: {
	blueprintLocation?:        null | string @go(BlueprintLocation,*string)
	blueprintServiceLocation?: null | string @go(BlueprintServiceLocation,*string)
	description?:              null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#LastCrawlInfo: {
	errorMessage?:  null | string @go(ErrorMessage,*string)
	logGroup?:      null | string @go(LogGroup,*string)
	logStream?:     null | string @go(LogStream,*string)
	messagePrefix?: null | string @go(MessagePrefix,*string)
	status?:        null | string @go(Status,*string)
}

// +kubebuilder:skipversion
#LineageConfiguration: {
	crawlerLineageSettings?: null | string @go(CrawlerLineageSettings,*string)
}

// +kubebuilder:skipversion
#MLTransform: {
	description?:     null | string  @go(Description,*string)
	glueVersion?:     null | string  @go(GlueVersion,*string)
	maxCapacity?:     null | float64 @go(MaxCapacity,*float64)
	maxRetries?:      null | int64   @go(MaxRetries,*int64)
	name?:            null | string  @go(Name,*string)
	numberOfWorkers?: null | int64   @go(NumberOfWorkers,*int64)
	role?:            null | string  @go(Role,*string)
	timeout?:         null | int64   @go(Timeout,*int64)
	workerType?:      null | string  @go(WorkerType,*string)
}

// +kubebuilder:skipversion
#MLUserDataEncryption: {
	kmsKeyID?: null | string @go(KMSKeyID,*string)
}

// +kubebuilder:skipversion
#Mapping: {
	dropped?: null | bool @go(Dropped,*bool)
	fromPath?: [...null | string] @go(FromPath,[]*string)
	fromType?: null | string @go(FromType,*string)
	toKey?:    null | string @go(ToKey,*string)
	toType?:   null | string @go(ToType,*string)
}

// +kubebuilder:skipversion
#Merge: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	primaryKeys?: [...[...null | string]] @go(PrimaryKeys,[][]*string)
	source?: null | string @go(Source,*string)
}

// +kubebuilder:skipversion
#MicrosoftSQLServerCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#MicrosoftSQLServerCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:  null | string @go(Name,*string)
	table?: null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#MongoDBTarget: {
	connectionName?: null | string @go(ConnectionName,*string)
	path?:           null | string @go(Path,*string)
	scanAll?:        null | bool   @go(ScanAll,*bool)
}

// +kubebuilder:skipversion
#MySQLCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#MySQLCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:  null | string @go(Name,*string)
	table?: null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#Node: {
	name?:     null | string @go(Name,*string)
	uniqueID?: null | string @go(UniqueID,*string)
}

// +kubebuilder:skipversion
#NotificationProperty: {
	notifyDelayAfter?: null | int64 @go(NotifyDelayAfter,*int64)
}

// +kubebuilder:skipversion
#NullCheckBoxList: {
	isEmpty?:      null | bool @go(IsEmpty,*bool)
	isNegOne?:     null | bool @go(IsNegOne,*bool)
	isNullString?: null | bool @go(IsNullString,*bool)
}

// +kubebuilder:skipversion
#NullValueField: {
	// A structure representing the datatype of the value.
	datatype?: null | #Datatype @go(Datatype,*Datatype)
	value?:    null | string    @go(Value,*string)
}

// +kubebuilder:skipversion
#OracleSQLCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#OracleSQLCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:  null | string @go(Name,*string)
	table?: null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#Order: {
	column?: null | string @go(Column,*string)
}

// +kubebuilder:skipversion
#PIIDetection: {
	entityTypesToDetect?: [...null | string] @go(EntityTypesToDetect,[]*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	maskValue?:         null | string  @go(MaskValue,*string)
	name?:              null | string  @go(Name,*string)
	outputColumnName?:  null | string  @go(OutputColumnName,*string)
	piiType?:           null | string  @go(PiiType,*string)
	sampleFraction?:    null | float64 @go(SampleFraction,*float64)
	thresholdFraction?: null | float64 @go(ThresholdFraction,*float64)
}

// +kubebuilder:skipversion
#Partition: {
	catalogID?:    null | string @go(CatalogID,*string)
	databaseName?: null | string @go(DatabaseName,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
	tableName?: null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#PartitionIndex: {
	indexName?: null | string @go(IndexName,*string)
}

// +kubebuilder:skipversion
#PartitionIndexDescriptor: {
	indexName?: null | string @go(IndexName,*string)
}

// +kubebuilder:skipversion
#PartitionInput: {
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
}

// +kubebuilder:skipversion
#PhysicalConnectionRequirements: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	securityGroupIDList?: [...null | string] @go(SecurityGroupIDList,[]*string)
	subnetID?: null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#PostgreSQLCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#PostgreSQLCatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:  null | string @go(Name,*string)
	table?: null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#Predecessor: {
	jobName?: null | string @go(JobName,*string)
}

// +kubebuilder:skipversion
#PrincipalPermissions: {
	permissions?: [...null | string] @go(Permissions,[]*string)

	// The Lake Formation principal.
	principal?: null | #DataLakePrincipal @go(Principal,*DataLakePrincipal)
}

// +kubebuilder:skipversion
#PropertyPredicate: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#RecrawlPolicy: {
	recrawlBehavior?: null | string @go(RecrawlBehavior,*string)
}

// +kubebuilder:skipversion
#RedshiftSource: {
	database?:       null | string @go(Database,*string)
	name?:           null | string @go(Name,*string)
	redshiftTmpDir?: null | string @go(RedshiftTmpDir,*string)
	table?:          null | string @go(Table,*string)
	tmpDirIAMRole?:  null | string @go(TmpDirIAMRole,*string)
}

// +kubebuilder:skipversion
#RedshiftTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:           null | string @go(Name,*string)
	redshiftTmpDir?: null | string @go(RedshiftTmpDir,*string)
	table?:          null | string @go(Table,*string)
	tmpDirIAMRole?:  null | string @go(TmpDirIAMRole,*string)

	// The options to configure an upsert operation when writing to a Redshift target .
	upsertRedshiftOptions?: null | #UpsertRedshiftTargetOptions @go(UpsertRedshiftOptions,*UpsertRedshiftTargetOptions)
}

// +kubebuilder:skipversion
#RegistryListItem: {
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#RelationalCatalogSource: {
	database?: null | string @go(Database,*string)
	name?:     null | string @go(Name,*string)
	table?:    null | string @go(Table,*string)
}

// +kubebuilder:skipversion
#RenameField: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	sourcePath?: [...null | string] @go(SourcePath,[]*string)
	targetPath?: [...null | string] @go(TargetPath,[]*string)
}

// +kubebuilder:skipversion
#ResourceURI: {
	uri?: null | string @go(URI,*string)
}

// +kubebuilder:skipversion
#S3CatalogSource: {
	// Specifies additional connection options for the Amazon S3 data store.
	additionalOptions?:  null | #S3SourceAdditionalOptions @go(AdditionalOptions,*S3SourceAdditionalOptions)
	database?:           null | string                     @go(Database,*string)
	name?:               null | string                     @go(Name,*string)
	partitionPredicate?: null | string                     @go(PartitionPredicate,*string)
	table?:              null | string                     @go(Table,*string)
}

// +kubebuilder:skipversion
#S3CatalogTarget: {
	database?: null | string @go(Database,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	partitionKeys?: [...[...null | string]] @go(PartitionKeys,[][]*string)

	// A policy that specifies update behavior for the crawler.
	schemaChangePolicy?: null | #CatalogSchemaChangePolicy @go(SchemaChangePolicy,*CatalogSchemaChangePolicy)
	table?:              null | string                     @go(Table,*string)
}

// +kubebuilder:skipversion
#S3CsvSource: {
	// Specifies additional connection options for the Amazon S3 data store.
	additionalOptions?: null | #S3DirectSourceAdditionalOptions @go(AdditionalOptions,*S3DirectSourceAdditionalOptions)
	compressionType?:   null | string                           @go(CompressionType,*string)
	escaper?:           null | string                           @go(Escaper,*string)
	exclusions?: [...null | string] @go(Exclusions,[]*string)
	groupFiles?:          null | string @go(GroupFiles,*string)
	groupSize?:           null | string @go(GroupSize,*string)
	maxBand?:             null | int64  @go(MaxBand,*int64)
	maxFilesInBand?:      null | int64  @go(MaxFilesInBand,*int64)
	multiline?:           null | bool   @go(Multiline,*bool)
	name?:                null | string @go(Name,*string)
	optimizePerformance?: null | bool   @go(OptimizePerformance,*bool)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	paths?: [...null | string] @go(Paths,[]*string)
	quoteChar?:   null | string @go(QuoteChar,*string)
	recurse?:     null | bool   @go(Recurse,*bool)
	separator?:   null | string @go(Separator,*string)
	skipFirst?:   null | bool   @go(SkipFirst,*bool)
	withHeader?:  null | bool   @go(WithHeader,*bool)
	writeHeader?: null | bool   @go(WriteHeader,*bool)
}

// +kubebuilder:skipversion
#S3DirectSourceAdditionalOptions: {
	boundedFiles?:     null | int64  @go(BoundedFiles,*int64)
	boundedSize?:      null | int64  @go(BoundedSize,*int64)
	enableSamplePath?: null | bool   @go(EnableSamplePath,*bool)
	samplePath?:       null | string @go(SamplePath,*string)
}

// +kubebuilder:skipversion
#S3DirectTarget: {
	compression?: null | string @go(Compression,*string)
	format?:      null | string @go(Format,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	partitionKeys?: [...[...null | string]] @go(PartitionKeys,[][]*string)
	path?: null | string @go(Path,*string)

	// A policy that specifies update behavior for the crawler.
	schemaChangePolicy?: null | #DirectSchemaChangePolicy @go(SchemaChangePolicy,*DirectSchemaChangePolicy)
}

// +kubebuilder:skipversion
#S3Encryption: {
	kmsKeyARN?:        null | string @go(KMSKeyARN,*string)
	s3EncryptionMode?: null | string @go(S3EncryptionMode,*string)
}

// +kubebuilder:skipversion
#S3GlueParquetTarget: {
	compression?: null | string @go(Compression,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	partitionKeys?: [...[...null | string]] @go(PartitionKeys,[][]*string)
	path?: null | string @go(Path,*string)

	// A policy that specifies update behavior for the crawler.
	schemaChangePolicy?: null | #DirectSchemaChangePolicy @go(SchemaChangePolicy,*DirectSchemaChangePolicy)
}

// +kubebuilder:skipversion
#S3JSONSource: {
	// Specifies additional connection options for the Amazon S3 data store.
	additionalOptions?: null | #S3DirectSourceAdditionalOptions @go(AdditionalOptions,*S3DirectSourceAdditionalOptions)
	compressionType?:   null | string                           @go(CompressionType,*string)
	exclusions?: [...null | string] @go(Exclusions,[]*string)
	groupFiles?:     null | string @go(GroupFiles,*string)
	groupSize?:      null | string @go(GroupSize,*string)
	jsonPath?:       null | string @go(JSONPath,*string)
	maxBand?:        null | int64  @go(MaxBand,*int64)
	maxFilesInBand?: null | int64  @go(MaxFilesInBand,*int64)
	multiline?:      null | bool   @go(Multiline,*bool)
	name?:           null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	paths?: [...null | string] @go(Paths,[]*string)
	recurse?: null | bool @go(Recurse,*bool)
}

// +kubebuilder:skipversion
#S3ParquetSource: {
	// Specifies additional connection options for the Amazon S3 data store.
	additionalOptions?: null | #S3DirectSourceAdditionalOptions @go(AdditionalOptions,*S3DirectSourceAdditionalOptions)
	compressionType?:   null | string                           @go(CompressionType,*string)
	exclusions?: [...null | string] @go(Exclusions,[]*string)
	groupFiles?:     null | string @go(GroupFiles,*string)
	groupSize?:      null | string @go(GroupSize,*string)
	maxBand?:        null | int64  @go(MaxBand,*int64)
	maxFilesInBand?: null | int64  @go(MaxFilesInBand,*int64)
	name?:           null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	paths?: [...null | string] @go(Paths,[]*string)
	recurse?: null | bool @go(Recurse,*bool)
}

// +kubebuilder:skipversion
#S3SourceAdditionalOptions: {
	boundedFiles?: null | int64 @go(BoundedFiles,*int64)
	boundedSize?:  null | int64 @go(BoundedSize,*int64)
}

// +kubebuilder:skipversion
#S3Target: {
	connectionName?:   null | string @go(ConnectionName,*string)
	dlqEventQueueARN?: null | string @go(DlqEventQueueARN,*string)
	eventQueueARN?:    null | string @go(EventQueueARN,*string)
	exclusions?: [...null | string] @go(Exclusions,[]*string)
	path?:       null | string @go(Path,*string)
	sampleSize?: null | int64  @go(SampleSize,*int64)
}

// +kubebuilder:skipversion
#SQLAlias: {
	alias?: null | string @go(Alias,*string)
	from?:  null | string @go(From,*string)
}

// +kubebuilder:skipversion
#Schedule: {
	scheduleExpression?: null | string @go(ScheduleExpression,*string)
	state?:              null | string @go(State,*string)
}

// +kubebuilder:skipversion
#SchemaChangePolicy: {
	deleteBehavior?: null | string @go(DeleteBehavior,*string)
	updateBehavior?: null | string @go(UpdateBehavior,*string)
}

// +kubebuilder:skipversion
#SchemaColumn: {
	dataType?: null | string @go(DataType,*string)
}

// +kubebuilder:skipversion
#SchemaListItem: {
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#SecurityConfiguration_SDK: {
	// Specifies an encryption configuration.
	encryptionConfiguration?: null | #EncryptionConfiguration @go(EncryptionConfiguration,*EncryptionConfiguration)
	name?:                    null | string                   @go(Name,*string)
}

// +kubebuilder:skipversion
#SelectFields: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	paths?: [...[...null | string]] @go(Paths,[][]*string)
}

// +kubebuilder:skipversion
#SelectFromCollection: {
	index?: null | int64 @go(Index,*int64)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#SerDeInfo: {
	name?: null | string @go(Name,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
	serializationLibrary?: null | string @go(SerializationLibrary,*string)
}

// +kubebuilder:skipversion
#Session: {
	// Specifies the connections used by a job.
	connections?:           null | #ConnectionsList @go(Connections,*ConnectionsList)
	description?:           null | string           @go(Description,*string)
	errorMessage?:          null | string           @go(ErrorMessage,*string)
	glueVersion?:           null | string           @go(GlueVersion,*string)
	id?:                    null | string           @go(ID,*string)
	maxCapacity?:           null | float64          @go(MaxCapacity,*float64)
	securityConfiguration?: null | string           @go(SecurityConfiguration,*string)
}

// +kubebuilder:skipversion
#SessionCommand: {
	name?:          null | string @go(Name,*string)
	pythonVersion?: null | string @go(PythonVersion,*string)
}

// +kubebuilder:skipversion
#SortCriterion: {
	fieldName?: null | string @go(FieldName,*string)
}

// +kubebuilder:skipversion
#SourceControlDetails: {
	authStrategy?: null | string @go(AuthStrategy,*string)
	authToken?:    null | string @go(AuthToken,*string)
	branch?:       null | string @go(Branch,*string)
	folder?:       null | string @go(Folder,*string)
	lastCommitID?: null | string @go(LastCommitID,*string)
	owner?:        null | string @go(Owner,*string)
	provider?:     null | string @go(Provider,*string)
	repository?:   null | string @go(Repository,*string)
}

// +kubebuilder:skipversion
#SparkConnectorSource: {
	additionalOptions?: {[string]: null | string} @go(AdditionalOptions,map[string]*string)
	connectionName?: null | string @go(ConnectionName,*string)
	connectionType?: null | string @go(ConnectionType,*string)
	connectorName?:  null | string @go(ConnectorName,*string)
	name?:           null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
}

// +kubebuilder:skipversion
#SparkConnectorTarget: {
	additionalOptions?: {[string]: null | string} @go(AdditionalOptions,map[string]*string)
	connectionName?: null | string @go(ConnectionName,*string)
	connectionType?: null | string @go(ConnectionType,*string)
	connectorName?:  null | string @go(ConnectorName,*string)
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
}

// +kubebuilder:skipversion
#SparkSQL: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	outputSchemas?: [...null | #GlueSchema] @go(OutputSchemas,[]*GlueSchema)
	sqlAliases?: [...null | #SQLAlias] @go(SQLAliases,[]*SQLAlias)
	sqlQuery?: null | string @go(SQLQuery,*string)
}

// +kubebuilder:skipversion
#Spigot: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string  @go(Name,*string)
	path?: null | string  @go(Path,*string)
	prob?: null | float64 @go(Prob,*float64)
	topk?: null | int64   @go(Topk,*int64)
}

// +kubebuilder:skipversion
#SplitFields: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?: null | string @go(Name,*string)
	paths?: [...[...null | string]] @go(Paths,[][]*string)
}

// +kubebuilder:skipversion
#StartingEventBatchCondition: {
	batchSize?:   null | int64 @go(BatchSize,*int64)
	batchWindow?: null | int64 @go(BatchWindow,*int64)
}

// +kubebuilder:skipversion
#Statement: {
	code?: null | string @go(Code,*string)
	id?:   null | int64  @go(ID,*int64)
}

// +kubebuilder:skipversion
#StatementOutput: {
	errorName?:      null | string @go(ErrorName,*string)
	errorValue?:     null | string @go(ErrorValue,*string)
	executionCount?: null | int64  @go(ExecutionCount,*int64)
	traceback?: [...null | string] @go(Traceback,[]*string)
}

// +kubebuilder:skipversion
#StatementOutputData: {
	textPlain?: null | string @go(TextPlain,*string)
}

// +kubebuilder:skipversion
#StorageDescriptor: {
	compressed?: null | bool @go(Compressed,*bool)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
	storedAsSubDirectories?: null | bool @go(StoredAsSubDirectories,*bool)
}

// +kubebuilder:skipversion
#StreamingDataPreviewOptions: {
	pollingTime?:        null | int64 @go(PollingTime,*int64)
	recordPollingLimit?: null | int64 @go(RecordPollingLimit,*int64)
}

// +kubebuilder:skipversion
#Table: {
	catalogID?:      null | string @go(CatalogID,*string)
	connectionName?: null | string @go(ConnectionName,*string)
	databaseName?:   null | string @go(DatabaseName,*string)
	tableName?:      null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#TableData: {
	catalogID?:                     null | string @go(CatalogID,*string)
	createdBy?:                     null | string @go(CreatedBy,*string)
	databaseName?:                  null | string @go(DatabaseName,*string)
	description?:                   null | string @go(Description,*string)
	isRegisteredWithLakeFormation?: null | bool   @go(IsRegisteredWithLakeFormation,*bool)
	name?:                          null | string @go(Name,*string)
	owner?:                         null | string @go(Owner,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
}

// +kubebuilder:skipversion
#TableError: {
	tableName?: null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#TableIdentifier: {
	catalogID?:    null | string @go(CatalogID,*string)
	databaseName?: null | string @go(DatabaseName,*string)
	name?:         null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#TableInput: {
	description?: null | string @go(Description,*string)
	name?:        null | string @go(Name,*string)
	owner?:       null | string @go(Owner,*string)
	parameters?: {[string]: null | string} @go(Parameters,map[string]*string)
}

// +kubebuilder:skipversion
#TableVersionError: {
	tableName?: null | string @go(TableName,*string)
}

// +kubebuilder:skipversion
#TaskRun: {
	errorString?:  null | string @go(ErrorString,*string)
	logGroupName?: null | string @go(LogGroupName,*string)
}

// +kubebuilder:skipversion
#TransformConfigParameter: {
	isOptional?:        null | bool   @go(IsOptional,*bool)
	listType?:          null | string @go(ListType,*string)
	name?:              null | string @go(Name,*string)
	type_?:             null | string @go(Type,*string)
	validationMessage?: null | string @go(ValidationMessage,*string)
	validationRule?:    null | string @go(ValidationRule,*string)
	value?: [...null | string] @go(Value,[]*string)
}

// +kubebuilder:skipversion
#TransformEncryption: {
	taskRunSecurityConfigurationName?: null | string @go(TaskRunSecurityConfigurationName,*string)
}

// +kubebuilder:skipversion
#TransformFilterCriteria: {
	glueVersion?: null | string @go(GlueVersion,*string)
	name?:        null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#Trigger: {
	description?:  null | string @go(Description,*string)
	name?:         null | string @go(Name,*string)
	schedule?:     null | string @go(Schedule,*string)
	workflowName?: null | string @go(WorkflowName,*string)
}

// +kubebuilder:skipversion
#TriggerUpdate: {
	description?: null | string @go(Description,*string)
	name?:        null | string @go(Name,*string)
	schedule?:    null | string @go(Schedule,*string)
}

// +kubebuilder:skipversion
#UnfilteredPartition: {
	isRegisteredWithLakeFormation?: null | bool @go(IsRegisteredWithLakeFormation,*bool)
}

// +kubebuilder:skipversion
#Union: {
	inputs?: [...null | string] @go(Inputs,[]*string)
	name?:      null | string @go(Name,*string)
	unionType?: null | string @go(UnionType,*string)
}

// +kubebuilder:skipversion
#UpdateCsvClassifierRequest: {
	allowSingleColumn?:        null | bool   @go(AllowSingleColumn,*bool)
	containsHeader?:           null | string @go(ContainsHeader,*string)
	customDatatypeConfigured?: null | bool   @go(CustomDatatypeConfigured,*bool)
	customDatatypes?: [...null | string] @go(CustomDatatypes,[]*string)
	delimiter?:            null | string @go(Delimiter,*string)
	disableValueTrimming?: null | bool   @go(DisableValueTrimming,*bool)
	header?: [...null | string] @go(Header,[]*string)
	name?:        null | string @go(Name,*string)
	quoteSymbol?: null | string @go(QuoteSymbol,*string)
}

// +kubebuilder:skipversion
#UpdateGrokClassifierRequest: {
	classification?: null | string @go(Classification,*string)
	customPatterns?: null | string @go(CustomPatterns,*string)
	grokPattern?:    null | string @go(GrokPattern,*string)
	name?:           null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#UpdateJSONClassifierRequest: {
	jsonPath?: null | string @go(JSONPath,*string)
	name?:     null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#UpdateXMLClassifierRequest: {
	classification?: null | string @go(Classification,*string)
	name?:           null | string @go(Name,*string)
	rowTag?:         null | string @go(RowTag,*string)
}

// +kubebuilder:skipversion
#UpsertRedshiftTargetOptions: {
	connectionName?: null | string @go(ConnectionName,*string)
	tableLocation?:  null | string @go(TableLocation,*string)
	upsertKeys?: [...null | string] @go(UpsertKeys,[]*string)
}

// +kubebuilder:skipversion
#UserDefinedFunction: {
	catalogID?:    null | string @go(CatalogID,*string)
	className?:    null | string @go(ClassName,*string)
	databaseName?: null | string @go(DatabaseName,*string)
	functionName?: null | string @go(FunctionName,*string)
	ownerName?:    null | string @go(OwnerName,*string)
}

// +kubebuilder:skipversion
#UserDefinedFunctionInput: {
	className?:    null | string @go(ClassName,*string)
	functionName?: null | string @go(FunctionName,*string)
	ownerName?:    null | string @go(OwnerName,*string)
}

// +kubebuilder:skipversion
#Workflow: {
	description?:       null | string @go(Description,*string)
	maxConcurrentRuns?: null | int64  @go(MaxConcurrentRuns,*int64)
	name?:              null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#WorkflowRun: {
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#WorkflowRunStatistics: {
	erroredActions?:   null | int64 @go(ErroredActions,*int64)
	failedActions?:    null | int64 @go(FailedActions,*int64)
	runningActions?:   null | int64 @go(RunningActions,*int64)
	stoppedActions?:   null | int64 @go(StoppedActions,*int64)
	succeededActions?: null | int64 @go(SucceededActions,*int64)
	timeoutActions?:   null | int64 @go(TimeoutActions,*int64)
	totalActions?:     null | int64 @go(TotalActions,*int64)
	waitingActions?:   null | int64 @go(WaitingActions,*int64)
}

// +kubebuilder:skipversion
#XMLClassifier: {
	classification?: null | string @go(Classification,*string)
	name?:           null | string @go(Name,*string)
	rowTag?:         null | string @go(RowTag,*string)
	version?:        null | int64  @go(Version,*int64)
}
