// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane-contrib/provider-aws/apis/efs/v1alpha1

package v1alpha1

// +kubebuilder:skipversion
#AccessPointDescription: {
	accessPointARN?: null | string @go(AccessPointARN,*string)
	accessPointID?:  null | string @go(AccessPointID,*string)
	clientToken?:    null | string @go(ClientToken,*string)
	fileSystemID?:   null | string @go(FileSystemID,*string)
	lifeCycleState?: null | string @go(LifeCycleState,*string)
	name?:           null | string @go(Name,*string)
	ownerID?:        null | string @go(OwnerID,*string)

	// The full POSIX identity, including the user ID, group ID, and any secondary
	// group IDs, on the access point that is used for all file system operations
	// performed by NFS clients using the access point.
	posixUser?: null | #PosixUser @go(PosixUser,*PosixUser)

	// Specifies the directory on the Amazon EFS file system that the access point
	// provides access to. The access point exposes the specified file system path
	// as the root directory of your file system to applications using the access
	// point. NFS clients using the access point can only access data in the access
	// point's RootDirectory and it's subdirectories.
	rootDirectory?: null | #RootDirectory @go(RootDirectory,*RootDirectory)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#CreationInfo: {
	ownerGid?:    null | int64  @go(OwnerGid,*int64)
	ownerUid?:    null | int64  @go(OwnerUid,*int64)
	permissions?: null | string @go(Permissions,*string)
}

// +kubebuilder:skipversion
#Destination: {
	fileSystemID?: null | string @go(FileSystemID,*string)
}

// +kubebuilder:skipversion
#DestinationToCreate: {
	availabilityZoneName?: null | string @go(AvailabilityZoneName,*string)
	kmsKeyID?:             null | string @go(KMSKeyID,*string)
}

// +kubebuilder:skipversion
#FileSystemDescription: {
	availabilityZoneID?:   null | string @go(AvailabilityZoneID,*string)
	availabilityZoneName?: null | string @go(AvailabilityZoneName,*string)
	creationToken?:        null | string @go(CreationToken,*string)
	encrypted?:            null | bool   @go(Encrypted,*bool)
	fileSystemARN?:        null | string @go(FileSystemARN,*string)
	fileSystemID?:         null | string @go(FileSystemID,*string)
	kmsKeyID?:             null | string @go(KMSKeyID,*string)
	lifeCycleState?:       null | string @go(LifeCycleState,*string)
	name?:                 null | string @go(Name,*string)
	numberOfMountTargets?: null | int64  @go(NumberOfMountTargets,*int64)
	ownerID?:              null | string @go(OwnerID,*string)
	performanceMode?:      null | string @go(PerformanceMode,*string)

	// The latest known metered size (in bytes) of data stored in the file system,
	// in its Value field, and the time at which that size was determined in its
	// Timestamp field. The value doesn't represent the size of a consistent snapshot
	// of the file system, but it is eventually consistent when there are no writes
	// to the file system. That is, the value represents the actual size only if
	// the file system is not modified for a period longer than a couple of hours.
	// Otherwise, the value is not necessarily the exact size the file system was
	// at any instant in time.
	sizeInBytes?: null | #FileSystemSize @go(SizeInBytes,*FileSystemSize)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	throughputMode?: null | string @go(ThroughputMode,*string)
}

// +kubebuilder:skipversion
#FileSystemSize: {
	value?:           null | int64 @go(Value,*int64)
	valueInIA?:       null | int64 @go(ValueInIA,*int64)
	valueInStandard?: null | int64 @go(ValueInStandard,*int64)
}

// +kubebuilder:skipversion
#MountTargetDescription: {
	availabilityZoneID?:   null | string @go(AvailabilityZoneID,*string)
	availabilityZoneName?: null | string @go(AvailabilityZoneName,*string)
	fileSystemID?:         null | string @go(FileSystemID,*string)
	ipAddress?:            null | string @go(IPAddress,*string)
	lifeCycleState?:       null | string @go(LifeCycleState,*string)
	mountTargetID?:        null | string @go(MountTargetID,*string)
	networkInterfaceID?:   null | string @go(NetworkInterfaceID,*string)
	ownerID?:              null | string @go(OwnerID,*string)
	subnetID?:             null | string @go(SubnetID,*string)
	vpcID?:                null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#PosixUser: {
	gid?: null | int64 @go(Gid,*int64)
	secondaryGids?: [...null | int64] @go(SecondaryGids,[]*int64)
	uid?: null | int64 @go(Uid,*int64)
}

// +kubebuilder:skipversion
#ReplicationConfigurationDescription: {
	originalSourceFileSystemARN?: null | string @go(OriginalSourceFileSystemARN,*string)
	sourceFileSystemARN?:         null | string @go(SourceFileSystemARN,*string)
	sourceFileSystemID?:          null | string @go(SourceFileSystemID,*string)
}

// +kubebuilder:skipversion
#RootDirectory: {
	// Required if the RootDirectory > Path specified does not exist. Specifies
	// the POSIX IDs and permissions to apply to the access point's RootDirectory
	// > Path. If the access point root directory does not exist, EFS creates it
	// with these settings when a client connects to the access point. When specifying
	// CreationInfo, you must include values for all properties.
	//
	// Amazon EFS creates a root directory only if you have provided the CreationInfo:
	// OwnUid, OwnGID, and permissions for the directory. If you do not provide
	// this information, Amazon EFS does not create the root directory. If the root
	// directory does not exist, attempts to mount using the access point will fail.
	//
	// If you do not provide CreationInfo and the specified RootDirectory does not
	// exist, attempts to mount the file system using the access point will fail.
	creationInfo?: null | #CreationInfo @go(CreationInfo,*CreationInfo)
	path?:         null | string        @go(Path,*string)
}

// +kubebuilder:skipversion
#Tag: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}
