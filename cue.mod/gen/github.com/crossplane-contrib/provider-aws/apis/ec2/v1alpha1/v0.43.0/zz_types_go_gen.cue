// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane-contrib/provider-aws/apis/ec2/v1alpha1

package v1alpha1

// +kubebuilder:skipversion
#AcceleratorCount: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#AcceleratorCountRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#AcceleratorTotalMemoryMiB: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#AcceleratorTotalMemoryMiBRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#AccessScopeAnalysisFinding: {
	findingID?: null | string @go(FindingID,*string)
}

// +kubebuilder:skipversion
#AccountAttribute: {
	attributeName?: null | string @go(AttributeName,*string)
}

// +kubebuilder:skipversion
#AccountAttributeValue: {
	attributeValue?: null | string @go(AttributeValue,*string)
}

// +kubebuilder:skipversion
#ActiveInstance: {
	instanceID?:            null | string @go(InstanceID,*string)
	instanceType?:          null | string @go(InstanceType,*string)
	spotInstanceRequestID?: null | string @go(SpotInstanceRequestID,*string)
}

// +kubebuilder:skipversion
#AddIPAMOperatingRegion: {
	regionName?: null | string @go(RegionName,*string)
}

// +kubebuilder:skipversion
#AddPrefixListEntry: {
	cidr?:        null | string @go(CIDR,*string)
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#AddedPrincipal: {
	principal?:           null | string @go(Principal,*string)
	serviceID?:           null | string @go(ServiceID,*string)
	servicePermissionID?: null | string @go(ServicePermissionID,*string)
}

// +kubebuilder:skipversion
#AdditionalDetail: {
	additionalDetailType?: null | string @go(AdditionalDetailType,*string)
}

// +kubebuilder:skipversion
#Address: {
	allocationID?:            null | string @go(AllocationID,*string)
	associationID?:           null | string @go(AssociationID,*string)
	carrierIP?:               null | string @go(CarrierIP,*string)
	customerOwnedIP?:         null | string @go(CustomerOwnedIP,*string)
	customerOwnedIPv4Pool?:   null | string @go(CustomerOwnedIPv4Pool,*string)
	instanceID?:              null | string @go(InstanceID,*string)
	networkBorderGroup?:      null | string @go(NetworkBorderGroup,*string)
	networkInterfaceID?:      null | string @go(NetworkInterfaceID,*string)
	networkInterfaceOwnerID?: null | string @go(NetworkInterfaceOwnerID,*string)
	privateIPAddress?:        null | string @go(PrivateIPAddress,*string)
	publicIP?:                null | string @go(PublicIP,*string)
	publicIPv4Pool?:          null | string @go(PublicIPv4Pool,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#AddressAttribute: {
	ptrRecord?: null | string @go(PtrRecord,*string)
}

// +kubebuilder:skipversion
#AddressTransfer: {
	allocationID?:      null | string @go(AllocationID,*string)
	publicIP?:          null | string @go(PublicIP,*string)
	transferAccountID?: null | string @go(TransferAccountID,*string)
}

// +kubebuilder:skipversion
#AllowedPrincipal: {
	principal?:           null | string @go(Principal,*string)
	serviceID?:           null | string @go(ServiceID,*string)
	servicePermissionID?: null | string @go(ServicePermissionID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#AlternatePathHint: {
	componentARN?: null | string @go(ComponentARN,*string)
	componentID?:  null | string @go(ComponentID,*string)
}

// +kubebuilder:skipversion
#AnalysisACLRule: {
	cidr?:       null | string @go(CIDR,*string)
	egress?:     null | bool   @go(Egress,*bool)
	protocol?:   null | string @go(Protocol,*string)
	ruleAction?: null | string @go(RuleAction,*string)
	ruleNumber?: null | int64  @go(RuleNumber,*int64)
}

// +kubebuilder:skipversion
#AnalysisComponent: {
	arn?:  null | string @go(ARN,*string)
	id?:   null | string @go(ID,*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#AnalysisLoadBalancerTarget: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
}

// +kubebuilder:skipversion
#AnalysisPacketHeader: {
	protocol?: null | string @go(Protocol,*string)
}

// +kubebuilder:skipversion
#AnalysisRouteTableRoute: {
	destinationCIDR?:             null | string @go(DestinationCIDR,*string)
	destinationPrefixListID?:     null | string @go(DestinationPrefixListID,*string)
	egressOnlyInternetGatewayID?: null | string @go(EgressOnlyInternetGatewayID,*string)
	gatewayID?:                   null | string @go(GatewayID,*string)
	instanceID?:                  null | string @go(InstanceID,*string)
	natGatewayID?:                null | string @go(NATGatewayID,*string)
	networkInterfaceID?:          null | string @go(NetworkInterfaceID,*string)
	origin?:                      null | string @go(Origin,*string)
	state?:                       null | string @go(State,*string)
	transitGatewayID?:            null | string @go(TransitGatewayID,*string)
	vpcPeeringConnectionID?:      null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#AnalysisSecurityGroupRule: {
	cidr?:            null | string @go(CIDR,*string)
	direction?:       null | string @go(Direction,*string)
	prefixListID?:    null | string @go(PrefixListID,*string)
	protocol?:        null | string @go(Protocol,*string)
	securityGroupID?: null | string @go(SecurityGroupID,*string)
}

// +kubebuilder:skipversion
#AssignedPrivateIPAddress: {
	privateIPAddress?: null | string @go(PrivateIPAddress,*string)
}

// +kubebuilder:skipversion
#AssociatedRole: {
	certificateS3BucketName?: null | string @go(CertificateS3BucketName,*string)
	certificateS3ObjectKey?:  null | string @go(CertificateS3ObjectKey,*string)
	encryptionKMSKeyID?:      null | string @go(EncryptionKMSKeyID,*string)
}

// +kubebuilder:skipversion
#AssociatedTargetNetwork: {
	networkID?: null | string @go(NetworkID,*string)
}

// +kubebuilder:skipversion
#AssociationStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#AthenaIntegration: {
	integrationResultS3DestinationARN?: null | string @go(IntegrationResultS3DestinationARN,*string)
}

// +kubebuilder:skipversion
#AttachmentENASrdSpecification: {
	enaSrdEnabled?: null | bool @go(ENASrdEnabled,*bool)
}

// +kubebuilder:skipversion
#AttachmentENASrdUDPSpecification: {
	enaSrdUDPEnabled?: null | bool @go(ENASrdUDPEnabled,*bool)
}

// +kubebuilder:skipversion
#AttributeBooleanValue: {
	value?: null | bool @go(Value,*bool)
}

// +kubebuilder:skipversion
#AttributeValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#AuthorizationRule: {
	accessAll?:           null | bool   @go(AccessAll,*bool)
	clientVPNEndpointID?: null | string @go(ClientVPNEndpointID,*string)
	description?:         null | string @go(Description,*string)
	destinationCIDR?:     null | string @go(DestinationCIDR,*string)
	groupID?:             null | string @go(GroupID,*string)
}

// +kubebuilder:skipversion
#AvailabilityZone: {
	groupName?:          null | string @go(GroupName,*string)
	networkBorderGroup?: null | string @go(NetworkBorderGroup,*string)
	parentZoneID?:       null | string @go(ParentZoneID,*string)
	parentZoneName?:     null | string @go(ParentZoneName,*string)
	regionName?:         null | string @go(RegionName,*string)
	zoneID?:             null | string @go(ZoneID,*string)
	zoneName?:           null | string @go(ZoneName,*string)
	zoneType?:           null | string @go(ZoneType,*string)
}

// +kubebuilder:skipversion
#AvailabilityZoneMessage: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#AvailableCapacity: {
	availableVCPUs?: null | int64 @go(AvailableVCPUs,*int64)
}

// +kubebuilder:skipversion
#BaselineEBSBandwidthMbps: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#BaselineEBSBandwidthMbpsRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#BlockDeviceMapping: {
	deviceName?:  null | string @go(DeviceName,*string)
	noDevice?:    null | string @go(NoDevice,*string)
	virtualName?: null | string @go(VirtualName,*string)
}

// +kubebuilder:skipversion
#BundleTask: {
	bundleID?:   null | string @go(BundleID,*string)
	instanceID?: null | string @go(InstanceID,*string)
	progress?:   null | string @go(Progress,*string)
}

// +kubebuilder:skipversion
#BundleTaskError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ByoipCIDR: {
	cidr?:          null | string @go(CIDR,*string)
	description?:   null | string @go(Description,*string)
	statusMessage?: null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#CIDRAuthorizationContext: {
	message?:   null | string @go(Message,*string)
	signature?: null | string @go(Signature,*string)
}

// +kubebuilder:skipversion
#CIDRBlock: {
	cidrBlock?: null | string @go(CIDRBlock,*string)
}

// +kubebuilder:skipversion
#CPUOptions: {
	coreCount?:      null | int64 @go(CoreCount,*int64)
	threadsPerCore?: null | int64 @go(ThreadsPerCore,*int64)
}

// +kubebuilder:skipversion
#CPUOptionsRequest: {
	coreCount?:      null | int64 @go(CoreCount,*int64)
	threadsPerCore?: null | int64 @go(ThreadsPerCore,*int64)
}

// +kubebuilder:skipversion
#CancelSpotFleetRequestsError: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#CancelSpotFleetRequestsErrorItem: {
	spotFleetRequestID?: null | string @go(SpotFleetRequestID,*string)
}

// +kubebuilder:skipversion
#CancelSpotFleetRequestsSuccessItem: {
	spotFleetRequestID?: null | string @go(SpotFleetRequestID,*string)
}

// +kubebuilder:skipversion
#CancelledSpotInstanceRequest: {
	spotInstanceRequestID?: null | string @go(SpotInstanceRequestID,*string)
}

// +kubebuilder:skipversion
#CapacityAllocation: {
	count?: null | int64 @go(Count,*int64)
}

// +kubebuilder:skipversion
#CapacityReservation: {
	availabilityZone?:           null | string @go(AvailabilityZone,*string)
	availabilityZoneID?:         null | string @go(AvailabilityZoneID,*string)
	availableInstanceCount?:     null | int64  @go(AvailableInstanceCount,*int64)
	capacityReservationARN?:     null | string @go(CapacityReservationARN,*string)
	capacityReservationFleetID?: null | string @go(CapacityReservationFleetID,*string)
	capacityReservationID?:      null | string @go(CapacityReservationID,*string)
	ebsOptimized?:               null | bool   @go(EBSOptimized,*bool)
	ephemeralStorage?:           null | bool   @go(EphemeralStorage,*bool)
	instanceType?:               null | string @go(InstanceType,*string)
	ownerID?:                    null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	totalInstanceCount?: null | int64 @go(TotalInstanceCount,*int64)
}

// +kubebuilder:skipversion
#CapacityReservationFleet: {
	allocationStrategy?:          null | string @go(AllocationStrategy,*string)
	capacityReservationFleetARN?: null | string @go(CapacityReservationFleetARN,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	totalFulfilledCapacity?: null | float64 @go(TotalFulfilledCapacity,*float64)
	totalTargetCapacity?:    null | int64   @go(TotalTargetCapacity,*int64)
}

// +kubebuilder:skipversion
#CapacityReservationGroup: {
	groupARN?: null | string @go(GroupARN,*string)
	ownerID?:  null | string @go(OwnerID,*string)
}

// +kubebuilder:skipversion
#CapacityReservationSpecification: {
	capacityReservationPreference?: null | string @go(CapacityReservationPreference,*string)

	// Describes a target Capacity Reservation or Capacity Reservation group.
	capacityReservationTarget?: null | #CapacityReservationTarget @go(CapacityReservationTarget,*CapacityReservationTarget)
}

// +kubebuilder:skipversion
#CapacityReservationSpecificationResponse: {
	capacityReservationPreference?: null | string @go(CapacityReservationPreference,*string)

	// Describes a target Capacity Reservation or Capacity Reservation group.
	capacityReservationTarget?: null | #CapacityReservationTargetResponse @go(CapacityReservationTarget,*CapacityReservationTargetResponse)
}

// +kubebuilder:skipversion
#CapacityReservationTarget: {
	capacityReservationID?:               null | string @go(CapacityReservationID,*string)
	capacityReservationResourceGroupARN?: null | string @go(CapacityReservationResourceGroupARN,*string)
}

// +kubebuilder:skipversion
#CapacityReservationTargetResponse: {
	capacityReservationID?:               null | string @go(CapacityReservationID,*string)
	capacityReservationResourceGroupARN?: null | string @go(CapacityReservationResourceGroupARN,*string)
}

// +kubebuilder:skipversion
#CarrierGateway: {
	carrierGatewayID?: null | string @go(CarrierGatewayID,*string)
	ownerID?:          null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#CertificateAuthentication: {
	clientRootCertificateChain?: null | string @go(ClientRootCertificateChain,*string)
}

// +kubebuilder:skipversion
#CertificateAuthenticationRequest: {
	clientRootCertificateChainARN?: null | string @go(ClientRootCertificateChainARN,*string)
}

// +kubebuilder:skipversion
#ClassicLinkDNSSupport: {
	classicLinkDNSSupported?: null | bool   @go(ClassicLinkDNSSupported,*bool)
	vpcID?:                   null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#ClassicLinkInstance: {
	instanceID?: null | string @go(InstanceID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#ClassicLoadBalancer: {
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#ClientCertificateRevocationListStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ClientConnectOptions: {
	enabled?:           null | bool   @go(Enabled,*bool)
	lambdaFunctionARN?: null | string @go(LambdaFunctionARN,*string)
}

// +kubebuilder:skipversion
#ClientConnectResponseOptions: {
	enabled?:           null | bool   @go(Enabled,*bool)
	lambdaFunctionARN?: null | string @go(LambdaFunctionARN,*string)
}

// +kubebuilder:skipversion
#ClientData: {
	comment?:    null | string  @go(Comment,*string)
	uploadSize?: null | float64 @go(UploadSize,*float64)
}

// +kubebuilder:skipversion
#ClientLoginBannerOptions: {
	bannerText?: null | string @go(BannerText,*string)
	enabled?:    null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#ClientLoginBannerResponseOptions: {
	bannerText?: null | string @go(BannerText,*string)
	enabled?:    null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#ClientVPNAuthorizationRuleStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ClientVPNConnection: {
	clientIP?:                  null | string @go(ClientIP,*string)
	clientVPNEndpointID?:       null | string @go(ClientVPNEndpointID,*string)
	commonName?:                null | string @go(CommonName,*string)
	connectionEndTime?:         null | string @go(ConnectionEndTime,*string)
	connectionEstablishedTime?: null | string @go(ConnectionEstablishedTime,*string)
	connectionID?:              null | string @go(ConnectionID,*string)
	egressBytes?:               null | string @go(EgressBytes,*string)
	egressPackets?:             null | string @go(EgressPackets,*string)
	ingressBytes?:              null | string @go(IngressBytes,*string)
	ingressPackets?:            null | string @go(IngressPackets,*string)
	postureComplianceStatuses?: [...null | string] @go(PostureComplianceStatuses,[]*string)
	timestamp?: null | string @go(Timestamp,*string)
	username?:  null | string @go(Username,*string)
}

// +kubebuilder:skipversion
#ClientVPNConnectionStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ClientVPNEndpoint: {
	clientCIDRBlock?:     null | string @go(ClientCIDRBlock,*string)
	clientVPNEndpointID?: null | string @go(ClientVPNEndpointID,*string)
	creationTime?:        null | string @go(CreationTime,*string)
	deletionTime?:        null | string @go(DeletionTime,*string)
	description?:         null | string @go(Description,*string)
	dnsName?:             null | string @go(DNSName,*string)
	dnsServers?: [...null | string] @go(DNSServers,[]*string)
	selfServicePortalURL?: null | string @go(SelfServicePortalURL,*string)
	serverCertificateARN?: null | string @go(ServerCertificateARN,*string)
	sessionTimeoutHours?:  null | int64  @go(SessionTimeoutHours,*int64)
	splitTunnel?:          null | bool   @go(SplitTunnel,*bool)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpnPort?: null | int64 @go(VPNPort,*int64)
}

// +kubebuilder:skipversion
#ClientVPNEndpointAttributeStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ClientVPNEndpointStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ClientVPNRoute: {
	clientVPNEndpointID?: null | string @go(ClientVPNEndpointID,*string)
	description?:         null | string @go(Description,*string)
	destinationCIDR?:     null | string @go(DestinationCIDR,*string)
	origin?:              null | string @go(Origin,*string)
	targetSubnet?:        null | string @go(TargetSubnet,*string)
	type_?:               null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#ClientVPNRouteStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#CloudWatchLogOptions: {
	logEnabled?:      null | bool   @go(LogEnabled,*bool)
	logGroupARN?:     null | string @go(LogGroupARN,*string)
	logOutputFormat?: null | string @go(LogOutputFormat,*string)
}

// +kubebuilder:skipversion
#CloudWatchLogOptionsSpecification: {
	logEnabled?:      null | bool   @go(LogEnabled,*bool)
	logOutputFormat?: null | string @go(LogOutputFormat,*string)
}

// +kubebuilder:skipversion
#CoipAddressUsage: {
	allocationID?: null | string @go(AllocationID,*string)
	awsAccountID?: null | string @go(AWSAccountID,*string)
	awsService?:   null | string @go(AWSService,*string)
	coIP?:         null | string @go(CoIP,*string)
}

// +kubebuilder:skipversion
#CoipCIDR: {
	cidr?:                     null | string @go(CIDR,*string)
	localGatewayRouteTableID?: null | string @go(LocalGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#CoipPool: {
	poolCIDRs?: [...null | string] @go(PoolCIDRs,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ConnectionLogOptions: {
	cloudwatchLogGroup?:  null | string @go(CloudwatchLogGroup,*string)
	cloudwatchLogStream?: null | string @go(CloudwatchLogStream,*string)
	enabled?:             null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#ConnectionLogResponseOptions: {
	cloudwatchLogGroup?:  null | string @go(CloudwatchLogGroup,*string)
	cloudwatchLogStream?: null | string @go(CloudwatchLogStream,*string)
	enabled?:             null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#ConnectionNotification: {
	connectionEvents?: [...null | string] @go(ConnectionEvents,[]*string)
	connectionNotificationARN?: null | string @go(ConnectionNotificationARN,*string)
	connectionNotificationID?:  null | string @go(ConnectionNotificationID,*string)
	serviceID?:                 null | string @go(ServiceID,*string)
	vpcEndpointID?:             null | string @go(VPCEndpointID,*string)
}

// +kubebuilder:skipversion
#ConversionTask: {
	conversionTaskID?: null | string @go(ConversionTaskID,*string)
	expirationTime?:   null | string @go(ExpirationTime,*string)
	statusMessage?:    null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#CreateFleetError: {
	errorCode?:    null | string @go(ErrorCode,*string)
	errorMessage?: null | string @go(ErrorMessage,*string)
}

// +kubebuilder:skipversion
#CreateFleetInstance: {
	instanceType?: null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#CreateTransitGatewayVPCAttachmentRequestOptions: {
	applianceModeSupport?: null | string @go(ApplianceModeSupport,*string)
	dnsSupport?:           null | string @go(DNSSupport,*string)
	ipv6Support?:          null | string @go(IPv6Support,*string)
}

// +kubebuilder:skipversion
#CreateVerifiedAccessEndpointEniOptions: {
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
}

// +kubebuilder:skipversion
#CreateVerifiedAccessTrustProviderDeviceOptions: {
	tenantID?: null | string @go(TenantID,*string)
}

// +kubebuilder:skipversion
#CreateVerifiedAccessTrustProviderOIDCOptions: {
	authorizationEndpoint?: null | string @go(AuthorizationEndpoint,*string)
	clientID?:              null | string @go(ClientID,*string)
	clientSecret?:          null | string @go(ClientSecret,*string)
	issuer?:                null | string @go(Issuer,*string)
	scope?:                 null | string @go(Scope,*string)
	tokenEndpoint?:         null | string @go(TokenEndpoint,*string)
	userInfoEndpoint?:      null | string @go(UserInfoEndpoint,*string)
}

// +kubebuilder:skipversion
#CreateVolumePermission: {
	userID?: null | string @go(UserID,*string)
}

// +kubebuilder:skipversion
#CreditSpecification: {
	cpuCredits?: null | string @go(CPUCredits,*string)
}

// +kubebuilder:skipversion
#CreditSpecificationRequest: {
	cpuCredits?: null | string @go(CPUCredits,*string)
}

// +kubebuilder:skipversion
#CustomerGateway: {
	bgpASN?:            null | string @go(BGPASN,*string)
	certificateARN?:    null | string @go(CertificateARN,*string)
	customerGatewayID?: null | string @go(CustomerGatewayID,*string)
	deviceName?:        null | string @go(DeviceName,*string)
	ipAddress?:         null | string @go(IPAddress,*string)
	state?:             null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#DHCPConfiguration: {
	key?: null | string @go(Key,*string)
}

// +kubebuilder:skipversion
#DHCPOptions: {
	dhcpOptionsID?: null | string @go(DHCPOptionsID,*string)
	ownerID?:       null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#DNSEntry: {
	dnsName?:      null | string @go(DNSName,*string)
	hostedZoneID?: null | string @go(HostedZoneID,*string)
}

// +kubebuilder:skipversion
#DNSOptions: {
	dnsRecordIPType?: null | string @go(DNSRecordIPType,*string)
}

// +kubebuilder:skipversion
#DNSOptionsSpecification: {
	dnsRecordIPType?: null | string @go(DNSRecordIPType,*string)
}

// +kubebuilder:skipversion
#DNSServersOptionsModifyStructure: {
	customDNSServers?: [...null | string] @go(CustomDNSServers,[]*string)
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#DataQuery: {
	destination?: null | string @go(Destination,*string)
	id?:          null | string @go(ID,*string)
	source?:      null | string @go(Source,*string)
}

// +kubebuilder:skipversion
#DataResponse: {
	destination?: null | string @go(Destination,*string)
	id?:          null | string @go(ID,*string)
	source?:      null | string @go(Source,*string)
}

// +kubebuilder:skipversion
#DeleteFleetError: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#DeleteLaunchTemplateVersionsResponseErrorItem: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	versionNumber?:      null | int64  @go(VersionNumber,*int64)
}

// +kubebuilder:skipversion
#DeleteLaunchTemplateVersionsResponseSuccessItem: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	versionNumber?:      null | int64  @go(VersionNumber,*int64)
}

// +kubebuilder:skipversion
#DeleteQueuedReservedInstancesError: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#DeregisterInstanceTagAttributeRequest: {
	includeAllTagsOfInstance?: null | bool @go(IncludeAllTagsOfInstance,*bool)
}

// +kubebuilder:skipversion
#DescribeFastLaunchImagesSuccessItem: {
	imageID?:               null | string @go(ImageID,*string)
	maxParallelLaunches?:   null | int64  @go(MaxParallelLaunches,*int64)
	ownerID?:               null | string @go(OwnerID,*string)
	stateTransitionReason?: null | string @go(StateTransitionReason,*string)
}

// +kubebuilder:skipversion
#DescribeFastSnapshotRestoreSuccessItem: {
	availabilityZone?:      null | string @go(AvailabilityZone,*string)
	ownerAlias?:            null | string @go(OwnerAlias,*string)
	ownerID?:               null | string @go(OwnerID,*string)
	snapshotID?:            null | string @go(SnapshotID,*string)
	stateTransitionReason?: null | string @go(StateTransitionReason,*string)
}

// +kubebuilder:skipversion
#DescribeFleetError: {
	errorCode?:    null | string @go(ErrorCode,*string)
	errorMessage?: null | string @go(ErrorMessage,*string)
}

// +kubebuilder:skipversion
#DescribeFleetsInstances: {
	instanceType?: null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#DestinationOptionsRequest: {
	fileFormat?:               null | string @go(FileFormat,*string)
	hiveCompatiblePartitions?: null | bool   @go(HiveCompatiblePartitions,*bool)
	perHourPartition?:         null | bool   @go(PerHourPartition,*bool)
}

// +kubebuilder:skipversion
#DestinationOptionsResponse: {
	fileFormat?:               null | string @go(FileFormat,*string)
	hiveCompatiblePartitions?: null | bool   @go(HiveCompatiblePartitions,*bool)
	perHourPartition?:         null | bool   @go(PerHourPartition,*bool)
}

// +kubebuilder:skipversion
#DeviceOptions: {
	tenantID?: null | string @go(TenantID,*string)
}

// +kubebuilder:skipversion
#DirectoryServiceAuthentication: {
	directoryID?: null | string @go(DirectoryID,*string)
}

// +kubebuilder:skipversion
#DirectoryServiceAuthenticationRequest: {
	directoryID?: null | string @go(DirectoryID,*string)
}

// +kubebuilder:skipversion
#DisableFastSnapshotRestoreErrorItem: {
	snapshotID?: null | string @go(SnapshotID,*string)
}

// +kubebuilder:skipversion
#DisableFastSnapshotRestoreStateError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#DisableFastSnapshotRestoreStateErrorItem: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
}

// +kubebuilder:skipversion
#DisableFastSnapshotRestoreSuccessItem: {
	availabilityZone?:      null | string @go(AvailabilityZone,*string)
	ownerAlias?:            null | string @go(OwnerAlias,*string)
	ownerID?:               null | string @go(OwnerID,*string)
	snapshotID?:            null | string @go(SnapshotID,*string)
	stateTransitionReason?: null | string @go(StateTransitionReason,*string)
}

// +kubebuilder:skipversion
#DiskImage: {
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#DiskImageDescription: {
	checksum?:          null | string @go(Checksum,*string)
	importManifestURL?: null | string @go(ImportManifestURL,*string)
	size?:              null | int64  @go(Size,*int64)
}

// +kubebuilder:skipversion
#DiskImageDetail: {
	bytes?:             null | int64  @go(Bytes,*int64)
	importManifestURL?: null | string @go(ImportManifestURL,*string)
}

// +kubebuilder:skipversion
#DiskImageVolumeDescription: {
	id?:   null | string @go(ID,*string)
	size?: null | int64  @go(Size,*int64)
}

// +kubebuilder:skipversion
#EBSBlockDevice: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	encrypted?:           null | bool   @go(Encrypted,*bool)
	iops?:                null | int64  @go(IOPS,*int64)
	kmsKeyID?:            null | string @go(KMSKeyID,*string)
	outpostARN?:          null | string @go(OutpostARN,*string)
	snapshotID?:          null | string @go(SnapshotID,*string)
	throughput?:          null | int64  @go(Throughput,*int64)
	volumeSize?:          null | int64  @go(VolumeSize,*int64)
	volumeType?:          null | string @go(VolumeType,*string)
}

// +kubebuilder:skipversion
#EBSInstanceBlockDevice: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	volumeID?:            null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#EBSInstanceBlockDeviceSpecification: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	volumeID?:            null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#ENASrdSpecification: {
	enaSrdEnabled?: null | bool @go(ENASrdEnabled,*bool)
}

// +kubebuilder:skipversion
#ENASrdUDPSpecification: {
	enaSrdUDPEnabled?: null | bool @go(ENASrdUDPEnabled,*bool)
}

// +kubebuilder:skipversion
#EgressOnlyInternetGateway: {
	egressOnlyInternetGatewayID?: null | string @go(EgressOnlyInternetGatewayID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ElasticGPUAssociation: {
	elasticGPUAssociationID?:    null | string @go(ElasticGPUAssociationID,*string)
	elasticGPUAssociationState?: null | string @go(ElasticGPUAssociationState,*string)
	elasticGPUAssociationTime?:  null | string @go(ElasticGPUAssociationTime,*string)
}

// +kubebuilder:skipversion
#ElasticGPUSpecification: {
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#ElasticGPUSpecificationResponse: {
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#ElasticGPUs: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	elasticGPUID?:     null | string @go(ElasticGPUID,*string)
	elasticGPUType?:   null | string @go(ElasticGPUType,*string)
	instanceID?:       null | string @go(InstanceID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ElasticInferenceAccelerator: {
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#ElasticInferenceAcceleratorAssociation: {
	elasticInferenceAcceleratorARN?:              null | string @go(ElasticInferenceAcceleratorARN,*string)
	elasticInferenceAcceleratorAssociationID?:    null | string @go(ElasticInferenceAcceleratorAssociationID,*string)
	elasticInferenceAcceleratorAssociationState?: null | string @go(ElasticInferenceAcceleratorAssociationState,*string)
}

// +kubebuilder:skipversion
#EnableFastSnapshotRestoreErrorItem: {
	snapshotID?: null | string @go(SnapshotID,*string)
}

// +kubebuilder:skipversion
#EnableFastSnapshotRestoreStateError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#EnableFastSnapshotRestoreStateErrorItem: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
}

// +kubebuilder:skipversion
#EnableFastSnapshotRestoreSuccessItem: {
	availabilityZone?:      null | string @go(AvailabilityZone,*string)
	ownerAlias?:            null | string @go(OwnerAlias,*string)
	ownerID?:               null | string @go(OwnerID,*string)
	snapshotID?:            null | string @go(SnapshotID,*string)
	stateTransitionReason?: null | string @go(StateTransitionReason,*string)
}

// +kubebuilder:skipversion
#EnclaveOptions: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#EnclaveOptionsRequest: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#EventInformation: {
	eventDescription?: null | string @go(EventDescription,*string)
	eventSubType?:     null | string @go(EventSubType,*string)
	instanceID?:       null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#Explanation: {
	availabilityZones?: [...null | string] @go(AvailabilityZones,[]*string)
	cidrs?: [...null | string] @go(CIDRs,[]*string)
	direction?:        null | string @go(Direction,*string)
	explanationCode?:  null | string @go(ExplanationCode,*string)
	missingComponent?: null | string @go(MissingComponent,*string)
	packetField?:      null | string @go(PacketField,*string)
	state?:            null | string @go(State,*string)
}

// +kubebuilder:skipversion
#ExportImageTask: {
	description?:       null | string @go(Description,*string)
	exportImageTaskID?: null | string @go(ExportImageTaskID,*string)
	imageID?:           null | string @go(ImageID,*string)
	progress?:          null | string @go(Progress,*string)
	status?:            null | string @go(Status,*string)
	statusMessage?:     null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ExportTask: {
	description?:   null | string @go(Description,*string)
	exportTaskID?:  null | string @go(ExportTaskID,*string)
	statusMessage?: null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ExportTaskS3Location: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Prefix?: null | string @go(S3Prefix,*string)
}

// +kubebuilder:skipversion
#ExportTaskS3LocationRequest: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Prefix?: null | string @go(S3Prefix,*string)
}

// +kubebuilder:skipversion
#ExportToS3Task: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Key?:    null | string @go(S3Key,*string)
}

// +kubebuilder:skipversion
#ExportToS3TaskSpecification: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Prefix?: null | string @go(S3Prefix,*string)
}

// +kubebuilder:skipversion
#FPGAImage: {
	dataRetentionSupport?: null | bool   @go(DataRetentionSupport,*bool)
	description?:          null | string @go(Description,*string)
	fpgaImageGlobalID?:    null | string @go(FPGAImageGlobalID,*string)
	fpgaImageID?:          null | string @go(FPGAImageID,*string)
	name?:                 null | string @go(Name,*string)
	ownerAlias?:           null | string @go(OwnerAlias,*string)
	ownerID?:              null | string @go(OwnerID,*string)
	public?:               null | bool   @go(Public,*bool)
	shellVersion?:         null | string @go(ShellVersion,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#FPGAImageAttribute: {
	description?: null | string @go(Description,*string)
	fpgaImageID?: null | string @go(FPGAImageID,*string)
	name?:        null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#FPGAImageState: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#FailedQueuedPurchaseDeletion: {
	reservedInstancesID?: null | string @go(ReservedInstancesID,*string)
}

// +kubebuilder:skipversion
#FastLaunchLaunchTemplateSpecificationRequest: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	version?:            null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#FastLaunchLaunchTemplateSpecificationResponse: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	version?:            null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#FastLaunchSnapshotConfigurationRequest: {
	targetResourceCount?: null | int64 @go(TargetResourceCount,*int64)
}

// +kubebuilder:skipversion
#FastLaunchSnapshotConfigurationResponse: {
	targetResourceCount?: null | int64 @go(TargetResourceCount,*int64)
}

// +kubebuilder:skipversion
#FederatedAuthentication: {
	samlProviderARN?:            null | string @go(SamlProviderARN,*string)
	selfServiceSamlProviderARN?: null | string @go(SelfServiceSamlProviderARN,*string)
}

// +kubebuilder:skipversion
#FederatedAuthenticationRequest: {
	sAMLProviderARN?:            null | string @go(SAMLProviderARN,*string)
	selfServiceSAMLProviderARN?: null | string @go(SelfServiceSAMLProviderARN,*string)
}

// +kubebuilder:skipversion
#Filter: {
	name?: null | string @go(Name,*string)
	values?: [...null | string] @go(Values,[]*string)
}

// +kubebuilder:skipversion
#FleetCapacityReservation: {
	availabilityZone?:      null | string  @go(AvailabilityZone,*string)
	availabilityZoneID?:    null | string  @go(AvailabilityZoneID,*string)
	capacityReservationID?: null | string  @go(CapacityReservationID,*string)
	ebsOptimized?:          null | bool    @go(EBSOptimized,*bool)
	fulfilledCapacity?:     null | float64 @go(FulfilledCapacity,*float64)
	instanceType?:          null | string  @go(InstanceType,*string)
	totalInstanceCount?:    null | int64   @go(TotalInstanceCount,*int64)
}

// +kubebuilder:skipversion
#FleetData: {
	clientToken?:               null | string  @go(ClientToken,*string)
	context?:                   null | string  @go(Context,*string)
	fulfilledCapacity?:         null | float64 @go(FulfilledCapacity,*float64)
	fulfilledOnDemandCapacity?: null | float64 @go(FulfilledOnDemandCapacity,*float64)
	replaceUnhealthyInstances?: null | bool    @go(ReplaceUnhealthyInstances,*bool)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	terminateInstancesWithExpiration?: null | bool @go(TerminateInstancesWithExpiration,*bool)
}

// +kubebuilder:skipversion
#FleetLaunchTemplateOverrides: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	imageID?:          null | string @go(ImageID,*string)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirements @go(InstanceRequirements,*InstanceRequirements)
	instanceType?:         null | string                @go(InstanceType,*string)
	maxPrice?:             null | string                @go(MaxPrice,*string)
	priority?:             null | float64               @go(Priority,*float64)
	subnetID?:             null | string                @go(SubnetID,*string)
	weightedCapacity?:     null | float64               @go(WeightedCapacity,*float64)
}

// +kubebuilder:skipversion
#FleetLaunchTemplateOverridesRequest: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	imageID?:          null | string @go(ImageID,*string)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirementsRequest @go(InstanceRequirements,*InstanceRequirementsRequest)
	instanceType?:         null | string                       @go(InstanceType,*string)
	maxPrice?:             null | string                       @go(MaxPrice,*string)
	priority?:             null | float64                      @go(Priority,*float64)
	subnetID?:             null | string                       @go(SubnetID,*string)
	weightedCapacity?:     null | float64                      @go(WeightedCapacity,*float64)
}

// +kubebuilder:skipversion
#FleetLaunchTemplateSpecification: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	version?:            null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#FleetLaunchTemplateSpecificationRequest: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	version?:            null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#FleetSpotCapacityRebalance: {
	terminationDelay?: null | int64 @go(TerminationDelay,*int64)
}

// +kubebuilder:skipversion
#FleetSpotCapacityRebalanceRequest: {
	terminationDelay?: null | int64 @go(TerminationDelay,*int64)
}

// +kubebuilder:skipversion
#FlowLog_SDK: {
	deliverCrossAccountRole?:  null | string @go(DeliverCrossAccountRole,*string)
	deliverLogsErrorMessage?:  null | string @go(DeliverLogsErrorMessage,*string)
	deliverLogsPermissionARN?: null | string @go(DeliverLogsPermissionARN,*string)
	deliverLogsStatus?:        null | string @go(DeliverLogsStatus,*string)

	// Describes the destination options for a flow log.
	destinationOptions?:     null | #DestinationOptionsResponse @go(DestinationOptions,*DestinationOptionsResponse)
	flowLogID?:              null | string                      @go(FlowLogID,*string)
	flowLogStatus?:          null | string                      @go(FlowLogStatus,*string)
	logDestination?:         null | string                      @go(LogDestination,*string)
	logDestinationType?:     null | string                      @go(LogDestinationType,*string)
	logFormat?:              null | string                      @go(LogFormat,*string)
	logGroupName?:           null | string                      @go(LogGroupName,*string)
	maxAggregationInterval?: null | int64                       @go(MaxAggregationInterval,*int64)
	resourceID?:             null | string                      @go(ResourceID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	trafficType?: null | string @go(TrafficType,*string)
}

// +kubebuilder:skipversion
#GroupIdentifier: {
	groupID?:   null | string @go(GroupID,*string)
	groupName?: null | string @go(GroupName,*string)
}

// +kubebuilder:skipversion
#HibernationOptions: {
	configured?: null | bool @go(Configured,*bool)
}

// +kubebuilder:skipversion
#HibernationOptionsRequest: {
	configured?: null | bool @go(Configured,*bool)
}

// +kubebuilder:skipversion
#Host: {
	availabilityZone?:                   null | string @go(AvailabilityZone,*string)
	availabilityZoneID?:                 null | string @go(AvailabilityZoneID,*string)
	clientToken?:                        null | string @go(ClientToken,*string)
	hostID?:                             null | string @go(HostID,*string)
	hostReservationID?:                  null | string @go(HostReservationID,*string)
	memberOfServiceLinkedResourceGroup?: null | bool   @go(MemberOfServiceLinkedResourceGroup,*bool)
	outpostARN?:                         null | string @go(OutpostARN,*string)
	ownerID?:                            null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#HostInstance: {
	instanceID?:   null | string @go(InstanceID,*string)
	instanceType?: null | string @go(InstanceType,*string)
	ownerID?:      null | string @go(OwnerID,*string)
}

// +kubebuilder:skipversion
#HostOffering: {
	duration?:       null | int64  @go(Duration,*int64)
	hourlyPrice?:    null | string @go(HourlyPrice,*string)
	instanceFamily?: null | string @go(InstanceFamily,*string)
	upfrontPrice?:   null | string @go(UpfrontPrice,*string)
}

// +kubebuilder:skipversion
#HostProperties: {
	cores?:          null | int64  @go(Cores,*int64)
	instanceFamily?: null | string @go(InstanceFamily,*string)
	instanceType?:   null | string @go(InstanceType,*string)
	sockets?:        null | int64  @go(Sockets,*int64)
	totalVCPUs?:     null | int64  @go(TotalVCPUs,*int64)
}

// +kubebuilder:skipversion
#HostReservation: {
	count?:          null | int64  @go(Count,*int64)
	duration?:       null | int64  @go(Duration,*int64)
	hourlyPrice?:    null | string @go(HourlyPrice,*string)
	instanceFamily?: null | string @go(InstanceFamily,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	upfrontPrice?: null | string @go(UpfrontPrice,*string)
}

// +kubebuilder:skipversion
#IAMInstanceProfile: {
	arn?: null | string @go(ARN,*string)
	id?:  null | string @go(ID,*string)
}

// +kubebuilder:skipversion
#IAMInstanceProfileAssociation: {
	associationID?: null | string @go(AssociationID,*string)
	instanceID?:    null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#IAMInstanceProfileSpecification: {
	arn?:  null | string @go(ARN,*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#ICMPTypeCode: {
	code?:  null | int64 @go(Code,*int64)
	type_?: null | int64 @go(Type,*int64)
}

// +kubebuilder:skipversion
#IDFormat: {
	resource?:   null | string @go(Resource,*string)
	useLongIDs?: null | bool   @go(UseLongIDs,*bool)
}

// +kubebuilder:skipversion
#IKEVersionsListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#IKEVersionsRequestListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#IPAM: {
	description?: null | string @go(Description,*string)
	ipamRegion?:  null | string @go(IPAMRegion,*string)
	ownerID?:     null | string @go(OwnerID,*string)
	scopeCount?:  null | int64  @go(ScopeCount,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#IPAMAddressHistoryRecord: {
	resourceCIDR?:    null | string @go(ResourceCIDR,*string)
	resourceID?:      null | string @go(ResourceID,*string)
	resourceName?:    null | string @go(ResourceName,*string)
	resourceOwnerID?: null | string @go(ResourceOwnerID,*string)
	resourceRegion?:  null | string @go(ResourceRegion,*string)
	vpcID?:           null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#IPAMCIDRAuthorizationContext: {
	message?:   null | string @go(Message,*string)
	signature?: null | string @go(Signature,*string)
}

// +kubebuilder:skipversion
#IPAMOperatingRegion: {
	regionName?: null | string @go(RegionName,*string)
}

// +kubebuilder:skipversion
#IPAMPool: {
	autoImport?:           null | bool   @go(AutoImport,*bool)
	description?:          null | string @go(Description,*string)
	ipamRegion?:           null | string @go(IPAMRegion,*string)
	locale?:               null | string @go(Locale,*string)
	ownerID?:              null | string @go(OwnerID,*string)
	poolDepth?:            null | int64  @go(PoolDepth,*int64)
	publiclyAdvertisable?: null | bool   @go(PubliclyAdvertisable,*bool)
	stateMessage?:         null | string @go(StateMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#IPAMPoolAllocation: {
	cidr?:           null | string @go(CIDR,*string)
	description?:    null | string @go(Description,*string)
	resourceID?:     null | string @go(ResourceID,*string)
	resourceOwner?:  null | string @go(ResourceOwner,*string)
	resourceRegion?: null | string @go(ResourceRegion,*string)
}

// +kubebuilder:skipversion
#IPAMPoolCIDR: {
	cidr?: null | string @go(CIDR,*string)
}

// +kubebuilder:skipversion
#IPAMPoolCIDRFailureReason: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#IPAMResourceCIDR: {
	resourceCIDR?:    null | string @go(ResourceCIDR,*string)
	resourceID?:      null | string @go(ResourceID,*string)
	resourceName?:    null | string @go(ResourceName,*string)
	resourceOwnerID?: null | string @go(ResourceOwnerID,*string)
	resourceRegion?:  null | string @go(ResourceRegion,*string)
	vpcID?:           null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#IPAMResourceTag: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#IPAMScope: {
	description?: null | string @go(Description,*string)
	ipamRegion?:  null | string @go(IPAMRegion,*string)
	isDefault?:   null | bool   @go(IsDefault,*bool)
	ownerID?:     null | string @go(OwnerID,*string)
	poolCount?:   null | int64  @go(PoolCount,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#IPPermission: {
	fromPort?:   null | int64  @go(FromPort,*int64)
	ipProtocol?: null | string @go(IPProtocol,*string)
	toPort?:     null | int64  @go(ToPort,*int64)
}

// +kubebuilder:skipversion
#IPRange: {
	cidrIP?:      null | string @go(CIDRIP,*string)
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#IPv4PrefixSpecification: {
	ipv4Prefix?: null | string @go(IPv4Prefix,*string)
}

// +kubebuilder:skipversion
#IPv4PrefixSpecificationRequest: {
	ipv4Prefix?: null | string @go(IPv4Prefix,*string)
}

// +kubebuilder:skipversion
#IPv4PrefixSpecificationResponse: {
	ipv4Prefix?: null | string @go(IPv4Prefix,*string)
}

// +kubebuilder:skipversion
#IPv6CIDRAssociation: {
	associatedResource?: null | string @go(AssociatedResource,*string)
	ipv6CIDR?:           null | string @go(IPv6CIDR,*string)
}

// +kubebuilder:skipversion
#IPv6CIDRBlock: {
	ipv6CIDRBlock?: null | string @go(IPv6CIDRBlock,*string)
}

// +kubebuilder:skipversion
#IPv6Pool: {
	description?: null | string @go(Description,*string)
	poolID?:      null | string @go(PoolID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#IPv6PrefixSpecification: {
	ipv6Prefix?: null | string @go(IPv6Prefix,*string)
}

// +kubebuilder:skipversion
#IPv6PrefixSpecificationRequest: {
	ipv6Prefix?: null | string @go(IPv6Prefix,*string)
}

// +kubebuilder:skipversion
#IPv6PrefixSpecificationResponse: {
	ipv6Prefix?: null | string @go(IPv6Prefix,*string)
}

// +kubebuilder:skipversion
#IPv6Range: {
	cidrIPv6?:    null | string @go(CIDRIPv6,*string)
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#Image: {
	creationDate?:    null | string @go(CreationDate,*string)
	deprecationTime?: null | string @go(DeprecationTime,*string)
	description?:     null | string @go(Description,*string)
	enaSupport?:      null | bool   @go(ENASupport,*bool)
	imageID?:         null | string @go(ImageID,*string)
	imageLocation?:   null | string @go(ImageLocation,*string)
	imageOwnerAlias?: null | string @go(ImageOwnerAlias,*string)
	kernelID?:        null | string @go(KernelID,*string)
	name?:            null | string @go(Name,*string)
	ownerID?:         null | string @go(OwnerID,*string)
	platformDetails?: null | string @go(PlatformDetails,*string)
	public?:          null | bool   @go(Public,*bool)
	ramDiskID?:       null | string @go(RAMDiskID,*string)
	rootDeviceName?:  null | string @go(RootDeviceName,*string)
	sriovNetSupport?: null | string @go(SRIOVNetSupport,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	usageOperation?: null | string @go(UsageOperation,*string)
}

// +kubebuilder:skipversion
#ImageDiskContainer: {
	description?: null | string @go(Description,*string)
	deviceName?:  null | string @go(DeviceName,*string)
	format?:      null | string @go(Format,*string)
	snapshotID?:  null | string @go(SnapshotID,*string)
	url?:         null | string @go(URL,*string)
}

// +kubebuilder:skipversion
#ImageRecycleBinInfo: {
	description?: null | string @go(Description,*string)
	imageID?:     null | string @go(ImageID,*string)
	name?:        null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#ImportImageLicenseConfigurationRequest: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#ImportImageLicenseConfigurationResponse: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#ImportImageTask: {
	architecture?:  null | string @go(Architecture,*string)
	description?:   null | string @go(Description,*string)
	encrypted?:     null | bool   @go(Encrypted,*bool)
	hypervisor?:    null | string @go(Hypervisor,*string)
	imageID?:       null | string @go(ImageID,*string)
	importTaskID?:  null | string @go(ImportTaskID,*string)
	kmsKeyID?:      null | string @go(KMSKeyID,*string)
	licenseType?:   null | string @go(LicenseType,*string)
	platform?:      null | string @go(Platform,*string)
	progress?:      null | string @go(Progress,*string)
	status?:        null | string @go(Status,*string)
	statusMessage?: null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	usageOperation?: null | string @go(UsageOperation,*string)
}

// +kubebuilder:skipversion
#ImportInstanceLaunchSpecification: {
	additionalInfo?: null | string @go(AdditionalInfo,*string)
	groupIDs?: [...null | string] @go(GroupIDs,[]*string)
	groupNames?: [...null | string] @go(GroupNames,[]*string)
	instanceInitiatedShutdownBehavior?: null | string @go(InstanceInitiatedShutdownBehavior,*string)
	instanceType?:                      null | string @go(InstanceType,*string)
	monitoring?:                        null | bool   @go(Monitoring,*bool)
	privateIPAddress?:                  null | string @go(PrivateIPAddress,*string)
	subnetID?:                          null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#ImportInstanceTaskDetails: {
	description?: null | string @go(Description,*string)
	instanceID?:  null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#ImportInstanceVolumeDetailItem: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	bytesConverted?:   null | int64  @go(BytesConverted,*int64)
	description?:      null | string @go(Description,*string)
	status?:           null | string @go(Status,*string)
	statusMessage?:    null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#ImportSnapshotTask: {
	description?:  null | string @go(Description,*string)
	importTaskID?: null | string @go(ImportTaskID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ImportVolumeTaskDetails: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	bytesConverted?:   null | int64  @go(BytesConverted,*int64)
	description?:      null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#InstanceBlockDeviceMapping: {
	deviceName?: null | string @go(DeviceName,*string)
}

// +kubebuilder:skipversion
#InstanceBlockDeviceMappingSpecification: {
	deviceName?:  null | string @go(DeviceName,*string)
	noDevice?:    null | string @go(NoDevice,*string)
	virtualName?: null | string @go(VirtualName,*string)
}

// +kubebuilder:skipversion
#InstanceCapacity: {
	availableCapacity?: null | int64  @go(AvailableCapacity,*int64)
	instanceType?:      null | string @go(InstanceType,*string)
	totalCapacity?:     null | int64  @go(TotalCapacity,*int64)
}

// +kubebuilder:skipversion
#InstanceCount: {
	instanceCount?: null | int64 @go(InstanceCount,*int64)
}

// +kubebuilder:skipversion
#InstanceCreditSpecification: {
	cpuCredits?: null | string @go(CPUCredits,*string)
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#InstanceCreditSpecificationRequest: {
	cpuCredits?: null | string @go(CPUCredits,*string)
}

// +kubebuilder:skipversion
#InstanceEventWindow: {
	name?: null | string @go(Name,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#InstanceEventWindowAssociationRequest: {
	instanceTags?: [...null | #Tag] @go(InstanceTags,[]*Tag)
}

// +kubebuilder:skipversion
#InstanceEventWindowAssociationTarget: {
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#InstanceEventWindowDisassociationRequest: {
	instanceTags?: [...null | #Tag] @go(InstanceTags,[]*Tag)
}

// +kubebuilder:skipversion
#InstanceExportDetails: {
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#InstanceFamilyCreditSpecification: {
	cpuCredits?: null | string @go(CPUCredits,*string)
}

// +kubebuilder:skipversion
#InstanceIPv4Prefix: {
	ipv4Prefix?: null | string @go(IPv4Prefix,*string)
}

// +kubebuilder:skipversion
#InstanceIPv6Address: {
	ipv6Address?: null | string @go(IPv6Address,*string)
}

// +kubebuilder:skipversion
#InstanceIPv6AddressRequest: {
	ipv6Address?: null | string @go(IPv6Address,*string)
}

// +kubebuilder:skipversion
#InstanceIPv6Prefix: {
	ipv6Prefix?: null | string @go(IPv6Prefix,*string)
}

// +kubebuilder:skipversion
#InstanceMarketOptionsRequest: {
	marketType?: null | string @go(MarketType,*string)
}

// +kubebuilder:skipversion
#InstanceMetadataOptionsRequest: {
	httpPutResponseHopLimit?: null | int64 @go(HTTPPutResponseHopLimit,*int64)
}

// +kubebuilder:skipversion
#InstanceMetadataOptionsResponse: {
	httpPutResponseHopLimit?: null | int64 @go(HTTPPutResponseHopLimit,*int64)
}

// +kubebuilder:skipversion
#InstanceMonitoring: {
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#InstanceNetworkInterface: {
	description?:   null | string @go(Description,*string)
	interfaceType?: null | string @go(InterfaceType,*string)
	ipv6Addresses?: [...null | #InstanceIPv6Address] @go(IPv6Addresses,[]*InstanceIPv6Address)
	macAddress?:         null | string @go(MacAddress,*string)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	ownerID?:            null | string @go(OwnerID,*string)
	privateDNSName?:     null | string @go(PrivateDNSName,*string)
	privateIPAddress?:   null | string @go(PrivateIPAddress,*string)
	sourceDestCheck?:    null | bool   @go(SourceDestCheck,*bool)
	subnetID?:           null | string @go(SubnetID,*string)
	vpcID?:              null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#InstanceNetworkInterfaceAssociation: {
	carrierIP?:       null | string @go(CarrierIP,*string)
	customerOwnedIP?: null | string @go(CustomerOwnedIP,*string)
	ipOwnerID?:       null | string @go(IPOwnerID,*string)
	publicDNSName?:   null | string @go(PublicDNSName,*string)
	publicIP?:        null | string @go(PublicIP,*string)
}

// +kubebuilder:skipversion
#InstanceNetworkInterfaceAttachment: {
	attachmentID?:        null | string @go(AttachmentID,*string)
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	deviceIndex?:         null | int64  @go(DeviceIndex,*int64)
	networkCardIndex?:    null | int64  @go(NetworkCardIndex,*int64)
}

// +kubebuilder:skipversion
#InstanceNetworkInterfaceSpecification: {
	associateCarrierIPAddress?: null | bool   @go(AssociateCarrierIPAddress,*bool)
	associatePublicIPAddress?:  null | bool   @go(AssociatePublicIPAddress,*bool)
	deleteOnTermination?:       null | bool   @go(DeleteOnTermination,*bool)
	description?:               null | string @go(Description,*string)
	deviceIndex?:               null | int64  @go(DeviceIndex,*int64)
	groups?: [...null | string] @go(Groups,[]*string)
	interfaceType?:   null | string @go(InterfaceType,*string)
	ipv4PrefixCount?: null | int64  @go(IPv4PrefixCount,*int64)
	ipv4Prefixes?: [...null | #IPv4PrefixSpecificationRequest] @go(IPv4Prefixes,[]*IPv4PrefixSpecificationRequest)
	ipv6AddressCount?: null | int64 @go(IPv6AddressCount,*int64)
	ipv6Addresses?: [...null | #InstanceIPv6Address] @go(IPv6Addresses,[]*InstanceIPv6Address)
	ipv6PrefixCount?: null | int64 @go(IPv6PrefixCount,*int64)
	ipv6Prefixes?: [...null | #IPv6PrefixSpecificationRequest] @go(IPv6Prefixes,[]*IPv6PrefixSpecificationRequest)
	networkCardIndex?:   null | int64  @go(NetworkCardIndex,*int64)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	privateIPAddress?:   null | string @go(PrivateIPAddress,*string)
	privateIPAddresses?: [...null | #PrivateIPAddressSpecification] @go(PrivateIPAddresses,[]*PrivateIPAddressSpecification)
	secondaryPrivateIPAddressCount?: null | int64  @go(SecondaryPrivateIPAddressCount,*int64)
	subnetID?:                       null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#InstancePrivateIPAddress: {
	primary?:          null | bool   @go(Primary,*bool)
	privateDNSName?:   null | string @go(PrivateDNSName,*string)
	privateIPAddress?: null | string @go(PrivateIPAddress,*string)
}

// +kubebuilder:skipversion
#InstanceRequirements: {
	// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
	// Services Inferentia chips) on an instance.
	acceleratorCount?: null | #AcceleratorCount @go(AcceleratorCount,*AcceleratorCount)
	acceleratorManufacturers?: [...null | string] @go(AcceleratorManufacturers,[]*string)
	acceleratorNames?: [...null | string] @go(AcceleratorNames,[]*string)

	// The minimum and maximum amount of total accelerator memory, in MiB.
	acceleratorTotalMemoryMiB?: null | #AcceleratorTotalMemoryMiB @go(AcceleratorTotalMemoryMiB,*AcceleratorTotalMemoryMiB)
	acceleratorTypes?: [...null | string] @go(AcceleratorTypes,[]*string)
	allowedInstanceTypes?: [...null | string] @go(AllowedInstanceTypes,[]*string)
	bareMetal?: null | string @go(BareMetal,*string)

	// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more
	// information, see Amazon EBS–optimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html)
	// in the Amazon EC2 User Guide.
	baselineEBSBandwidthMbps?: null | #BaselineEBSBandwidthMbps @go(BaselineEBSBandwidthMbps,*BaselineEBSBandwidthMbps)
	burstablePerformance?:     null | string                    @go(BurstablePerformance,*string)
	cpuManufacturers?: [...null | string] @go(CPUManufacturers,[]*string)
	excludedInstanceTypes?: [...null | string] @go(ExcludedInstanceTypes,[]*string)
	instanceGenerations?: [...null | string] @go(InstanceGenerations,[]*string)
	localStorage?: null | string @go(LocalStorage,*string)
	localStorageTypes?: [...null | string] @go(LocalStorageTypes,[]*string)

	// The minimum and maximum amount of memory per vCPU, in GiB.
	memoryGiBPerVCPU?: null | #MemoryGiBPerVCPU @go(MemoryGiBPerVCPU,*MemoryGiBPerVCPU)

	// The minimum and maximum amount of memory, in MiB.
	memoryMiB?: null | #MemoryMiB @go(MemoryMiB,*MemoryMiB)

	// The minimum and maximum amount of network bandwidth, in gigabits per second
	// (Gbps).
	//
	// Setting the minimum bandwidth does not guarantee that your instance will
	// achieve the minimum bandwidth. Amazon EC2 will identify instance types that
	// support the specified minimum bandwidth, but the actual bandwidth of your
	// instance might go below the specified minimum at times. For more information,
	// see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth)
	// in the Amazon EC2 User Guide.
	networkBandwidthGbps?: null | #NetworkBandwidthGbps @go(NetworkBandwidthGbps,*NetworkBandwidthGbps)

	// The minimum and maximum number of network interfaces.
	networkInterfaceCount?:                     null | #NetworkInterfaceCount @go(NetworkInterfaceCount,*NetworkInterfaceCount)
	onDemandMaxPricePercentageOverLowestPrice?: null | int64                  @go(OnDemandMaxPricePercentageOverLowestPrice,*int64)
	requireHibernateSupport?:                   null | bool                   @go(RequireHibernateSupport,*bool)
	spotMaxPricePercentageOverLowestPrice?:     null | int64                  @go(SpotMaxPricePercentageOverLowestPrice,*int64)

	// The minimum and maximum amount of total local storage, in GB.
	totalLocalStorageGB?: null | #TotalLocalStorageGB @go(TotalLocalStorageGB,*TotalLocalStorageGB)

	// The minimum and maximum number of vCPUs.
	vCPUCount?: null | #VCPUCountRange @go(VCPUCount,*VCPUCountRange)
}

// +kubebuilder:skipversion
#InstanceRequirementsRequest: {
	// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
	// Services Inferentia chips) on an instance. To exclude accelerator-enabled
	// instance types, set Max to 0.
	acceleratorCount?: null | #AcceleratorCountRequest @go(AcceleratorCount,*AcceleratorCountRequest)
	acceleratorManufacturers?: [...null | string] @go(AcceleratorManufacturers,[]*string)
	acceleratorNames?: [...null | string] @go(AcceleratorNames,[]*string)

	// The minimum and maximum amount of total accelerator memory, in MiB.
	acceleratorTotalMemoryMiB?: null | #AcceleratorTotalMemoryMiBRequest @go(AcceleratorTotalMemoryMiB,*AcceleratorTotalMemoryMiBRequest)
	acceleratorTypes?: [...null | string] @go(AcceleratorTypes,[]*string)
	allowedInstanceTypes?: [...null | string] @go(AllowedInstanceTypes,[]*string)
	bareMetal?: null | string @go(BareMetal,*string)

	// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more
	// information, see Amazon EBS–optimized instances (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html)
	// in the Amazon EC2 User Guide.
	baselineEBSBandwidthMbps?: null | #BaselineEBSBandwidthMbpsRequest @go(BaselineEBSBandwidthMbps,*BaselineEBSBandwidthMbpsRequest)
	burstablePerformance?:     null | string                           @go(BurstablePerformance,*string)
	cpuManufacturers?: [...null | string] @go(CPUManufacturers,[]*string)
	excludedInstanceTypes?: [...null | string] @go(ExcludedInstanceTypes,[]*string)
	instanceGenerations?: [...null | string] @go(InstanceGenerations,[]*string)
	localStorage?: null | string @go(LocalStorage,*string)
	localStorageTypes?: [...null | string] @go(LocalStorageTypes,[]*string)

	// The minimum and maximum amount of memory per vCPU, in GiB.
	memoryGiBPerVCPU?: null | #MemoryGiBPerVCPURequest @go(MemoryGiBPerVCPU,*MemoryGiBPerVCPURequest)

	// The minimum and maximum amount of memory, in MiB.
	memoryMiB?: null | #MemoryMiBRequest @go(MemoryMiB,*MemoryMiBRequest)

	// The minimum and maximum amount of network bandwidth, in gigabits per second
	// (Gbps).
	//
	// Setting the minimum bandwidth does not guarantee that your instance will
	// achieve the minimum bandwidth. Amazon EC2 will identify instance types that
	// support the specified minimum bandwidth, but the actual bandwidth of your
	// instance might go below the specified minimum at times. For more information,
	// see Available instance bandwidth (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth)
	// in the Amazon EC2 User Guide.
	networkBandwidthGbps?: null | #NetworkBandwidthGbpsRequest @go(NetworkBandwidthGbps,*NetworkBandwidthGbpsRequest)

	// The minimum and maximum number of network interfaces.
	networkInterfaceCount?:                     null | #NetworkInterfaceCountRequest @go(NetworkInterfaceCount,*NetworkInterfaceCountRequest)
	onDemandMaxPricePercentageOverLowestPrice?: null | int64                         @go(OnDemandMaxPricePercentageOverLowestPrice,*int64)
	requireHibernateSupport?:                   null | bool                          @go(RequireHibernateSupport,*bool)
	spotMaxPricePercentageOverLowestPrice?:     null | int64                         @go(SpotMaxPricePercentageOverLowestPrice,*int64)

	// The minimum and maximum amount of total local storage, in GB.
	totalLocalStorageGB?: null | #TotalLocalStorageGBRequest @go(TotalLocalStorageGB,*TotalLocalStorageGBRequest)

	// The minimum and maximum number of vCPUs.
	vCPUCount?: null | #VCPUCountRangeRequest @go(VCPUCount,*VCPUCountRangeRequest)
}

// +kubebuilder:skipversion
#InstanceRequirementsWithMetadataRequest: {
	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirementsRequest @go(InstanceRequirements,*InstanceRequirementsRequest)
}

// +kubebuilder:skipversion
#InstanceSpecification: {
	excludeBootVolume?: null | bool @go(ExcludeBootVolume,*bool)
	excludeDataVolumeIDs?: [...null | string] @go(ExcludeDataVolumeIDs,[]*string)
}

// +kubebuilder:skipversion
#InstanceState: {
	code?: null | int64 @go(Code,*int64)
}

// +kubebuilder:skipversion
#InstanceStateChange: {
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#InstanceStatus: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	instanceID?:       null | string @go(InstanceID,*string)
	outpostARN?:       null | string @go(OutpostARN,*string)
}

// +kubebuilder:skipversion
#InstanceStatusEvent: {
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#InstanceTagNotificationAttribute: {
	includeAllTagsOfInstance?: null | bool @go(IncludeAllTagsOfInstance,*bool)
}

// +kubebuilder:skipversion
#InstanceTypeInfo: {
	instanceType?: null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#InstanceTypeInfoFromInstanceRequirements: {
	instanceType?: null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#InstanceTypeOffering: {
	instanceType?: null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#InstanceUsage: {
	accountID?:         null | string @go(AccountID,*string)
	usedInstanceCount?: null | int64  @go(UsedInstanceCount,*int64)
}

// +kubebuilder:skipversion
#InternetGateway: {
	internetGatewayID?: null | string @go(InternetGatewayID,*string)
	ownerID?:           null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#InternetGatewayAttachment: {
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#KeyPairInfo: {
	keyFingerprint?: null | string @go(KeyFingerprint,*string)
	keyName?:        null | string @go(KeyName,*string)
	keyPairID?:      null | string @go(KeyPairID,*string)
	publicKey?:      null | string @go(PublicKey,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LastError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#LaunchPermission: {
	organizationARN?:       null | string @go(OrganizationARN,*string)
	organizationalUnitARN?: null | string @go(OrganizationalUnitARN,*string)
	userID?:                null | string @go(UserID,*string)
}

// +kubebuilder:skipversion
#LaunchSpecification: {
	addressingType?: null | string @go(AddressingType,*string)
	ebsOptimized?:   null | bool   @go(EBSOptimized,*bool)
	imageID?:        null | string @go(ImageID,*string)
	instanceType?:   null | string @go(InstanceType,*string)
	kernelID?:       null | string @go(KernelID,*string)
	keyName?:        null | string @go(KeyName,*string)
	ramDiskID?:      null | string @go(RAMDiskID,*string)
	subnetID?:       null | string @go(SubnetID,*string)
	userData?:       null | string @go(UserData,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateBlockDeviceMapping: {
	deviceName?: null | string @go(DeviceName,*string)

	// Describes a block device for an EBS volume.
	ebs?:         null | #LaunchTemplateEBSBlockDevice @go(EBS,*LaunchTemplateEBSBlockDevice)
	noDevice?:    null | string                        @go(NoDevice,*string)
	virtualName?: null | string                        @go(VirtualName,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateBlockDeviceMappingRequest: {
	deviceName?: null | string @go(DeviceName,*string)

	// The parameters for a block device for an EBS volume.
	ebs?:         null | #LaunchTemplateEBSBlockDeviceRequest @go(EBS,*LaunchTemplateEBSBlockDeviceRequest)
	noDevice?:    null | string                               @go(NoDevice,*string)
	virtualName?: null | string                               @go(VirtualName,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateCPUOptions: {
	coreCount?:      null | int64 @go(CoreCount,*int64)
	threadsPerCore?: null | int64 @go(ThreadsPerCore,*int64)
}

// +kubebuilder:skipversion
#LaunchTemplateCPUOptionsRequest: {
	coreCount?:      null | int64 @go(CoreCount,*int64)
	threadsPerCore?: null | int64 @go(ThreadsPerCore,*int64)
}

// +kubebuilder:skipversion
#LaunchTemplateCapacityReservationSpecificationRequest: {
	capacityReservationPreference?: null | string @go(CapacityReservationPreference,*string)

	// Describes a target Capacity Reservation or Capacity Reservation group.
	capacityReservationTarget?: null | #CapacityReservationTarget @go(CapacityReservationTarget,*CapacityReservationTarget)
}

// +kubebuilder:skipversion
#LaunchTemplateCapacityReservationSpecificationResponse: {
	capacityReservationPreference?: null | string @go(CapacityReservationPreference,*string)

	// Describes a target Capacity Reservation or Capacity Reservation group.
	capacityReservationTarget?: null | #CapacityReservationTargetResponse @go(CapacityReservationTarget,*CapacityReservationTargetResponse)
}

// +kubebuilder:skipversion
#LaunchTemplateEBSBlockDevice: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	encrypted?:           null | bool   @go(Encrypted,*bool)
	iops?:                null | int64  @go(IOPS,*int64)
	kmsKeyID?:            null | string @go(KMSKeyID,*string)
	snapshotID?:          null | string @go(SnapshotID,*string)
	throughput?:          null | int64  @go(Throughput,*int64)
	volumeSize?:          null | int64  @go(VolumeSize,*int64)
	volumeType?:          null | string @go(VolumeType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateEBSBlockDeviceRequest: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	encrypted?:           null | bool   @go(Encrypted,*bool)
	iops?:                null | int64  @go(IOPS,*int64)
	kmsKeyID?:            null | string @go(KMSKeyID,*string)
	snapshotID?:          null | string @go(SnapshotID,*string)
	throughput?:          null | int64  @go(Throughput,*int64)
	volumeSize?:          null | int64  @go(VolumeSize,*int64)
	volumeType?:          null | string @go(VolumeType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateElasticInferenceAccelerator: {
	count?: null | int64  @go(Count,*int64)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateElasticInferenceAcceleratorResponse: {
	count?: null | int64  @go(Count,*int64)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateEnclaveOptions: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#LaunchTemplateEnclaveOptionsRequest: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#LaunchTemplateHibernationOptions: {
	configured?: null | bool @go(Configured,*bool)
}

// +kubebuilder:skipversion
#LaunchTemplateHibernationOptionsRequest: {
	configured?: null | bool @go(Configured,*bool)
}

// +kubebuilder:skipversion
#LaunchTemplateIAMInstanceProfileSpecification: {
	arn?:  null | string @go(ARN,*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateIAMInstanceProfileSpecificationRequest: {
	arn?:  null | string @go(ARN,*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMaintenanceOptions: {
	autoRecovery?: null | string @go(AutoRecovery,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMaintenanceOptionsRequest: {
	autoRecovery?: null | string @go(AutoRecovery,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMarketOptions: {
	marketType?: null | string @go(MarketType,*string)

	// The options for Spot Instances.
	spotOptions?: null | #LaunchTemplateSpotMarketOptions @go(SpotOptions,*LaunchTemplateSpotMarketOptions)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMarketOptionsRequest: {
	marketType?: null | string @go(MarketType,*string)

	// The options for Spot Instances.
	spotOptions?: null | #LaunchTemplateSpotMarketOptionsRequest @go(SpotOptions,*LaunchTemplateSpotMarketOptionsRequest)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMetadataOptions: {
	httpEndpoint?:            null | string @go(HTTPEndpoint,*string)
	httpProtocolIPv6?:        null | string @go(HTTPProtocolIPv6,*string)
	httpPutResponseHopLimit?: null | int64  @go(HTTPPutResponseHopLimit,*int64)
	httpTokens?:              null | string @go(HTTPTokens,*string)
	instanceMetadataTags?:    null | string @go(InstanceMetadataTags,*string)
	state?:                   null | string @go(State,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceMetadataOptionsRequest: {
	httpEndpoint?:            null | string @go(HTTPEndpoint,*string)
	httpProtocolIPv6?:        null | string @go(HTTPProtocolIPv6,*string)
	httpPutResponseHopLimit?: null | int64  @go(HTTPPutResponseHopLimit,*int64)
	httpTokens?:              null | string @go(HTTPTokens,*string)
	instanceMetadataTags?:    null | string @go(InstanceMetadataTags,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceNetworkInterfaceSpecification: {
	associateCarrierIPAddress?: null | bool   @go(AssociateCarrierIPAddress,*bool)
	associatePublicIPAddress?:  null | bool   @go(AssociatePublicIPAddress,*bool)
	deleteOnTermination?:       null | bool   @go(DeleteOnTermination,*bool)
	description?:               null | string @go(Description,*string)
	deviceIndex?:               null | int64  @go(DeviceIndex,*int64)
	groups?: [...null | string] @go(Groups,[]*string)
	interfaceType?:   null | string @go(InterfaceType,*string)
	ipv4PrefixCount?: null | int64  @go(IPv4PrefixCount,*int64)
	ipv4Prefixes?: [...null | #IPv4PrefixSpecificationResponse] @go(IPv4Prefixes,[]*IPv4PrefixSpecificationResponse)
	ipv6AddressCount?: null | int64 @go(IPv6AddressCount,*int64)
	ipv6Addresses?: [...null | #InstanceIPv6Address] @go(IPv6Addresses,[]*InstanceIPv6Address)
	ipv6PrefixCount?: null | int64 @go(IPv6PrefixCount,*int64)
	ipv6Prefixes?: [...null | #IPv6PrefixSpecificationResponse] @go(IPv6Prefixes,[]*IPv6PrefixSpecificationResponse)
	networkCardIndex?:   null | int64  @go(NetworkCardIndex,*int64)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	privateIPAddress?:   null | string @go(PrivateIPAddress,*string)
	privateIPAddresses?: [...null | #PrivateIPAddressSpecification] @go(PrivateIPAddresses,[]*PrivateIPAddressSpecification)
	secondaryPrivateIPAddressCount?: null | int64  @go(SecondaryPrivateIPAddressCount,*int64)
	subnetID?:                       null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateInstanceNetworkInterfaceSpecificationRequest: {
	associateCarrierIPAddress?: null | bool   @go(AssociateCarrierIPAddress,*bool)
	associatePublicIPAddress?:  null | bool   @go(AssociatePublicIPAddress,*bool)
	deleteOnTermination?:       null | bool   @go(DeleteOnTermination,*bool)
	description?:               null | string @go(Description,*string)
	deviceIndex?:               null | int64  @go(DeviceIndex,*int64)
	groups?: [...null | string] @go(Groups,[]*string)
	interfaceType?:   null | string @go(InterfaceType,*string)
	ipv4PrefixCount?: null | int64  @go(IPv4PrefixCount,*int64)
	ipv4Prefixes?: [...null | #IPv4PrefixSpecificationRequest] @go(IPv4Prefixes,[]*IPv4PrefixSpecificationRequest)
	ipv6AddressCount?: null | int64 @go(IPv6AddressCount,*int64)
	ipv6Addresses?: [...null | #InstanceIPv6AddressRequest] @go(IPv6Addresses,[]*InstanceIPv6AddressRequest)
	ipv6PrefixCount?: null | int64 @go(IPv6PrefixCount,*int64)
	ipv6Prefixes?: [...null | #IPv6PrefixSpecificationRequest] @go(IPv6Prefixes,[]*IPv6PrefixSpecificationRequest)
	networkCardIndex?:   null | int64  @go(NetworkCardIndex,*int64)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	privateIPAddress?:   null | string @go(PrivateIPAddress,*string)
	privateIPAddresses?: [...null | #PrivateIPAddressSpecification] @go(PrivateIPAddresses,[]*PrivateIPAddressSpecification)
	secondaryPrivateIPAddressCount?: null | int64  @go(SecondaryPrivateIPAddressCount,*int64)
	subnetID?:                       null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateLicenseConfiguration: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateLicenseConfigurationRequest: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateOverrides: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirements @go(InstanceRequirements,*InstanceRequirements)
	instanceType?:         null | string                @go(InstanceType,*string)
	priority?:             null | float64               @go(Priority,*float64)
	spotPrice?:            null | string                @go(SpotPrice,*string)
	subnetID?:             null | string                @go(SubnetID,*string)
	weightedCapacity?:     null | float64               @go(WeightedCapacity,*float64)
}

// +kubebuilder:skipversion
#LaunchTemplatePlacement: {
	affinity?:             null | string @go(Affinity,*string)
	availabilityZone?:     null | string @go(AvailabilityZone,*string)
	groupID?:              null | string @go(GroupID,*string)
	groupName?:            null | string @go(GroupName,*string)
	hostID?:               null | string @go(HostID,*string)
	hostResourceGroupARN?: null | string @go(HostResourceGroupARN,*string)
	partitionNumber?:      null | int64  @go(PartitionNumber,*int64)
	spreadDomain?:         null | string @go(SpreadDomain,*string)
	tenancy?:              null | string @go(Tenancy,*string)
}

// +kubebuilder:skipversion
#LaunchTemplatePlacementRequest: {
	affinity?:             null | string @go(Affinity,*string)
	availabilityZone?:     null | string @go(AvailabilityZone,*string)
	groupID?:              null | string @go(GroupID,*string)
	groupName?:            null | string @go(GroupName,*string)
	hostID?:               null | string @go(HostID,*string)
	hostResourceGroupARN?: null | string @go(HostResourceGroupARN,*string)
	partitionNumber?:      null | int64  @go(PartitionNumber,*int64)
	spreadDomain?:         null | string @go(SpreadDomain,*string)
	tenancy?:              null | string @go(Tenancy,*string)
}

// +kubebuilder:skipversion
#LaunchTemplatePrivateDNSNameOptions: {
	enableResourceNameDNSAAAARecord?: null | bool   @go(EnableResourceNameDNSAAAARecord,*bool)
	enableResourceNameDNSARecord?:    null | bool   @go(EnableResourceNameDNSARecord,*bool)
	hostnameType?:                    null | string @go(HostnameType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplatePrivateDNSNameOptionsRequest: {
	enableResourceNameDNSAAAARecord?: null | bool   @go(EnableResourceNameDNSAAAARecord,*bool)
	enableResourceNameDNSARecord?:    null | bool   @go(EnableResourceNameDNSARecord,*bool)
	hostnameType?:                    null | string @go(HostnameType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateSpecification: {
	launchTemplateID?:   null | string @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string @go(LaunchTemplateName,*string)
	version?:            null | string @go(Version,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateSpotMarketOptions: {
	blockDurationMinutes?:         null | int64  @go(BlockDurationMinutes,*int64)
	instanceInterruptionBehavior?: null | string @go(InstanceInterruptionBehavior,*string)
	maxPrice?:                     null | string @go(MaxPrice,*string)
	spotInstanceType?:             null | string @go(SpotInstanceType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateSpotMarketOptionsRequest: {
	blockDurationMinutes?:         null | int64  @go(BlockDurationMinutes,*int64)
	instanceInterruptionBehavior?: null | string @go(InstanceInterruptionBehavior,*string)
	maxPrice?:                     null | string @go(MaxPrice,*string)
	spotInstanceType?:             null | string @go(SpotInstanceType,*string)
}

// +kubebuilder:skipversion
#LaunchTemplateTagSpecification: {
	resourceType?: null | string @go(ResourceType,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LaunchTemplateTagSpecificationRequest: {
	resourceType?: null | string @go(ResourceType,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LaunchTemplateVersion_SDK: {
	createdBy?:      null | string @go(CreatedBy,*string)
	defaultVersion?: null | bool   @go(DefaultVersion,*bool)

	// The information for a launch template.
	launchTemplateData?: null | #ResponseLaunchTemplateData @go(LaunchTemplateData,*ResponseLaunchTemplateData)
	launchTemplateID?:   null | string                      @go(LaunchTemplateID,*string)
	launchTemplateName?: null | string                      @go(LaunchTemplateName,*string)
	versionDescription?: null | string                      @go(VersionDescription,*string)
	versionNumber?:      null | int64                       @go(VersionNumber,*int64)
}

// +kubebuilder:skipversion
#LaunchTemplate_SDK: {
	createdBy?:            null | string @go(CreatedBy,*string)
	defaultVersionNumber?: null | int64  @go(DefaultVersionNumber,*int64)
	latestVersionNumber?:  null | int64  @go(LatestVersionNumber,*int64)
	launchTemplateID?:     null | string @go(LaunchTemplateID,*string)
	launchTemplateName?:   null | string @go(LaunchTemplateName,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LaunchTemplatesMonitoring: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#LaunchTemplatesMonitoringRequest: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#LicenseConfiguration: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#LicenseConfigurationRequest: {
	licenseConfigurationARN?: null | string @go(LicenseConfigurationARN,*string)
}

// +kubebuilder:skipversion
#LoadPermission: {
	userID?: null | string @go(UserID,*string)
}

// +kubebuilder:skipversion
#LoadPermissionRequest: {
	userID?: null | string @go(UserID,*string)
}

// +kubebuilder:skipversion
#LocalGateway: {
	localGatewayID?: null | string @go(LocalGatewayID,*string)
	outpostARN?:     null | string @go(OutpostARN,*string)
	ownerID?:        null | string @go(OwnerID,*string)
	state?:          null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LocalGatewayRoute: {
	destinationCIDRBlock?: null | string @go(DestinationCIDRBlock,*string)
	networkInterfaceID?:   null | string @go(NetworkInterfaceID,*string)
	ownerID?:              null | string @go(OwnerID,*string)
	subnetID?:             null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#LocalGatewayRouteTable: {
	localGatewayID?:           null | string @go(LocalGatewayID,*string)
	localGatewayRouteTableID?: null | string @go(LocalGatewayRouteTableID,*string)
	outpostARN?:               null | string @go(OutpostARN,*string)
	ownerID?:                  null | string @go(OwnerID,*string)
	state?:                    null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LocalGatewayRouteTableVPCAssociation: {
	localGatewayID?:           null | string @go(LocalGatewayID,*string)
	localGatewayRouteTableID?: null | string @go(LocalGatewayRouteTableID,*string)
	ownerID?:                  null | string @go(OwnerID,*string)
	state?:                    null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#LocalGatewayRouteTableVirtualInterfaceGroupAssociation: {
	localGatewayID?:           null | string @go(LocalGatewayID,*string)
	localGatewayRouteTableID?: null | string @go(LocalGatewayRouteTableID,*string)
	ownerID?:                  null | string @go(OwnerID,*string)
	state?:                    null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#LocalGatewayVirtualInterface: {
	localAddress?:   null | string @go(LocalAddress,*string)
	localBGPASN?:    null | int64  @go(LocalBGPASN,*int64)
	localGatewayID?: null | string @go(LocalGatewayID,*string)
	ownerID?:        null | string @go(OwnerID,*string)
	peerAddress?:    null | string @go(PeerAddress,*string)
	peerBGPASN?:     null | int64  @go(PeerBGPASN,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vlan?: null | int64 @go(VLAN,*int64)
}

// +kubebuilder:skipversion
#LocalGatewayVirtualInterfaceGroup: {
	localGatewayID?: null | string @go(LocalGatewayID,*string)
	ownerID?:        null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ManagedPrefixList: {
	addressFamily?:  null | string @go(AddressFamily,*string)
	maxEntries?:     null | int64  @go(MaxEntries,*int64)
	ownerID?:        null | string @go(OwnerID,*string)
	prefixListID?:   null | string @go(PrefixListID,*string)
	prefixListName?: null | string @go(PrefixListName,*string)
	stateMessage?:   null | string @go(StateMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	version?: null | int64 @go(Version,*int64)
}

// +kubebuilder:skipversion
#MemoryGiBPerVCPU: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#MemoryGiBPerVCPURequest: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#MemoryMiB: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#MemoryMiBRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#MetricPoint: {
	status?: null | string @go(Status,*string)
}

// +kubebuilder:skipversion
#ModifyTransitGatewayOptions: {
	amazonSideASN?:                null | int64  @go(AmazonSideASN,*int64)
	autoAcceptSharedAttachments?:  null | string @go(AutoAcceptSharedAttachments,*string)
	defaultRouteTableAssociation?: null | string @go(DefaultRouteTableAssociation,*string)
	defaultRouteTablePropagation?: null | string @go(DefaultRouteTablePropagation,*string)
	dnsSupport?:                   null | string @go(DNSSupport,*string)
	vpnECMPSupport?:               null | string @go(VPNECMPSupport,*string)
}

// +kubebuilder:skipversion
#ModifyTransitGatewayVPCAttachmentRequestOptions: {
	applianceModeSupport?: null | string @go(ApplianceModeSupport,*string)
	dnsSupport?:           null | string @go(DNSSupport,*string)
	ipv6Support?:          null | string @go(IPv6Support,*string)
}

// +kubebuilder:skipversion
#ModifyVPNTunnelOptionsSpecification: {
	dpdTimeoutAction?:       null | string @go(DPDTimeoutAction,*string)
	dpdTimeoutSeconds?:      null | int64  @go(DPDTimeoutSeconds,*int64)
	phase1LifetimeSeconds?:  null | int64  @go(Phase1LifetimeSeconds,*int64)
	phase2LifetimeSeconds?:  null | int64  @go(Phase2LifetimeSeconds,*int64)
	preSharedKey?:           null | string @go(PreSharedKey,*string)
	rekeyFuzzPercentage?:    null | int64  @go(RekeyFuzzPercentage,*int64)
	rekeyMarginTimeSeconds?: null | int64  @go(RekeyMarginTimeSeconds,*int64)
	replayWindowSize?:       null | int64  @go(ReplayWindowSize,*int64)
	startupAction?:          null | string @go(StartupAction,*string)
	tunnelInsideCIDR?:       null | string @go(TunnelInsideCIDR,*string)
	tunnelInsideIPv6CIDR?:   null | string @go(TunnelInsideIPv6CIDR,*string)
}

// +kubebuilder:skipversion
#ModifyVerifiedAccessTrustProviderOIDCOptions: {
	scope?: null | string @go(Scope,*string)
}

// +kubebuilder:skipversion
#MovingAddressStatus: {
	publicIP?: null | string @go(PublicIP,*string)
}

// +kubebuilder:skipversion
#NATGateway: {
	failureCode?:    null | string @go(FailureCode,*string)
	failureMessage?: null | string @go(FailureMessage,*string)
	natGatewayID?:   null | string @go(NATGatewayID,*string)
	subnetID?:       null | string @go(SubnetID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#NATGatewayAddress: {
	allocationID?:       null | string @go(AllocationID,*string)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	privateIP?:          null | string @go(PrivateIP,*string)
	publicIP?:           null | string @go(PublicIP,*string)
}

// +kubebuilder:skipversion
#NetworkACL: {
	isDefault?:    null | bool   @go(IsDefault,*bool)
	networkACLID?: null | string @go(NetworkACLID,*string)
	ownerID?:      null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#NetworkACLAssociation: {
	networkACLAssociationID?: null | string @go(NetworkACLAssociationID,*string)
	networkACLID?:            null | string @go(NetworkACLID,*string)
	subnetID?:                null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#NetworkACLEntry: {
	cidrBlock?:     null | string @go(CIDRBlock,*string)
	egress?:        null | bool   @go(Egress,*bool)
	ipv6CIDRBlock?: null | string @go(IPv6CIDRBlock,*string)
	protocol?:      null | string @go(Protocol,*string)
	ruleNumber?:    null | int64  @go(RuleNumber,*int64)
}

// +kubebuilder:skipversion
#NetworkBandwidthGbps: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#NetworkBandwidthGbpsRequest: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#NetworkInsightsAccessScope: {
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#NetworkInsightsAccessScopeAnalysis: {
	analyzedEniCount?: null | int64  @go(AnalyzedEniCount,*int64)
	statusMessage?:    null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	warningMessage?: null | string @go(WarningMessage,*string)
}

// +kubebuilder:skipversion
#NetworkInsightsAnalysis: {
	additionalAccounts?: [...null | string] @go(AdditionalAccounts,[]*string)
	networkPathFound?: null | bool   @go(NetworkPathFound,*bool)
	statusMessage?:    null | string @go(StatusMessage,*string)
	suggestedAccounts?: [...null | string] @go(SuggestedAccounts,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	warningMessage?: null | string @go(WarningMessage,*string)
}

// +kubebuilder:skipversion
#NetworkInsightsPath: {
	destination?:     null | string @go(Destination,*string)
	destinationPort?: null | int64  @go(DestinationPort,*int64)
	source?:          null | string @go(Source,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#NetworkInterface: {
	availabilityZone?:   null | string @go(AvailabilityZone,*string)
	denyAllIgwTraffic?:  null | bool   @go(DenyAllIgwTraffic,*bool)
	description?:        null | string @go(Description,*string)
	ipv6Address?:        null | string @go(IPv6Address,*string)
	ipv6Native?:         null | bool   @go(IPv6Native,*bool)
	macAddress?:         null | string @go(MacAddress,*string)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	outpostARN?:         null | string @go(OutpostARN,*string)
	ownerID?:            null | string @go(OwnerID,*string)
	privateDNSName?:     null | string @go(PrivateDNSName,*string)
	privateIPAddress?:   null | string @go(PrivateIPAddress,*string)
	requesterID?:        null | string @go(RequesterID,*string)
	requesterManaged?:   null | bool   @go(RequesterManaged,*bool)
	sourceDestCheck?:    null | bool   @go(SourceDestCheck,*bool)
	subnetID?:           null | string @go(SubnetID,*string)
	tagSet?: [...null | #Tag] @go(TagSet,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#NetworkInterfaceAssociation: {
	allocationID?:    null | string @go(AllocationID,*string)
	associationID?:   null | string @go(AssociationID,*string)
	carrierIP?:       null | string @go(CarrierIP,*string)
	customerOwnedIP?: null | string @go(CustomerOwnedIP,*string)
	ipOwnerID?:       null | string @go(IPOwnerID,*string)
	publicDNSName?:   null | string @go(PublicDNSName,*string)
	publicIP?:        null | string @go(PublicIP,*string)
}

// +kubebuilder:skipversion
#NetworkInterfaceAttachment: {
	attachmentID?:        null | string @go(AttachmentID,*string)
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	deviceIndex?:         null | int64  @go(DeviceIndex,*int64)
	instanceID?:          null | string @go(InstanceID,*string)
	instanceOwnerID?:     null | string @go(InstanceOwnerID,*string)
	networkCardIndex?:    null | int64  @go(NetworkCardIndex,*int64)
}

// +kubebuilder:skipversion
#NetworkInterfaceAttachmentChanges: {
	deleteOnTermination?: null | bool @go(DeleteOnTermination,*bool)
}

// +kubebuilder:skipversion
#NetworkInterfaceCount: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#NetworkInterfaceCountRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#NetworkInterfaceIPv6Address: {
	ipv6Address?: null | string @go(IPv6Address,*string)
}

// +kubebuilder:skipversion
#NetworkInterfacePermission: {
	awsAccountID?:                 null | string @go(AWSAccountID,*string)
	awsService?:                   null | string @go(AWSService,*string)
	networkInterfaceID?:           null | string @go(NetworkInterfaceID,*string)
	networkInterfacePermissionID?: null | string @go(NetworkInterfacePermissionID,*string)
}

// +kubebuilder:skipversion
#NetworkInterfacePermissionState: {
	statusMessage?: null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#NetworkInterfacePrivateIPAddress: {
	primary?:          null | bool   @go(Primary,*bool)
	privateDNSName?:   null | string @go(PrivateDNSName,*string)
	privateIPAddress?: null | string @go(PrivateIPAddress,*string)
}

// +kubebuilder:skipversion
#NewDHCPConfiguration: {
	key?: null | string @go(Key,*string)
	values?: [...null | string] @go(Values,[]*string)
}

// +kubebuilder:skipversion
#OIDCOptions: {
	authorizationEndpoint?: null | string @go(AuthorizationEndpoint,*string)
	clientID?:              null | string @go(ClientID,*string)
	clientSecret?:          null | string @go(ClientSecret,*string)
	issuer?:                null | string @go(Issuer,*string)
	scope?:                 null | string @go(Scope,*string)
	tokenEndpoint?:         null | string @go(TokenEndpoint,*string)
	userInfoEndpoint?:      null | string @go(UserInfoEndpoint,*string)
}

// +kubebuilder:skipversion
#OnDemandOptions: {
	maxTotalPrice?:          null | string @go(MaxTotalPrice,*string)
	minTargetCapacity?:      null | int64  @go(MinTargetCapacity,*int64)
	singleAvailabilityZone?: null | bool   @go(SingleAvailabilityZone,*bool)
	singleInstanceType?:     null | bool   @go(SingleInstanceType,*bool)
}

// +kubebuilder:skipversion
#OnDemandOptionsRequest: {
	maxTotalPrice?:          null | string @go(MaxTotalPrice,*string)
	minTargetCapacity?:      null | int64  @go(MinTargetCapacity,*int64)
	singleAvailabilityZone?: null | bool   @go(SingleAvailabilityZone,*bool)
	singleInstanceType?:     null | bool   @go(SingleInstanceType,*bool)
}

// +kubebuilder:skipversion
#PacketHeaderStatement: {
	destinationAddresses?: [...null | string] @go(DestinationAddresses,[]*string)
	destinationPorts?: [...null | string] @go(DestinationPorts,[]*string)
	destinationPrefixLists?: [...null | string] @go(DestinationPrefixLists,[]*string)
	sourceAddresses?: [...null | string] @go(SourceAddresses,[]*string)
	sourcePorts?: [...null | string] @go(SourcePorts,[]*string)
	sourcePrefixLists?: [...null | string] @go(SourcePrefixLists,[]*string)
}

// +kubebuilder:skipversion
#PacketHeaderStatementRequest: {
	destinationAddresses?: [...null | string] @go(DestinationAddresses,[]*string)
	destinationPorts?: [...null | string] @go(DestinationPorts,[]*string)
	destinationPrefixLists?: [...null | string] @go(DestinationPrefixLists,[]*string)
	sourceAddresses?: [...null | string] @go(SourceAddresses,[]*string)
	sourcePorts?: [...null | string] @go(SourcePorts,[]*string)
	sourcePrefixLists?: [...null | string] @go(SourcePrefixLists,[]*string)
}

// +kubebuilder:skipversion
#PathComponent: {
	sequenceNumber?: null | int64 @go(SequenceNumber,*int64)
}

// +kubebuilder:skipversion
#PciID: {
	deviceID?:          null | string @go(DeviceID,*string)
	subsystemID?:       null | string @go(SubsystemID,*string)
	subsystemVendorID?: null | string @go(SubsystemVendorID,*string)
	vendorID?:          null | string @go(VendorID,*string)
}

// +kubebuilder:skipversion
#PeeringAttachmentStatus: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#PeeringConnectionOptions: {
	allowDNSResolutionFromRemoteVPC?:            null | bool @go(AllowDNSResolutionFromRemoteVPC,*bool)
	allowEgressFromLocalClassicLinkToRemoteVPC?: null | bool @go(AllowEgressFromLocalClassicLinkToRemoteVPC,*bool)
	allowEgressFromLocalVPCToRemoteClassicLink?: null | bool @go(AllowEgressFromLocalVPCToRemoteClassicLink,*bool)
}

// +kubebuilder:skipversion
#PeeringConnectionOptionsRequest: {
	allowDNSResolutionFromRemoteVPC?:            null | bool @go(AllowDNSResolutionFromRemoteVPC,*bool)
	allowEgressFromLocalClassicLinkToRemoteVPC?: null | bool @go(AllowEgressFromLocalClassicLinkToRemoteVPC,*bool)
	allowEgressFromLocalVPCToRemoteClassicLink?: null | bool @go(AllowEgressFromLocalVPCToRemoteClassicLink,*bool)
}

// +kubebuilder:skipversion
#PeeringTgwInfo: {
	coreNetworkID?:    null | string @go(CoreNetworkID,*string)
	ownerID?:          null | string @go(OwnerID,*string)
	region?:           null | string @go(Region,*string)
	transitGatewayID?: null | string @go(TransitGatewayID,*string)
}

// +kubebuilder:skipversion
#Phase1DHGroupNumbersListValue: {
	value?: null | int64 @go(Value,*int64)
}

// +kubebuilder:skipversion
#Phase1DHGroupNumbersRequestListValue: {
	value?: null | int64 @go(Value,*int64)
}

// +kubebuilder:skipversion
#Phase1EncryptionAlgorithmsListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase1EncryptionAlgorithmsRequestListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase1IntegrityAlgorithmsListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase1IntegrityAlgorithmsRequestListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase2DHGroupNumbersListValue: {
	value?: null | int64 @go(Value,*int64)
}

// +kubebuilder:skipversion
#Phase2DHGroupNumbersRequestListValue: {
	value?: null | int64 @go(Value,*int64)
}

// +kubebuilder:skipversion
#Phase2EncryptionAlgorithmsListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase2EncryptionAlgorithmsRequestListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase2IntegrityAlgorithmsListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Phase2IntegrityAlgorithmsRequestListValue: {
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#Placement: {
	affinity?:             null | string @go(Affinity,*string)
	availabilityZone?:     null | string @go(AvailabilityZone,*string)
	groupID?:              null | string @go(GroupID,*string)
	groupName?:            null | string @go(GroupName,*string)
	hostID?:               null | string @go(HostID,*string)
	hostResourceGroupARN?: null | string @go(HostResourceGroupARN,*string)
	partitionNumber?:      null | int64  @go(PartitionNumber,*int64)
	spreadDomain?:         null | string @go(SpreadDomain,*string)
	tenancy?:              null | string @go(Tenancy,*string)
}

// +kubebuilder:skipversion
#PlacementGroup: {
	groupARN?:       null | string @go(GroupARN,*string)
	groupID?:        null | string @go(GroupID,*string)
	groupName?:      null | string @go(GroupName,*string)
	partitionCount?: null | int64  @go(PartitionCount,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#PlacementResponse: {
	groupName?: null | string @go(GroupName,*string)
}

// +kubebuilder:skipversion
#PoolCIDRBlock: {
	cidr?: null | string @go(CIDR,*string)
}

// +kubebuilder:skipversion
#PortRange: {
	from?: null | int64 @go(From,*int64)
	to?:   null | int64 @go(To,*int64)
}

// +kubebuilder:skipversion
#PrefixList: {
	cidrs?: [...null | string] @go(CIDRs,[]*string)
	prefixListID?:   null | string @go(PrefixListID,*string)
	prefixListName?: null | string @go(PrefixListName,*string)
}

// +kubebuilder:skipversion
#PrefixListAssociation: {
	resourceID?:    null | string @go(ResourceID,*string)
	resourceOwner?: null | string @go(ResourceOwner,*string)
}

// +kubebuilder:skipversion
#PrefixListEntry: {
	cidr?:        null | string @go(CIDR,*string)
	description?: null | string @go(Description,*string)
}

// +kubebuilder:skipversion
#PrefixListID: {
	description?:  null | string @go(Description,*string)
	prefixListID?: null | string @go(PrefixListID,*string)
}

// +kubebuilder:skipversion
#PriceSchedule: {
	active?: null | bool    @go(Active,*bool)
	price?:  null | float64 @go(Price,*float64)
	term?:   null | int64   @go(Term,*int64)
}

// +kubebuilder:skipversion
#PriceScheduleSpecification: {
	price?: null | float64 @go(Price,*float64)
	term?:  null | int64   @go(Term,*int64)
}

// +kubebuilder:skipversion
#PricingDetail: {
	count?: null | int64   @go(Count,*int64)
	price?: null | float64 @go(Price,*float64)
}

// +kubebuilder:skipversion
#PrincipalIDFormat: {
	arn?: null | string @go(ARN,*string)
}

// +kubebuilder:skipversion
#PrivateDNSDetails: {
	privateDNSName?: null | string @go(PrivateDNSName,*string)
}

// +kubebuilder:skipversion
#PrivateDNSNameConfiguration: {
	name?:  null | string @go(Name,*string)
	state?: null | string @go(State,*string)
	type_?: null | string @go(Type,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#PrivateDNSNameOptionsOnLaunch: {
	enableResourceNameDNSAAAARecord?: null | bool   @go(EnableResourceNameDNSAAAARecord,*bool)
	enableResourceNameDNSARecord?:    null | bool   @go(EnableResourceNameDNSARecord,*bool)
	hostnameType?:                    null | string @go(HostnameType,*string)
}

// +kubebuilder:skipversion
#PrivateDNSNameOptionsRequest: {
	enableResourceNameDNSAAAARecord?: null | bool   @go(EnableResourceNameDNSAAAARecord,*bool)
	enableResourceNameDNSARecord?:    null | bool   @go(EnableResourceNameDNSARecord,*bool)
	hostnameType?:                    null | string @go(HostnameType,*string)
}

// +kubebuilder:skipversion
#PrivateDNSNameOptionsResponse: {
	enableResourceNameDNSAAAARecord?: null | bool   @go(EnableResourceNameDNSAAAARecord,*bool)
	enableResourceNameDNSARecord?:    null | bool   @go(EnableResourceNameDNSARecord,*bool)
	hostnameType?:                    null | string @go(HostnameType,*string)
}

// +kubebuilder:skipversion
#PrivateIPAddressSpecification: {
	primary?:          null | bool   @go(Primary,*bool)
	privateIPAddress?: null | string @go(PrivateIPAddress,*string)
}

// +kubebuilder:skipversion
#ProductCode: {
	productCodeID?: null | string @go(ProductCodeID,*string)
}

// +kubebuilder:skipversion
#PropagatingVGW: {
	gatewayID?: null | string @go(GatewayID,*string)
}

// +kubebuilder:skipversion
#ProvisionedBandwidth: {
	provisioned?: null | string @go(Provisioned,*string)
	requested?:   null | string @go(Requested,*string)
	status?:      null | string @go(Status,*string)
}

// +kubebuilder:skipversion
#PtrUpdateStatus: {
	reason?: null | string @go(Reason,*string)
	status?: null | string @go(Status,*string)
	value?:  null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#PublicIPv4Pool: {
	description?:        null | string @go(Description,*string)
	networkBorderGroup?: null | string @go(NetworkBorderGroup,*string)
	poolID?:             null | string @go(PoolID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	totalAddressCount?:          null | int64 @go(TotalAddressCount,*int64)
	totalAvailableAddressCount?: null | int64 @go(TotalAvailableAddressCount,*int64)
}

// +kubebuilder:skipversion
#PublicIPv4PoolRange: {
	addressCount?:          null | int64  @go(AddressCount,*int64)
	availableAddressCount?: null | int64  @go(AvailableAddressCount,*int64)
	firstAddress?:          null | string @go(FirstAddress,*string)
	lastAddress?:           null | string @go(LastAddress,*string)
}

// +kubebuilder:skipversion
#Purchase: {
	duration?:       null | int64  @go(Duration,*int64)
	hourlyPrice?:    null | string @go(HourlyPrice,*string)
	instanceFamily?: null | string @go(InstanceFamily,*string)
	upfrontPrice?:   null | string @go(UpfrontPrice,*string)
}

// +kubebuilder:skipversion
#PurchaseRequest: {
	instanceCount?: null | int64  @go(InstanceCount,*int64)
	purchaseToken?: null | string @go(PurchaseToken,*string)
}

// +kubebuilder:skipversion
#RecurringCharge: {
	amount?: null | float64 @go(Amount,*float64)
}

// +kubebuilder:skipversion
#ReferencedSecurityGroup: {
	groupID?:                null | string @go(GroupID,*string)
	peeringStatus?:          null | string @go(PeeringStatus,*string)
	userID?:                 null | string @go(UserID,*string)
	vpcID?:                  null | string @go(VPCID,*string)
	vpcPeeringConnectionID?: null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#Region: {
	endpoint?:    null | string @go(Endpoint,*string)
	optInStatus?: null | string @go(OptInStatus,*string)
	regionName?:  null | string @go(RegionName,*string)
}

// +kubebuilder:skipversion
#RegisterInstanceTagAttributeRequest: {
	includeAllTagsOfInstance?: null | bool @go(IncludeAllTagsOfInstance,*bool)
}

// +kubebuilder:skipversion
#RemoveIPAMOperatingRegion: {
	regionName?: null | string @go(RegionName,*string)
}

// +kubebuilder:skipversion
#RemovePrefixListEntry: {
	cidr?: null | string @go(CIDR,*string)
}

// +kubebuilder:skipversion
#ReplaceRootVolumeTask: {
	completeTime?:             null | string @go(CompleteTime,*string)
	deleteReplacedRootVolume?: null | bool   @go(DeleteReplacedRootVolume,*bool)
	imageID?:                  null | string @go(ImageID,*string)
	instanceID?:               null | string @go(InstanceID,*string)
	snapshotID?:               null | string @go(SnapshotID,*string)
	startTime?:                null | string @go(StartTime,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#RequestIPAMResourceTag: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#RequestLaunchTemplateData: {
	blockDeviceMappings?: [...null | #LaunchTemplateBlockDeviceMappingRequest] @go(BlockDeviceMappings,[]*LaunchTemplateBlockDeviceMappingRequest)

	// Describes an instance's Capacity Reservation targeting option. You can specify
	// only one option at a time. Use the CapacityReservationPreference parameter
	// to configure the instance to run in On-Demand capacity or to run in any open
	// Capacity Reservation that has matching attributes (instance type, platform,
	// Availability Zone). Use the CapacityReservationTarget parameter to explicitly
	// target a specific Capacity Reservation or a Capacity Reservation group.
	capacityReservationSpecification?: null | #LaunchTemplateCapacityReservationSpecificationRequest @go(CapacityReservationSpecification,*LaunchTemplateCapacityReservationSpecificationRequest)

	// The CPU options for the instance. Both the core count and threads per core
	// must be specified in the request.
	cpuOptions?: null | #LaunchTemplateCPUOptionsRequest @go(CPUOptions,*LaunchTemplateCPUOptionsRequest)

	// The credit option for CPU usage of a T instance.
	creditSpecification?:   null | #CreditSpecificationRequest @go(CreditSpecification,*CreditSpecificationRequest)
	disableAPIStop?:        null | bool                        @go(DisableAPIStop,*bool)
	disableAPITermination?: null | bool                        @go(DisableAPITermination,*bool)
	ebsOptimized?:          null | bool                        @go(EBSOptimized,*bool)
	elasticGPUSpecifications?: [...null | #ElasticGPUSpecification] @go(ElasticGPUSpecifications,[]*ElasticGPUSpecification)
	elasticInferenceAccelerators?: [...null | #LaunchTemplateElasticInferenceAccelerator] @go(ElasticInferenceAccelerators,[]*LaunchTemplateElasticInferenceAccelerator)

	// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
	// For more information, see What is Amazon Web Services Nitro Enclaves? (https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html)
	// in the Amazon Web Services Nitro Enclaves User Guide.
	enclaveOptions?: null | #LaunchTemplateEnclaveOptionsRequest @go(EnclaveOptions,*LaunchTemplateEnclaveOptionsRequest)

	// Indicates whether the instance is configured for hibernation. This parameter
	// is valid only if the instance meets the hibernation prerequisites (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html).
	hibernationOptions?: null | #LaunchTemplateHibernationOptionsRequest @go(HibernationOptions,*LaunchTemplateHibernationOptionsRequest)

	// An IAM instance profile.
	iamInstanceProfile?:                null | #LaunchTemplateIAMInstanceProfileSpecificationRequest @go(IAMInstanceProfile,*LaunchTemplateIAMInstanceProfileSpecificationRequest)
	imageID?:                           null | string                                                @go(ImageID,*string)
	instanceInitiatedShutdownBehavior?: null | string                                                @go(InstanceInitiatedShutdownBehavior,*string)

	// The market (purchasing) option for the instances.
	instanceMarketOptions?: null | #LaunchTemplateInstanceMarketOptionsRequest @go(InstanceMarketOptions,*LaunchTemplateInstanceMarketOptionsRequest)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirementsRequest @go(InstanceRequirements,*InstanceRequirementsRequest)
	instanceType?:         null | string                       @go(InstanceType,*string)
	kernelID?:             null | string                       @go(KernelID,*string)
	keyName?:              null | string                       @go(KeyName,*string)
	licenseSpecifications?: [...null | #LaunchTemplateLicenseConfigurationRequest] @go(LicenseSpecifications,[]*LaunchTemplateLicenseConfigurationRequest)

	// The maintenance options of your instance.
	maintenanceOptions?: null | #LaunchTemplateInstanceMaintenanceOptionsRequest @go(MaintenanceOptions,*LaunchTemplateInstanceMaintenanceOptionsRequest)

	// The metadata options for the instance. For more information, see Instance
	// metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
	// in the Amazon Elastic Compute Cloud User Guide.
	metadataOptions?: null | #LaunchTemplateInstanceMetadataOptionsRequest @go(MetadataOptions,*LaunchTemplateInstanceMetadataOptionsRequest)

	// Describes the monitoring for the instance.
	monitoring?: null | #LaunchTemplatesMonitoringRequest @go(Monitoring,*LaunchTemplatesMonitoringRequest)
	networkInterfaces?: [...null | #LaunchTemplateInstanceNetworkInterfaceSpecificationRequest] @go(NetworkInterfaces,[]*LaunchTemplateInstanceNetworkInterfaceSpecificationRequest)

	// Describes the placement of an instance.
	placement?: null | #LaunchTemplatePlacementRequest @go(Placement,*LaunchTemplatePlacementRequest)

	// Describes the options for instance hostnames.
	privateDNSNameOptions?: null | #LaunchTemplatePrivateDNSNameOptionsRequest @go(PrivateDNSNameOptions,*LaunchTemplatePrivateDNSNameOptionsRequest)
	ramDiskID?:             null | string                                      @go(RAMDiskID,*string)
	securityGroupIDs?: [...null | string] @go(SecurityGroupIDs,[]*string)
	securityGroups?: [...null | string] @go(SecurityGroups,[]*string)
	tagSpecifications?: [...null | #LaunchTemplateTagSpecificationRequest] @go(TagSpecifications,[]*LaunchTemplateTagSpecificationRequest)
	userData?: null | string @go(UserData,*string)
}

// +kubebuilder:skipversion
#RequestSpotLaunchSpecification: {
	addressingType?: null | string @go(AddressingType,*string)
	ebsOptimized?:   null | bool   @go(EBSOptimized,*bool)
	imageID?:        null | string @go(ImageID,*string)
	instanceType?:   null | string @go(InstanceType,*string)
	kernelID?:       null | string @go(KernelID,*string)
	keyName?:        null | string @go(KeyName,*string)
	ramDiskID?:      null | string @go(RAMDiskID,*string)
	subnetID?:       null | string @go(SubnetID,*string)
	userData?:       null | string @go(UserData,*string)
}

// +kubebuilder:skipversion
#ReservationFleetInstanceSpecification: {
	availabilityZone?:   null | string @go(AvailabilityZone,*string)
	availabilityZoneID?: null | string @go(AvailabilityZoneID,*string)
	ebsOptimized?:       null | bool   @go(EBSOptimized,*bool)
	instanceType?:       null | string @go(InstanceType,*string)
}

// +kubebuilder:skipversion
#ReservationValue: {
	hourlyPrice?:           null | string @go(HourlyPrice,*string)
	remainingTotalValue?:   null | string @go(RemainingTotalValue,*string)
	remainingUpfrontValue?: null | string @go(RemainingUpfrontValue,*string)
}

// +kubebuilder:skipversion
#ReservedInstanceLimitPrice: {
	amount?: null | float64 @go(Amount,*float64)
}

// +kubebuilder:skipversion
#ReservedInstanceReservationValue: {
	reservedInstanceID?: null | string @go(ReservedInstanceID,*string)
}

// +kubebuilder:skipversion
#ReservedInstances: {
	availabilityZone?:    null | string @go(AvailabilityZone,*string)
	duration?:            null | int64  @go(Duration,*int64)
	instanceCount?:       null | int64  @go(InstanceCount,*int64)
	instanceTenancy?:     null | string @go(InstanceTenancy,*string)
	instanceType?:        null | string @go(InstanceType,*string)
	reservedInstancesID?: null | string @go(ReservedInstancesID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ReservedInstancesConfiguration: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	instanceCount?:    null | int64  @go(InstanceCount,*int64)
	instanceType?:     null | string @go(InstanceType,*string)
	platform?:         null | string @go(Platform,*string)
}

// +kubebuilder:skipversion
#ReservedInstancesID: {
	reservedInstancesID?: null | string @go(ReservedInstancesID,*string)
}

// +kubebuilder:skipversion
#ReservedInstancesListing: {
	clientToken?:                null | string @go(ClientToken,*string)
	reservedInstancesID?:        null | string @go(ReservedInstancesID,*string)
	reservedInstancesListingID?: null | string @go(ReservedInstancesListingID,*string)
	statusMessage?:              null | string @go(StatusMessage,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ReservedInstancesModification: {
	clientToken?:                     null | string @go(ClientToken,*string)
	reservedInstancesModificationID?: null | string @go(ReservedInstancesModificationID,*string)
	status?:                          null | string @go(Status,*string)
	statusMessage?:                   null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#ReservedInstancesModificationResult: {
	reservedInstancesID?: null | string @go(ReservedInstancesID,*string)
}

// +kubebuilder:skipversion
#ReservedInstancesOffering: {
	availabilityZone?:            null | string @go(AvailabilityZone,*string)
	duration?:                    null | int64  @go(Duration,*int64)
	instanceTenancy?:             null | string @go(InstanceTenancy,*string)
	instanceType?:                null | string @go(InstanceType,*string)
	marketplace?:                 null | bool   @go(Marketplace,*bool)
	reservedInstancesOfferingID?: null | string @go(ReservedInstancesOfferingID,*string)
}

// +kubebuilder:skipversion
#ResourceStatement: {
	resourceTypes?: [...null | string] @go(ResourceTypes,[]*string)
	resources?: [...null | string] @go(Resources,[]*string)
}

// +kubebuilder:skipversion
#ResourceStatementRequest: {
	resourceTypes?: [...null | string] @go(ResourceTypes,[]*string)
	resources?: [...null | string] @go(Resources,[]*string)
}

// +kubebuilder:skipversion
#ResponseError: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ResponseLaunchTemplateData: {
	blockDeviceMappings?: [...null | #LaunchTemplateBlockDeviceMapping] @go(BlockDeviceMappings,[]*LaunchTemplateBlockDeviceMapping)

	// Information about the Capacity Reservation targeting option.
	capacityReservationSpecification?: null | #LaunchTemplateCapacityReservationSpecificationResponse @go(CapacityReservationSpecification,*LaunchTemplateCapacityReservationSpecificationResponse)

	// The CPU options for the instance.
	cpuOptions?: null | #LaunchTemplateCPUOptions @go(CPUOptions,*LaunchTemplateCPUOptions)

	// Describes the credit option for CPU usage of a T instance.
	creditSpecification?:   null | #CreditSpecification @go(CreditSpecification,*CreditSpecification)
	disableAPIStop?:        null | bool                 @go(DisableAPIStop,*bool)
	disableAPITermination?: null | bool                 @go(DisableAPITermination,*bool)
	ebsOptimized?:          null | bool                 @go(EBSOptimized,*bool)
	elasticGPUSpecifications?: [...null | #ElasticGPUSpecificationResponse] @go(ElasticGPUSpecifications,[]*ElasticGPUSpecificationResponse)
	elasticInferenceAccelerators?: [...null | #LaunchTemplateElasticInferenceAcceleratorResponse] @go(ElasticInferenceAccelerators,[]*LaunchTemplateElasticInferenceAcceleratorResponse)

	// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
	enclaveOptions?: null | #LaunchTemplateEnclaveOptions @go(EnclaveOptions,*LaunchTemplateEnclaveOptions)

	// Indicates whether an instance is configured for hibernation.
	hibernationOptions?: null | #LaunchTemplateHibernationOptions @go(HibernationOptions,*LaunchTemplateHibernationOptions)

	// Describes an IAM instance profile.
	iamInstanceProfile?:                null | #LaunchTemplateIAMInstanceProfileSpecification @go(IAMInstanceProfile,*LaunchTemplateIAMInstanceProfileSpecification)
	imageID?:                           null | string                                         @go(ImageID,*string)
	instanceInitiatedShutdownBehavior?: null | string                                         @go(InstanceInitiatedShutdownBehavior,*string)

	// The market (purchasing) option for the instances.
	instanceMarketOptions?: null | #LaunchTemplateInstanceMarketOptions @go(InstanceMarketOptions,*LaunchTemplateInstanceMarketOptions)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirements @go(InstanceRequirements,*InstanceRequirements)
	instanceType?:         null | string                @go(InstanceType,*string)
	kernelID?:             null | string                @go(KernelID,*string)
	keyName?:              null | string                @go(KeyName,*string)
	licenseSpecifications?: [...null | #LaunchTemplateLicenseConfiguration] @go(LicenseSpecifications,[]*LaunchTemplateLicenseConfiguration)

	// The maintenance options of your instance.
	maintenanceOptions?: null | #LaunchTemplateInstanceMaintenanceOptions @go(MaintenanceOptions,*LaunchTemplateInstanceMaintenanceOptions)

	// The metadata options for the instance. For more information, see Instance
	// metadata and user data (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)
	// in the Amazon Elastic Compute Cloud User Guide.
	metadataOptions?: null | #LaunchTemplateInstanceMetadataOptions @go(MetadataOptions,*LaunchTemplateInstanceMetadataOptions)

	// Describes the monitoring for the instance.
	monitoring?: null | #LaunchTemplatesMonitoring @go(Monitoring,*LaunchTemplatesMonitoring)
	networkInterfaces?: [...null | #LaunchTemplateInstanceNetworkInterfaceSpecification] @go(NetworkInterfaces,[]*LaunchTemplateInstanceNetworkInterfaceSpecification)

	// Describes the placement of an instance.
	placement?: null | #LaunchTemplatePlacement @go(Placement,*LaunchTemplatePlacement)

	// Describes the options for instance hostnames.
	privateDNSNameOptions?: null | #LaunchTemplatePrivateDNSNameOptions @go(PrivateDNSNameOptions,*LaunchTemplatePrivateDNSNameOptions)
	ramDiskID?:             null | string                               @go(RAMDiskID,*string)
	securityGroupIDs?: [...null | string] @go(SecurityGroupIDs,[]*string)
	securityGroups?: [...null | string] @go(SecurityGroups,[]*string)
	tagSpecifications?: [...null | #LaunchTemplateTagSpecification] @go(TagSpecifications,[]*LaunchTemplateTagSpecification)
	userData?: null | string @go(UserData,*string)
}

// +kubebuilder:skipversion
#RouteTable: {
	ownerID?:      null | string @go(OwnerID,*string)
	routeTableID?: null | string @go(RouteTableID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#RouteTableAssociation: {
	gatewayID?:               null | string @go(GatewayID,*string)
	main?:                    null | bool   @go(Main,*bool)
	routeTableAssociationID?: null | string @go(RouteTableAssociationID,*string)
	routeTableID?:            null | string @go(RouteTableID,*string)
	subnetID?:                null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#RouteTableAssociationState: {
	statusMessage?: null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#Route_SDK: {
	carrierGatewayID?:            null | string @go(CarrierGatewayID,*string)
	coreNetworkARN?:              null | string @go(CoreNetworkARN,*string)
	destinationCIDRBlock?:        null | string @go(DestinationCIDRBlock,*string)
	destinationIPv6CIDRBlock?:    null | string @go(DestinationIPv6CIDRBlock,*string)
	destinationPrefixListID?:     null | string @go(DestinationPrefixListID,*string)
	egressOnlyInternetGatewayID?: null | string @go(EgressOnlyInternetGatewayID,*string)
	gatewayID?:                   null | string @go(GatewayID,*string)
	instanceID?:                  null | string @go(InstanceID,*string)
	instanceOwnerID?:             null | string @go(InstanceOwnerID,*string)
	localGatewayID?:              null | string @go(LocalGatewayID,*string)
	natGatewayID?:                null | string @go(NATGatewayID,*string)
	networkInterfaceID?:          null | string @go(NetworkInterfaceID,*string)
	transitGatewayID?:            null | string @go(TransitGatewayID,*string)
	vpcPeeringConnectionID?:      null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#RunInstancesMonitoringEnabled: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#S3ObjectTag: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#S3Storage: {
	awsAccessKeyID?:        null | string @go(AWSAccessKeyID,*string)
	bucket?:                null | string @go(Bucket,*string)
	prefix?:                null | string @go(Prefix,*string)
	uploadPolicySignature?: null | string @go(UploadPolicySignature,*string)
}

// +kubebuilder:skipversion
#ScheduledInstance: {
	availabilityZone?:            null | string @go(AvailabilityZone,*string)
	hourlyPrice?:                 null | string @go(HourlyPrice,*string)
	instanceCount?:               null | int64  @go(InstanceCount,*int64)
	instanceType?:                null | string @go(InstanceType,*string)
	networkPlatform?:             null | string @go(NetworkPlatform,*string)
	platform?:                    null | string @go(Platform,*string)
	scheduledInstanceID?:         null | string @go(ScheduledInstanceID,*string)
	slotDurationInHours?:         null | int64  @go(SlotDurationInHours,*int64)
	totalScheduledInstanceHours?: null | int64  @go(TotalScheduledInstanceHours,*int64)
}

// +kubebuilder:skipversion
#ScheduledInstanceAvailability: {
	availabilityZone?:            null | string @go(AvailabilityZone,*string)
	availableInstanceCount?:      null | int64  @go(AvailableInstanceCount,*int64)
	hourlyPrice?:                 null | string @go(HourlyPrice,*string)
	instanceType?:                null | string @go(InstanceType,*string)
	maxTermDurationInDays?:       null | int64  @go(MaxTermDurationInDays,*int64)
	minTermDurationInDays?:       null | int64  @go(MinTermDurationInDays,*int64)
	networkPlatform?:             null | string @go(NetworkPlatform,*string)
	platform?:                    null | string @go(Platform,*string)
	purchaseToken?:               null | string @go(PurchaseToken,*string)
	slotDurationInHours?:         null | int64  @go(SlotDurationInHours,*int64)
	totalScheduledInstanceHours?: null | int64  @go(TotalScheduledInstanceHours,*int64)
}

// +kubebuilder:skipversion
#ScheduledInstanceRecurrence: {
	frequency?:               null | string @go(Frequency,*string)
	interval?:                null | int64  @go(Interval,*int64)
	occurrenceRelativeToEnd?: null | bool   @go(OccurrenceRelativeToEnd,*bool)
	occurrenceUnit?:          null | string @go(OccurrenceUnit,*string)
}

// +kubebuilder:skipversion
#ScheduledInstanceRecurrenceRequest: {
	frequency?:               null | string @go(Frequency,*string)
	interval?:                null | int64  @go(Interval,*int64)
	occurrenceRelativeToEnd?: null | bool   @go(OccurrenceRelativeToEnd,*bool)
	occurrenceUnit?:          null | string @go(OccurrenceUnit,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesBlockDeviceMapping: {
	deviceName?:  null | string @go(DeviceName,*string)
	noDevice?:    null | string @go(NoDevice,*string)
	virtualName?: null | string @go(VirtualName,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesEBS: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	encrypted?:           null | bool   @go(Encrypted,*bool)
	iops?:                null | int64  @go(IOPS,*int64)
	snapshotID?:          null | string @go(SnapshotID,*string)
	volumeSize?:          null | int64  @go(VolumeSize,*int64)
	volumeType?:          null | string @go(VolumeType,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesIAMInstanceProfile: {
	arn?:  null | string @go(ARN,*string)
	name?: null | string @go(Name,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesLaunchSpecification: {
	ebsOptimized?: null | bool   @go(EBSOptimized,*bool)
	imageID?:      null | string @go(ImageID,*string)
	instanceType?: null | string @go(InstanceType,*string)
	kernelID?:     null | string @go(KernelID,*string)
	keyName?:      null | string @go(KeyName,*string)
	ramDiskID?:    null | string @go(RAMDiskID,*string)
	subnetID?:     null | string @go(SubnetID,*string)
	userData?:     null | string @go(UserData,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesMonitoring: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#ScheduledInstancesNetworkInterface: {
	associatePublicIPAddress?:       null | bool   @go(AssociatePublicIPAddress,*bool)
	deleteOnTermination?:            null | bool   @go(DeleteOnTermination,*bool)
	description?:                    null | string @go(Description,*string)
	deviceIndex?:                    null | int64  @go(DeviceIndex,*int64)
	ipv6AddressCount?:               null | int64  @go(IPv6AddressCount,*int64)
	networkInterfaceID?:             null | string @go(NetworkInterfaceID,*string)
	privateIPAddress?:               null | string @go(PrivateIPAddress,*string)
	secondaryPrivateIPAddressCount?: null | int64  @go(SecondaryPrivateIPAddressCount,*int64)
	subnetID?:                       null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesPlacement: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	groupName?:        null | string @go(GroupName,*string)
}

// +kubebuilder:skipversion
#ScheduledInstancesPrivateIPAddressConfig: {
	primary?:          null | bool   @go(Primary,*bool)
	privateIPAddress?: null | string @go(PrivateIPAddress,*string)
}

// +kubebuilder:skipversion
#SecurityGroup: {
	description?: null | string @go(Description,*string)
	groupID?:     null | string @go(GroupID,*string)
	groupName?:   null | string @go(GroupName,*string)
	ownerID?:     null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#SecurityGroupIdentifier: {
	groupID?:   null | string @go(GroupID,*string)
	groupName?: null | string @go(GroupName,*string)
}

// +kubebuilder:skipversion
#SecurityGroupReference: {
	groupID?:                null | string @go(GroupID,*string)
	referencingVPCID?:       null | string @go(ReferencingVPCID,*string)
	vpcPeeringConnectionID?: null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#SecurityGroupRuleDescription: {
	description?:         null | string @go(Description,*string)
	securityGroupRuleID?: null | string @go(SecurityGroupRuleID,*string)
}

// +kubebuilder:skipversion
#SecurityGroupRuleRequest: {
	cidrIPv4?:          null | string @go(CIDRIPv4,*string)
	cidrIPv6?:          null | string @go(CIDRIPv6,*string)
	description?:       null | string @go(Description,*string)
	fromPort?:          null | int64  @go(FromPort,*int64)
	ipProtocol?:        null | string @go(IPProtocol,*string)
	prefixListID?:      null | string @go(PrefixListID,*string)
	referencedGroupID?: null | string @go(ReferencedGroupID,*string)
	toPort?:            null | int64  @go(ToPort,*int64)
}

// +kubebuilder:skipversion
#ServiceConfiguration: {
	acceptanceRequired?: null | bool @go(AcceptanceRequired,*bool)
	availabilityZones?: [...null | string] @go(AvailabilityZones,[]*string)
	baseEndpointDNSNames?: [...null | string] @go(BaseEndpointDNSNames,[]*string)
	gatewayLoadBalancerARNs?: [...null | string] @go(GatewayLoadBalancerARNs,[]*string)
	managesVPCEndpoints?: null | bool @go(ManagesVPCEndpoints,*bool)
	networkLoadBalancerARNs?: [...null | string] @go(NetworkLoadBalancerARNs,[]*string)
	payerResponsibility?: null | string @go(PayerResponsibility,*string)
	privateDNSName?:      null | string @go(PrivateDNSName,*string)

	// Information about the private DNS name for the service endpoint.
	privateDNSNameConfiguration?: null | #PrivateDNSNameConfiguration @go(PrivateDNSNameConfiguration,*PrivateDNSNameConfiguration)
	serviceID?:                   null | string                       @go(ServiceID,*string)
	serviceName?:                 null | string                       @go(ServiceName,*string)
	serviceState?:                null | string                       @go(ServiceState,*string)
	serviceType?: [...null | #ServiceTypeDetail] @go(ServiceType,[]*ServiceTypeDetail)
	supportedIPAddressTypes?: [...null | string] @go(SupportedIPAddressTypes,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#ServiceDetail: {
	acceptanceRequired?: null | bool @go(AcceptanceRequired,*bool)
	availabilityZones?: [...null | string] @go(AvailabilityZones,[]*string)
	baseEndpointDNSNames?: [...null | string] @go(BaseEndpointDNSNames,[]*string)
	managesVPCEndpoints?:             null | bool   @go(ManagesVPCEndpoints,*bool)
	owner?:                           null | string @go(Owner,*string)
	payerResponsibility?:             null | string @go(PayerResponsibility,*string)
	privateDNSName?:                  null | string @go(PrivateDNSName,*string)
	privateDNSNameVerificationState?: null | string @go(PrivateDNSNameVerificationState,*string)
	serviceID?:                       null | string @go(ServiceID,*string)
	serviceName?:                     null | string @go(ServiceName,*string)
	serviceType?: [...null | #ServiceTypeDetail] @go(ServiceType,[]*ServiceTypeDetail)
	supportedIPAddressTypes?: [...null | string] @go(SupportedIPAddressTypes,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcEndpointPolicySupported?: null | bool @go(VPCEndpointPolicySupported,*bool)
}

// +kubebuilder:skipversion
#ServiceTypeDetail: {
	serviceType?: null | string @go(ServiceType,*string)
}

// +kubebuilder:skipversion
#SnapshotDetail: {
	description?:   null | string  @go(Description,*string)
	deviceName?:    null | string  @go(DeviceName,*string)
	diskImageSize?: null | float64 @go(DiskImageSize,*float64)
	format?:        null | string  @go(Format,*string)
	progress?:      null | string  @go(Progress,*string)
	snapshotID?:    null | string  @go(SnapshotID,*string)
	status?:        null | string  @go(Status,*string)
	statusMessage?: null | string  @go(StatusMessage,*string)
	url?:           null | string  @go(URL,*string)
}

// +kubebuilder:skipversion
#SnapshotDiskContainer: {
	description?: null | string @go(Description,*string)
	format?:      null | string @go(Format,*string)
	url?:         null | string @go(URL,*string)
}

// +kubebuilder:skipversion
#SnapshotInfo: {
	description?: null | string @go(Description,*string)
	encrypted?:   null | bool   @go(Encrypted,*bool)
	outpostARN?:  null | string @go(OutpostARN,*string)
	ownerID?:     null | string @go(OwnerID,*string)
	progress?:    null | string @go(Progress,*string)
	snapshotID?:  null | string @go(SnapshotID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	volumeID?:   null | string @go(VolumeID,*string)
	volumeSize?: null | int64  @go(VolumeSize,*int64)
}

// +kubebuilder:skipversion
#SnapshotRecycleBinInfo: {
	description?: null | string @go(Description,*string)
	snapshotID?:  null | string @go(SnapshotID,*string)
	volumeID?:    null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#SnapshotTaskDetail: {
	description?:   null | string  @go(Description,*string)
	diskImageSize?: null | float64 @go(DiskImageSize,*float64)
	encrypted?:     null | bool    @go(Encrypted,*bool)
	format?:        null | string  @go(Format,*string)
	kmsKeyID?:      null | string  @go(KMSKeyID,*string)
	progress?:      null | string  @go(Progress,*string)
	snapshotID?:    null | string  @go(SnapshotID,*string)
	status?:        null | string  @go(Status,*string)
	statusMessage?: null | string  @go(StatusMessage,*string)
	url?:           null | string  @go(URL,*string)
}

// +kubebuilder:skipversion
#SnapshotTierStatus: {
	lastTieringOperationStatusDetail?: null | string @go(LastTieringOperationStatusDetail,*string)
	lastTieringProgress?:              null | int64  @go(LastTieringProgress,*int64)
	ownerID?:                          null | string @go(OwnerID,*string)
	snapshotID?:                       null | string @go(SnapshotID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	volumeID?: null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#SpotCapacityRebalance: {
	terminationDelay?: null | int64 @go(TerminationDelay,*int64)
}

// +kubebuilder:skipversion
#SpotDatafeedSubscription: {
	bucket?:  null | string @go(Bucket,*string)
	ownerID?: null | string @go(OwnerID,*string)
	prefix?:  null | string @go(Prefix,*string)
}

// +kubebuilder:skipversion
#SpotFleetLaunchSpecification: {
	addressingType?: null | string @go(AddressingType,*string)
	ebsOptimized?:   null | bool   @go(EBSOptimized,*bool)
	imageID?:        null | string @go(ImageID,*string)

	// The attributes for the instance types. When you specify instance attributes,
	// Amazon EC2 will identify instance types with these attributes.
	//
	// When you specify multiple attributes, you get instance types that satisfy
	// all of the specified attributes. If you specify multiple values for an attribute,
	// you get instance types that satisfy any of the specified values.
	//
	// To limit the list of instance types from which Amazon EC2 can identify matching
	// instance types, you can use one of the following parameters, but not both
	// in the same request:
	//
	//    * AllowedInstanceTypes - The instance types to include in the list. All
	//    other instance types are ignored, even if they match your specified attributes.
	//
	//    * ExcludedInstanceTypes - The instance types to exclude from the list,
	//    even if they match your specified attributes.
	//
	// You must specify VCpuCount and MemoryMiB. All other attributes are optional.
	// Any unspecified optional attribute is set to its default.
	//
	// For more information, see Attribute-based instance type selection for EC2
	// Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html),
	// Attribute-based instance type selection for Spot Fleet (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html),
	// and Spot placement score (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html)
	// in the Amazon EC2 User Guide.
	instanceRequirements?: null | #InstanceRequirements @go(InstanceRequirements,*InstanceRequirements)
	instanceType?:         null | string                @go(InstanceType,*string)
	kernelID?:             null | string                @go(KernelID,*string)
	keyName?:              null | string                @go(KeyName,*string)
	ramDiskID?:            null | string                @go(RAMDiskID,*string)
	spotPrice?:            null | string                @go(SpotPrice,*string)
	subnetID?:             null | string                @go(SubnetID,*string)
	userData?:             null | string                @go(UserData,*string)
	weightedCapacity?:     null | float64               @go(WeightedCapacity,*float64)
}

// +kubebuilder:skipversion
#SpotFleetMonitoring: {
	enabled?: null | bool @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#SpotFleetRequestConfig: {
	spotFleetRequestID?: null | string @go(SpotFleetRequestID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#SpotFleetRequestConfigData: {
	clientToken?:                  null | string  @go(ClientToken,*string)
	context?:                      null | string  @go(Context,*string)
	fulfilledCapacity?:            null | float64 @go(FulfilledCapacity,*float64)
	iamFleetRole?:                 null | string  @go(IAMFleetRole,*string)
	instanceInterruptionBehavior?: null | string  @go(InstanceInterruptionBehavior,*string)
	instancePoolsToUseCount?:      null | int64   @go(InstancePoolsToUseCount,*int64)
	onDemandFulfilledCapacity?:    null | float64 @go(OnDemandFulfilledCapacity,*float64)
	onDemandMaxTotalPrice?:        null | string  @go(OnDemandMaxTotalPrice,*string)
	onDemandTargetCapacity?:       null | int64   @go(OnDemandTargetCapacity,*int64)
	replaceUnhealthyInstances?:    null | bool    @go(ReplaceUnhealthyInstances,*bool)
	spotMaxTotalPrice?:            null | string  @go(SpotMaxTotalPrice,*string)
	spotPrice?:                    null | string  @go(SpotPrice,*string)
	tagSpecifications?: [...null | #TagSpecification] @go(TagSpecifications,[]*TagSpecification)
	targetCapacity?:                   null | int64 @go(TargetCapacity,*int64)
	terminateInstancesWithExpiration?: null | bool  @go(TerminateInstancesWithExpiration,*bool)
}

// +kubebuilder:skipversion
#SpotFleetTagSpecification: {
	resourceType?: null | string @go(ResourceType,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#SpotInstanceRequest: {
	actualBlockHourlyPrice?:       null | string @go(ActualBlockHourlyPrice,*string)
	availabilityZoneGroup?:        null | string @go(AvailabilityZoneGroup,*string)
	blockDurationMinutes?:         null | int64  @go(BlockDurationMinutes,*int64)
	instanceInterruptionBehavior?: null | string @go(InstanceInterruptionBehavior,*string)
	launchGroup?:                  null | string @go(LaunchGroup,*string)
	launchedAvailabilityZone?:     null | string @go(LaunchedAvailabilityZone,*string)
	spotInstanceRequestID?:        null | string @go(SpotInstanceRequestID,*string)
	spotPrice?:                    null | string @go(SpotPrice,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	type_?: null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#SpotInstanceStateFault: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#SpotInstanceStatus: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#SpotMarketOptions: {
	blockDurationMinutes?:         null | int64  @go(BlockDurationMinutes,*int64)
	instanceInterruptionBehavior?: null | string @go(InstanceInterruptionBehavior,*string)
	maxPrice?:                     null | string @go(MaxPrice,*string)
	spotInstanceType?:             null | string @go(SpotInstanceType,*string)
}

// +kubebuilder:skipversion
#SpotOptions: {
	instancePoolsToUseCount?: null | int64  @go(InstancePoolsToUseCount,*int64)
	maxTotalPrice?:           null | string @go(MaxTotalPrice,*string)
	minTargetCapacity?:       null | int64  @go(MinTargetCapacity,*int64)
	singleAvailabilityZone?:  null | bool   @go(SingleAvailabilityZone,*bool)
	singleInstanceType?:      null | bool   @go(SingleInstanceType,*bool)
}

// +kubebuilder:skipversion
#SpotOptionsRequest: {
	instancePoolsToUseCount?: null | int64  @go(InstancePoolsToUseCount,*int64)
	maxTotalPrice?:           null | string @go(MaxTotalPrice,*string)
	minTargetCapacity?:       null | int64  @go(MinTargetCapacity,*int64)
	singleAvailabilityZone?:  null | bool   @go(SingleAvailabilityZone,*bool)
	singleInstanceType?:      null | bool   @go(SingleInstanceType,*bool)
}

// +kubebuilder:skipversion
#SpotPlacement: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	groupName?:        null | string @go(GroupName,*string)
	tenancy?:          null | string @go(Tenancy,*string)
}

// +kubebuilder:skipversion
#SpotPlacementScore: {
	availabilityZoneID?: null | string @go(AvailabilityZoneID,*string)
	region?:             null | string @go(Region,*string)
	score?:              null | int64  @go(Score,*int64)
}

// +kubebuilder:skipversion
#SpotPrice: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	instanceType?:     null | string @go(InstanceType,*string)
	spotPrice?:        null | string @go(SpotPrice,*string)
}

// +kubebuilder:skipversion
#StaleIPPermission: {
	fromPort?:   null | int64  @go(FromPort,*int64)
	ipProtocol?: null | string @go(IPProtocol,*string)
	toPort?:     null | int64  @go(ToPort,*int64)
}

// +kubebuilder:skipversion
#StaleSecurityGroup: {
	description?: null | string @go(Description,*string)
	groupID?:     null | string @go(GroupID,*string)
	groupName?:   null | string @go(GroupName,*string)
	vpcID?:       null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#StateReason: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#StorageLocation: {
	bucket?: null | string @go(Bucket,*string)
	key?:    null | string @go(Key,*string)
}

// +kubebuilder:skipversion
#StoreImageTaskResult: {
	amiID?:                  null | string @go(AMIID,*string)
	bucket?:                 null | string @go(Bucket,*string)
	progressPercentage?:     null | int64  @go(ProgressPercentage,*int64)
	s3ObjectKey?:            null | string @go(S3ObjectKey,*string)
	storeTaskFailureReason?: null | string @go(StoreTaskFailureReason,*string)
	storeTaskState?:         null | string @go(StoreTaskState,*string)
}

// +kubebuilder:skipversion
#Subnet: {
	assignIPv6AddressOnCreation?: null | bool   @go(AssignIPv6AddressOnCreation,*bool)
	availabilityZone?:            null | string @go(AvailabilityZone,*string)
	availabilityZoneID?:          null | string @go(AvailabilityZoneID,*string)
	cidrBlock?:                   null | string @go(CIDRBlock,*string)
	defaultForAZ?:                null | bool   @go(DefaultForAZ,*bool)
	enableDNS64?:                 null | bool   @go(EnableDNS64,*bool)
	enableLniAtDeviceIndex?:      null | int64  @go(EnableLniAtDeviceIndex,*int64)
	ipv6Native?:                  null | bool   @go(IPv6Native,*bool)
	mapCustomerOwnedIPOnLaunch?:  null | bool   @go(MapCustomerOwnedIPOnLaunch,*bool)
	mapPublicIPOnLaunch?:         null | bool   @go(MapPublicIPOnLaunch,*bool)
	outpostARN?:                  null | string @go(OutpostARN,*string)
	ownerID?:                     null | string @go(OwnerID,*string)
	subnetARN?:                   null | string @go(SubnetARN,*string)
	subnetID?:                    null | string @go(SubnetID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#SubnetAssociation: {
	subnetID?: null | string @go(SubnetID,*string)
}

// +kubebuilder:skipversion
#SubnetCIDRBlockState: {
	statusMessage?: null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#SubnetCIDRReservation: {
	cidr?:        null | string @go(CIDR,*string)
	description?: null | string @go(Description,*string)
	ownerID?:     null | string @go(OwnerID,*string)
	subnetID?:    null | string @go(SubnetID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#SubnetIPv6CIDRBlockAssociation: {
	ipv6CIDRBlock?: null | string @go(IPv6CIDRBlock,*string)
}

// +kubebuilder:skipversion
#Subscription: {
	destination?: null | string @go(Destination,*string)
	source?:      null | string @go(Source,*string)
}

// +kubebuilder:skipversion
#SuccessfulInstanceCreditSpecificationItem: {
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#SuccessfulQueuedPurchaseDeletion: {
	reservedInstancesID?: null | string @go(ReservedInstancesID,*string)
}

// +kubebuilder:skipversion
#Tag: {
	key?:   null | string @go(Key,*string)
	value?: null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#TagDescription: {
	key?:          null | string @go(Key,*string)
	resourceID?:   null | string @go(ResourceID,*string)
	resourceType?: null | string @go(ResourceType,*string)
	value?:        null | string @go(Value,*string)
}

// +kubebuilder:skipversion
#TagSpecification: {
	resourceType?: null | string @go(ResourceType,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
}

// +kubebuilder:skipversion
#TargetCapacitySpecification: {
	onDemandTargetCapacity?: null | int64 @go(OnDemandTargetCapacity,*int64)
	spotTargetCapacity?:     null | int64 @go(SpotTargetCapacity,*int64)
	totalTargetCapacity?:    null | int64 @go(TotalTargetCapacity,*int64)
}

// +kubebuilder:skipversion
#TargetCapacitySpecificationRequest: {
	onDemandTargetCapacity?: null | int64 @go(OnDemandTargetCapacity,*int64)
	spotTargetCapacity?:     null | int64 @go(SpotTargetCapacity,*int64)
	totalTargetCapacity?:    null | int64 @go(TotalTargetCapacity,*int64)
}

// +kubebuilder:skipversion
#TargetConfiguration: {
	instanceCount?: null | int64  @go(InstanceCount,*int64)
	offeringID?:    null | string @go(OfferingID,*string)
}

// +kubebuilder:skipversion
#TargetConfigurationRequest: {
	instanceCount?: null | int64 @go(InstanceCount,*int64)
}

// +kubebuilder:skipversion
#TargetGroup: {
	arn?: null | string @go(ARN,*string)
}

// +kubebuilder:skipversion
#TargetNetwork: {
	associationID?:       null | string @go(AssociationID,*string)
	clientVPNEndpointID?: null | string @go(ClientVPNEndpointID,*string)
	securityGroups?: [...null | string] @go(SecurityGroups,[]*string)
	targetNetworkID?: null | string @go(TargetNetworkID,*string)
	vpcID?:           null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#TerminateConnectionStatus: {
	connectionID?: null | string @go(ConnectionID,*string)
}

// +kubebuilder:skipversion
#TotalLocalStorageGB: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#TotalLocalStorageGBRequest: {
	max?: null | float64 @go(Max,*float64)
	min?: null | float64 @go(Min,*float64)
}

// +kubebuilder:skipversion
#TrafficMirrorFilter: {
	description?: null | string @go(Description,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	trafficMirrorFilterID?: null | string @go(TrafficMirrorFilterID,*string)
}

// +kubebuilder:skipversion
#TrafficMirrorFilterRule: {
	description?:               null | string @go(Description,*string)
	destinationCIDRBlock?:      null | string @go(DestinationCIDRBlock,*string)
	protocol?:                  null | int64  @go(Protocol,*int64)
	ruleNumber?:                null | int64  @go(RuleNumber,*int64)
	sourceCIDRBlock?:           null | string @go(SourceCIDRBlock,*string)
	trafficMirrorFilterID?:     null | string @go(TrafficMirrorFilterID,*string)
	trafficMirrorFilterRuleID?: null | string @go(TrafficMirrorFilterRuleID,*string)
}

// +kubebuilder:skipversion
#TrafficMirrorPortRange: {
	fromPort?: null | int64 @go(FromPort,*int64)
	toPort?:   null | int64 @go(ToPort,*int64)
}

// +kubebuilder:skipversion
#TrafficMirrorPortRangeRequest: {
	fromPort?: null | int64 @go(FromPort,*int64)
	toPort?:   null | int64 @go(ToPort,*int64)
}

// +kubebuilder:skipversion
#TrafficMirrorSession: {
	description?:        null | string @go(Description,*string)
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
	ownerID?:            null | string @go(OwnerID,*string)
	packetLength?:       null | int64  @go(PacketLength,*int64)
	sessionNumber?:      null | int64  @go(SessionNumber,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	trafficMirrorFilterID?:  null | string @go(TrafficMirrorFilterID,*string)
	trafficMirrorSessionID?: null | string @go(TrafficMirrorSessionID,*string)
	trafficMirrorTargetID?:  null | string @go(TrafficMirrorTargetID,*string)
	virtualNetworkID?:       null | int64  @go(VirtualNetworkID,*int64)
}

// +kubebuilder:skipversion
#TrafficMirrorTarget: {
	description?:                   null | string @go(Description,*string)
	gatewayLoadBalancerEndpointID?: null | string @go(GatewayLoadBalancerEndpointID,*string)
	networkInterfaceID?:            null | string @go(NetworkInterfaceID,*string)
	networkLoadBalancerARN?:        null | string @go(NetworkLoadBalancerARN,*string)
	ownerID?:                       null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	trafficMirrorTargetID?: null | string @go(TrafficMirrorTargetID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayAssociation: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayRouteTableID?: null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayAttachment: {
	resourceID?:      null | string @go(ResourceID,*string)
	resourceOwnerID?: null | string @go(ResourceOwnerID,*string)
	resourceType?:    null | string @go(ResourceType,*string)
	state?:           null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayID?:           null | string @go(TransitGatewayID,*string)
	transitGatewayOwnerID?:      null | string @go(TransitGatewayOwnerID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayAttachmentAssociation: {
	transitGatewayRouteTableID?: null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayAttachmentBGPConfiguration: {
	peerAddress?:           null | string @go(PeerAddress,*string)
	peerASN?:               null | int64  @go(PeerASN,*int64)
	transitGatewayAddress?: null | string @go(TransitGatewayAddress,*string)
	transitGatewayASN?:     null | int64  @go(TransitGatewayASN,*int64)
}

// +kubebuilder:skipversion
#TransitGatewayAttachmentPropagation: {
	transitGatewayRouteTableID?: null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayConnect: {
	state?: null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayAttachmentID?:          null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayID?:                    null | string @go(TransitGatewayID,*string)
	transportTransitGatewayAttachmentID?: null | string @go(TransportTransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayConnectPeer: {
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayConnectPeerConfiguration: {
	peerAddress?:           null | string @go(PeerAddress,*string)
	transitGatewayAddress?: null | string @go(TransitGatewayAddress,*string)
}

// +kubebuilder:skipversion
#TransitGatewayConnectRequestBGPOptions: {
	peerASN?: null | int64 @go(PeerASN,*int64)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastDeregisteredGroupMembers: {
	deregisteredNetworkInterfaceIDs?: [...null | string] @go(DeregisteredNetworkInterfaceIDs,[]*string)
	groupIPAddress?:                  null | string @go(GroupIPAddress,*string)
	transitGatewayMulticastDomainID?: null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastDeregisteredGroupSources: {
	deregisteredNetworkInterfaceIDs?: [...null | string] @go(DeregisteredNetworkInterfaceIDs,[]*string)
	groupIPAddress?:                  null | string @go(GroupIPAddress,*string)
	transitGatewayMulticastDomainID?: null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastDomain: {
	ownerID?: null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayID?:                 null | string @go(TransitGatewayID,*string)
	transitGatewayMulticastDomainARN?: null | string @go(TransitGatewayMulticastDomainARN,*string)
	transitGatewayMulticastDomainID?:  null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastDomainAssociation: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceOwnerID?:            null | string @go(ResourceOwnerID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastDomainAssociations: {
	resourceID?:                      null | string @go(ResourceID,*string)
	resourceOwnerID?:                 null | string @go(ResourceOwnerID,*string)
	resourceType?:                    null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?:      null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayMulticastDomainID?: null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastGroup: {
	groupIPAddress?:             null | string @go(GroupIPAddress,*string)
	groupMember?:                null | bool   @go(GroupMember,*bool)
	groupSource?:                null | bool   @go(GroupSource,*bool)
	networkInterfaceID?:         null | string @go(NetworkInterfaceID,*string)
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceOwnerID?:            null | string @go(ResourceOwnerID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	subnetID?:                   null | string @go(SubnetID,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastRegisteredGroupMembers: {
	groupIPAddress?: null | string @go(GroupIPAddress,*string)
	registeredNetworkInterfaceIDs?: [...null | string] @go(RegisteredNetworkInterfaceIDs,[]*string)
	transitGatewayMulticastDomainID?: null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayMulticastRegisteredGroupSources: {
	groupIPAddress?: null | string @go(GroupIPAddress,*string)
	registeredNetworkInterfaceIDs?: [...null | string] @go(RegisteredNetworkInterfaceIDs,[]*string)
	transitGatewayMulticastDomainID?: null | string @go(TransitGatewayMulticastDomainID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayOptions: {
	amazonSideASN?:                  null | int64  @go(AmazonSideASN,*int64)
	associationDefaultRouteTableID?: null | string @go(AssociationDefaultRouteTableID,*string)
	autoAcceptSharedAttachments?:    null | string @go(AutoAcceptSharedAttachments,*string)
	defaultRouteTableAssociation?:   null | string @go(DefaultRouteTableAssociation,*string)
	defaultRouteTablePropagation?:   null | string @go(DefaultRouteTablePropagation,*string)
	dnsSupport?:                     null | string @go(DNSSupport,*string)
	multicastSupport?:               null | string @go(MulticastSupport,*string)
	propagationDefaultRouteTableID?: null | string @go(PropagationDefaultRouteTableID,*string)
	transitGatewayCIDRBlocks?: [...null | string] @go(TransitGatewayCIDRBlocks,[]*string)
	vpnECMPSupport?: null | string @go(VPNECMPSupport,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPeeringAttachment: {
	accepterTransitGatewayAttachmentID?: null | string @go(AccepterTransitGatewayAttachmentID,*string)
	state?:                              null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPolicyRule: {
	destinationCIDRBlock?: null | string @go(DestinationCIDRBlock,*string)
	destinationPortRange?: null | string @go(DestinationPortRange,*string)
	protocol?:             null | string @go(Protocol,*string)
	sourceCIDRBlock?:      null | string @go(SourceCIDRBlock,*string)
	sourcePortRange?:      null | string @go(SourcePortRange,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPolicyRuleMetaData: {
	metaDataKey?:   null | string @go(MetaDataKey,*string)
	metaDataValue?: null | string @go(MetaDataValue,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPolicyTable: {
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayID?: null | string @go(TransitGatewayID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPolicyTableAssociation: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPolicyTableEntry: {
	policyRuleNumber?:   null | string @go(PolicyRuleNumber,*string)
	targetRouteTableID?: null | string @go(TargetRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPrefixListAttachment: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPrefixListReference: {
	blackhole?:                  null | bool   @go(Blackhole,*bool)
	prefixListID?:               null | string @go(PrefixListID,*string)
	prefixListOwnerID?:          null | string @go(PrefixListOwnerID,*string)
	transitGatewayRouteTableID?: null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayPropagation: {
	resourceID?:                             null | string @go(ResourceID,*string)
	resourceType?:                           null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?:             null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayRouteTableAnnouncementID?: null | string @go(TransitGatewayRouteTableAnnouncementID,*string)
	transitGatewayRouteTableID?:             null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRequestOptions: {
	amazonSideASN?:                null | int64  @go(AmazonSideASN,*int64)
	autoAcceptSharedAttachments?:  null | string @go(AutoAcceptSharedAttachments,*string)
	defaultRouteTableAssociation?: null | string @go(DefaultRouteTableAssociation,*string)
	defaultRouteTablePropagation?: null | string @go(DefaultRouteTablePropagation,*string)
	dnsSupport?:                   null | string @go(DNSSupport,*string)
	multicastSupport?:             null | string @go(MulticastSupport,*string)
	transitGatewayCIDRBlocks?: [...null | string] @go(TransitGatewayCIDRBlocks,[]*string)
	vpnECMPSupport?: null | string @go(VPNECMPSupport,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteAttachment: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteTableAnnouncement: {
	coreNetworkID?:        null | string @go(CoreNetworkID,*string)
	peerCoreNetworkID?:    null | string @go(PeerCoreNetworkID,*string)
	peerTransitGatewayID?: null | string @go(PeerTransitGatewayID,*string)
	peeringAttachmentID?:  null | string @go(PeeringAttachmentID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayID?:                       null | string @go(TransitGatewayID,*string)
	transitGatewayRouteTableAnnouncementID?: null | string @go(TransitGatewayRouteTableAnnouncementID,*string)
	transitGatewayRouteTableID?:             null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteTableAssociation: {
	resourceID?:                 null | string @go(ResourceID,*string)
	resourceType?:               null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteTablePropagation: {
	resourceID?:                             null | string @go(ResourceID,*string)
	resourceType?:                           null | string @go(ResourceType,*string)
	transitGatewayAttachmentID?:             null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayRouteTableAnnouncementID?: null | string @go(TransitGatewayRouteTableAnnouncementID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteTableRoute: {
	attachmentID?:    null | string @go(AttachmentID,*string)
	destinationCIDR?: null | string @go(DestinationCIDR,*string)
	prefixListID?:    null | string @go(PrefixListID,*string)
	resourceID?:      null | string @go(ResourceID,*string)
	resourceType?:    null | string @go(ResourceType,*string)
	routeOrigin?:     null | string @go(RouteOrigin,*string)
	state?:           null | string @go(State,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRouteTable_SDK: {
	defaultAssociationRouteTable?: null | bool   @go(DefaultAssociationRouteTable,*bool)
	defaultPropagationRouteTable?: null | bool   @go(DefaultPropagationRouteTable,*bool)
	state?:                        null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayID?:           null | string @go(TransitGatewayID,*string)
	transitGatewayRouteTableID?: null | string @go(TransitGatewayRouteTableID,*string)
}

// +kubebuilder:skipversion
#TransitGatewayRoute_SDK: {
	destinationCIDRBlock?: null | string @go(DestinationCIDRBlock,*string)
	prefixListID?:         null | string @go(PrefixListID,*string)
	state?:                null | string @go(State,*string)
	transitGatewayAttachments?: [...null | #TransitGatewayRouteAttachment] @go(TransitGatewayAttachments,[]*TransitGatewayRouteAttachment)
	transitGatewayRouteTableAnnouncementID?: null | string @go(TransitGatewayRouteTableAnnouncementID,*string)
	type_?:                                  null | string @go(Type,*string)
}

// +kubebuilder:skipversion
#TransitGatewayVPCAttachmentOptions: {
	applianceModeSupport?: null | string @go(ApplianceModeSupport,*string)
	dnsSupport?:           null | string @go(DNSSupport,*string)
	ipv6Support?:          null | string @go(IPv6Support,*string)
}

// +kubebuilder:skipversion
#TransitGatewayVPCAttachment_SDK: {
	// Describes the VPC attachment options.
	options?: null | #TransitGatewayVPCAttachmentOptions @go(Options,*TransitGatewayVPCAttachmentOptions)
	state?:   null | string                              @go(State,*string)
	subnetIDs?: [...null | string] @go(SubnetIDs,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayAttachmentID?: null | string @go(TransitGatewayAttachmentID,*string)
	transitGatewayID?:           null | string @go(TransitGatewayID,*string)
	vpcID?:                      null | string @go(VPCID,*string)
	vpcOwnerID?:                 null | string @go(VPCOwnerID,*string)
}

// +kubebuilder:skipversion
#TransitGateway_SDK: {
	description?: null | string @go(Description,*string)

	// Describes the options for a transit gateway.
	options?: null | #TransitGatewayOptions @go(Options,*TransitGatewayOptions)
	ownerID?: null | string                 @go(OwnerID,*string)
	state?:   null | string                 @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayARN?: null | string @go(TransitGatewayARN,*string)
	transitGatewayID?:  null | string @go(TransitGatewayID,*string)
}

// +kubebuilder:skipversion
#TrunkInterfaceAssociation: {
	branchInterfaceID?: null | string @go(BranchInterfaceID,*string)
	greKey?:            null | int64  @go(GreKey,*int64)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	trunkInterfaceID?: null | string @go(TrunkInterfaceID,*string)
	vlanID?:           null | int64  @go(VLANID,*int64)
}

// +kubebuilder:skipversion
#TunnelOption: {
	dpdTimeoutAction?:       null | string @go(DPDTimeoutAction,*string)
	dpdTimeoutSeconds?:      null | int64  @go(DPDTimeoutSeconds,*int64)
	outsideIPAddress?:       null | string @go(OutsideIPAddress,*string)
	phase1LifetimeSeconds?:  null | int64  @go(Phase1LifetimeSeconds,*int64)
	phase2LifetimeSeconds?:  null | int64  @go(Phase2LifetimeSeconds,*int64)
	preSharedKey?:           null | string @go(PreSharedKey,*string)
	rekeyFuzzPercentage?:    null | int64  @go(RekeyFuzzPercentage,*int64)
	rekeyMarginTimeSeconds?: null | int64  @go(RekeyMarginTimeSeconds,*int64)
	replayWindowSize?:       null | int64  @go(ReplayWindowSize,*int64)
	startupAction?:          null | string @go(StartupAction,*string)
	tunnelInsideCIDR?:       null | string @go(TunnelInsideCIDR,*string)
	tunnelInsideIPv6CIDR?:   null | string @go(TunnelInsideIPv6CIDR,*string)
}

// +kubebuilder:skipversion
#UnsuccessfulInstanceCreditSpecificationItem: {
	instanceID?: null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#UnsuccessfulInstanceCreditSpecificationItemError: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#UnsuccessfulItem: {
	resourceID?: null | string @go(ResourceID,*string)
}

// +kubebuilder:skipversion
#UnsuccessfulItemError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#UserBucket: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Key?:    null | string @go(S3Key,*string)
}

// +kubebuilder:skipversion
#UserBucketDetails: {
	s3Bucket?: null | string @go(S3Bucket,*string)
	s3Key?:    null | string @go(S3Key,*string)
}

// +kubebuilder:skipversion
#UserData: {
	data?: null | string @go(Data,*string)
}

// +kubebuilder:skipversion
#UserIDGroupPair: {
	description?:            null | string @go(Description,*string)
	groupID?:                null | string @go(GroupID,*string)
	groupName?:              null | string @go(GroupName,*string)
	peeringStatus?:          null | string @go(PeeringStatus,*string)
	userID?:                 null | string @go(UserID,*string)
	vpcID?:                  null | string @go(VPCID,*string)
	vpcPeeringConnectionID?: null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#VCPUCountRange: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#VCPUCountRangeRequest: {
	max?: null | int64 @go(Max,*int64)
	min?: null | int64 @go(Min,*int64)
}

// +kubebuilder:skipversion
#VGWTelemetry: {
	acceptedRouteCount?: null | int64  @go(AcceptedRouteCount,*int64)
	certificateARN?:     null | string @go(CertificateARN,*string)
	outsideIPAddress?:   null | string @go(OutsideIPAddress,*string)
	statusMessage?:      null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#VPC: {
	cidrBlock?:       null | string @go(CIDRBlock,*string)
	dhcpOptionsID?:   null | string @go(DHCPOptionsID,*string)
	instanceTenancy?: null | string @go(InstanceTenancy,*string)
	isDefault?:       null | bool   @go(IsDefault,*bool)
	ownerID?:         null | string @go(OwnerID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#VPCAttachment: {
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#VPCCIDRBlockAssociation: {
	associationID?: null | string @go(AssociationID,*string)
	cidrBlock?:     null | string @go(CIDRBlock,*string)
}

// +kubebuilder:skipversion
#VPCCIDRBlockState: {
	statusMessage?: null | string @go(StatusMessage,*string)
}

// +kubebuilder:skipversion
#VPCClassicLink: {
	classicLinkEnabled?: null | bool @go(ClassicLinkEnabled,*bool)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcID?: null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#VPCEndpointConnection: {
	dnsEntries?: [...null | #DNSEntry] @go(DNSEntries,[]*DNSEntry)
	gatewayLoadBalancerARNs?: [...null | string] @go(GatewayLoadBalancerARNs,[]*string)
	ipAddressType?: null | string @go(IPAddressType,*string)
	networkLoadBalancerARNs?: [...null | string] @go(NetworkLoadBalancerARNs,[]*string)
	serviceID?: null | string @go(ServiceID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcEndpointConnectionID?: null | string @go(VPCEndpointConnectionID,*string)
	vpcEndpointID?:           null | string @go(VPCEndpointID,*string)
	vpcEndpointOwner?:        null | string @go(VPCEndpointOwner,*string)
	vpcEndpointState?:        null | string @go(VPCEndpointState,*string)
}

// +kubebuilder:skipversion
#VPCEndpoint_SDK: {
	dnsEntries?: [...null | #DNSEntry] @go(DNSEntries,[]*DNSEntry)

	// Describes the DNS options for an endpoint.
	dnsOptions?: null | #DNSOptions @go(DNSOptions,*DNSOptions)
	groups?: [...null | #SecurityGroupIdentifier] @go(Groups,[]*SecurityGroupIdentifier)
	ipAddressType?: null | string @go(IPAddressType,*string)

	// The last error that occurred for a VPC endpoint.
	lastError?: null | #LastError @go(LastError,*LastError)
	networkInterfaceIDs?: [...null | string] @go(NetworkInterfaceIDs,[]*string)
	ownerID?:           null | string @go(OwnerID,*string)
	policyDocument?:    null | string @go(PolicyDocument,*string)
	privateDNSEnabled?: null | bool   @go(PrivateDNSEnabled,*bool)
	requesterManaged?:  null | bool   @go(RequesterManaged,*bool)
	routeTableIDs?: [...null | string] @go(RouteTableIDs,[]*string)
	serviceName?: null | string @go(ServiceName,*string)
	state?:       null | string @go(State,*string)
	subnetIDs?: [...null | string] @go(SubnetIDs,[]*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcEndpointID?:   null | string @go(VPCEndpointID,*string)
	vpcEndpointType?: null | string @go(VPCEndpointType,*string)
	vpcID?:           null | string @go(VPCID,*string)
}

// +kubebuilder:skipversion
#VPCIPv6CIDRBlockAssociation: {
	associationID?:      null | string @go(AssociationID,*string)
	ipv6CIDRBlock?:      null | string @go(IPv6CIDRBlock,*string)
	ipv6Pool?:           null | string @go(IPv6Pool,*string)
	networkBorderGroup?: null | string @go(NetworkBorderGroup,*string)
}

// +kubebuilder:skipversion
#VPCPeeringConnectionOptionsDescription: {
	allowDNSResolutionFromRemoteVPC?:            null | bool @go(AllowDNSResolutionFromRemoteVPC,*bool)
	allowEgressFromLocalClassicLinkToRemoteVPC?: null | bool @go(AllowEgressFromLocalClassicLinkToRemoteVPC,*bool)
	allowEgressFromLocalVPCToRemoteClassicLink?: null | bool @go(AllowEgressFromLocalVPCToRemoteClassicLink,*bool)
}

// +kubebuilder:skipversion
#VPCPeeringConnectionStateReason: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#VPCPeeringConnectionVPCInfo: {
	cidrBlock?: null | string @go(CIDRBlock,*string)
	cidrBlockSet?: [...null | #CIDRBlock] @go(CIDRBlockSet,[]*CIDRBlock)
	ipv6CIDRBlockSet?: [...null | #IPv6CIDRBlock] @go(IPv6CIDRBlockSet,[]*IPv6CIDRBlock)
	ownerID?: null | string @go(OwnerID,*string)

	//
	// We are retiring EC2-Classic. We recommend that you migrate from EC2-Classic
	// to a VPC. For more information, see Migrate from EC2-Classic to a VPC (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/vpc-migrate.html)
	// in the Amazon Elastic Compute Cloud User Guide.
	//
	// Describes the VPC peering connection options.
	peeringOptions?: null | #VPCPeeringConnectionOptionsDescription @go(PeeringOptions,*VPCPeeringConnectionOptionsDescription)
	region?:         null | string                                  @go(Region,*string)
	vpcID?:          null | string                                  @go(VPCID,*string)
}

// +kubebuilder:skipversion
#VPCPeeringConnection_SDK: {
	// Describes a VPC in a VPC peering connection.
	accepterVPCInfo?: null | #VPCPeeringConnectionVPCInfo @go(AccepterVPCInfo,*VPCPeeringConnectionVPCInfo)

	// Describes a VPC in a VPC peering connection.
	requesterVPCInfo?: null | #VPCPeeringConnectionVPCInfo @go(RequesterVPCInfo,*VPCPeeringConnectionVPCInfo)

	// Describes the status of a VPC peering connection.
	status?: null | #VPCPeeringConnectionStateReason @go(Status,*VPCPeeringConnectionStateReason)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpcPeeringConnectionID?: null | string @go(VPCPeeringConnectionID,*string)
}

// +kubebuilder:skipversion
#VPNConnection: {
	category?:                     null | string @go(Category,*string)
	coreNetworkARN?:               null | string @go(CoreNetworkARN,*string)
	coreNetworkAttachmentARN?:     null | string @go(CoreNetworkAttachmentARN,*string)
	customerGatewayConfiguration?: null | string @go(CustomerGatewayConfiguration,*string)
	customerGatewayID?:            null | string @go(CustomerGatewayID,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	transitGatewayID?: null | string @go(TransitGatewayID,*string)
	vpnConnectionID?:  null | string @go(VPNConnectionID,*string)
	vpnGatewayID?:     null | string @go(VPNGatewayID,*string)
}

// +kubebuilder:skipversion
#VPNConnectionDeviceType: {
	platform?:                  null | string @go(Platform,*string)
	software?:                  null | string @go(Software,*string)
	vendor?:                    null | string @go(Vendor,*string)
	vpnConnectionDeviceTypeID?: null | string @go(VPNConnectionDeviceTypeID,*string)
}

// +kubebuilder:skipversion
#VPNConnectionOptions: {
	enableAcceleration?:                  null | bool   @go(EnableAcceleration,*bool)
	localIPv4NetworkCIDR?:                null | string @go(LocalIPv4NetworkCIDR,*string)
	localIPv6NetworkCIDR?:                null | string @go(LocalIPv6NetworkCIDR,*string)
	outsideIPAddressType?:                null | string @go(OutsideIPAddressType,*string)
	remoteIPv4NetworkCIDR?:               null | string @go(RemoteIPv4NetworkCIDR,*string)
	remoteIPv6NetworkCIDR?:               null | string @go(RemoteIPv6NetworkCIDR,*string)
	staticRoutesOnly?:                    null | bool   @go(StaticRoutesOnly,*bool)
	transportTransitGatewayAttachmentID?: null | string @go(TransportTransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#VPNConnectionOptionsSpecification: {
	enableAcceleration?:                  null | bool   @go(EnableAcceleration,*bool)
	localIPv4NetworkCIDR?:                null | string @go(LocalIPv4NetworkCIDR,*string)
	localIPv6NetworkCIDR?:                null | string @go(LocalIPv6NetworkCIDR,*string)
	outsideIPAddressType?:                null | string @go(OutsideIPAddressType,*string)
	remoteIPv4NetworkCIDR?:               null | string @go(RemoteIPv4NetworkCIDR,*string)
	remoteIPv6NetworkCIDR?:               null | string @go(RemoteIPv6NetworkCIDR,*string)
	staticRoutesOnly?:                    null | bool   @go(StaticRoutesOnly,*bool)
	transportTransitGatewayAttachmentID?: null | string @go(TransportTransitGatewayAttachmentID,*string)
}

// +kubebuilder:skipversion
#VPNGateway: {
	amazonSideASN?:    null | int64  @go(AmazonSideASN,*int64)
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	vpnGatewayID?: null | string @go(VPNGatewayID,*string)
}

// +kubebuilder:skipversion
#VPNStaticRoute: {
	destinationCIDRBlock?: null | string @go(DestinationCIDRBlock,*string)
}

// +kubebuilder:skipversion
#VPNTunnelOptionsSpecification: {
	dpdTimeoutAction?:       null | string @go(DPDTimeoutAction,*string)
	dpdTimeoutSeconds?:      null | int64  @go(DPDTimeoutSeconds,*int64)
	phase1LifetimeSeconds?:  null | int64  @go(Phase1LifetimeSeconds,*int64)
	phase2LifetimeSeconds?:  null | int64  @go(Phase2LifetimeSeconds,*int64)
	preSharedKey?:           null | string @go(PreSharedKey,*string)
	rekeyFuzzPercentage?:    null | int64  @go(RekeyFuzzPercentage,*int64)
	rekeyMarginTimeSeconds?: null | int64  @go(RekeyMarginTimeSeconds,*int64)
	replayWindowSize?:       null | int64  @go(ReplayWindowSize,*int64)
	startupAction?:          null | string @go(StartupAction,*string)
	tunnelInsideCIDR?:       null | string @go(TunnelInsideCIDR,*string)
	tunnelInsideIPv6CIDR?:   null | string @go(TunnelInsideIPv6CIDR,*string)
}

// +kubebuilder:skipversion
#ValidationError: {
	code?:    null | string @go(Code,*string)
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#ValidationWarning: {
	errors?: [...null | #ValidationError] @go(Errors,[]*ValidationError)
}

// +kubebuilder:skipversion
#VerifiedAccessEndpoint: {
	applicationDomain?:      null | string @go(ApplicationDomain,*string)
	creationTime?:           null | string @go(CreationTime,*string)
	deletionTime?:           null | string @go(DeletionTime,*string)
	description?:            null | string @go(Description,*string)
	deviceValidationDomain?: null | string @go(DeviceValidationDomain,*string)
	domainCertificateARN?:   null | string @go(DomainCertificateARN,*string)
	endpointDomain?:         null | string @go(EndpointDomain,*string)
	lastUpdatedTime?:        null | string @go(LastUpdatedTime,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	verifiedAccessEndpointID?: null | string @go(VerifiedAccessEndpointID,*string)
	verifiedAccessGroupID?:    null | string @go(VerifiedAccessGroupID,*string)
	verifiedAccessInstanceID?: null | string @go(VerifiedAccessInstanceID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessEndpointEniOptions: {
	networkInterfaceID?: null | string @go(NetworkInterfaceID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessEndpointLoadBalancerOptions: {
	loadBalancerARN?: null | string @go(LoadBalancerARN,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessEndpointStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessGroup: {
	creationTime?:    null | string @go(CreationTime,*string)
	deletionTime?:    null | string @go(DeletionTime,*string)
	description?:     null | string @go(Description,*string)
	lastUpdatedTime?: null | string @go(LastUpdatedTime,*string)
	owner?:           null | string @go(Owner,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	verifiedAccessGroupARN?:   null | string @go(VerifiedAccessGroupARN,*string)
	verifiedAccessGroupID?:    null | string @go(VerifiedAccessGroupID,*string)
	verifiedAccessInstanceID?: null | string @go(VerifiedAccessInstanceID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessInstance: {
	creationTime?:    null | string @go(CreationTime,*string)
	description?:     null | string @go(Description,*string)
	lastUpdatedTime?: null | string @go(LastUpdatedTime,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	verifiedAccessInstanceID?: null | string @go(VerifiedAccessInstanceID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessInstanceLoggingConfiguration: {
	verifiedAccessInstanceID?: null | string @go(VerifiedAccessInstanceID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessLogCloudWatchLogsDestination: {
	enabled?:  null | bool   @go(Enabled,*bool)
	logGroup?: null | string @go(LogGroup,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessLogCloudWatchLogsDestinationOptions: {
	enabled?:  null | bool   @go(Enabled,*bool)
	logGroup?: null | string @go(LogGroup,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessLogDeliveryStatus: {
	message?: null | string @go(Message,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessLogKinesisDataFirehoseDestination: {
	deliveryStream?: null | string @go(DeliveryStream,*string)
	enabled?:        null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#VerifiedAccessLogKinesisDataFirehoseDestinationOptions: {
	deliveryStream?: null | string @go(DeliveryStream,*string)
	enabled?:        null | bool   @go(Enabled,*bool)
}

// +kubebuilder:skipversion
#VerifiedAccessLogS3Destination: {
	bucketName?:  null | string @go(BucketName,*string)
	bucketOwner?: null | string @go(BucketOwner,*string)
	enabled?:     null | bool   @go(Enabled,*bool)
	prefix?:      null | string @go(Prefix,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessLogS3DestinationOptions: {
	bucketName?:  null | string @go(BucketName,*string)
	bucketOwner?: null | string @go(BucketOwner,*string)
	enabled?:     null | bool   @go(Enabled,*bool)
	prefix?:      null | string @go(Prefix,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessTrustProvider: {
	creationTime?:        null | string @go(CreationTime,*string)
	description?:         null | string @go(Description,*string)
	lastUpdatedTime?:     null | string @go(LastUpdatedTime,*string)
	policyReferenceName?: null | string @go(PolicyReferenceName,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	verifiedAccessTrustProviderID?: null | string @go(VerifiedAccessTrustProviderID,*string)
}

// +kubebuilder:skipversion
#VerifiedAccessTrustProviderCondensed: {
	description?:                   null | string @go(Description,*string)
	verifiedAccessTrustProviderID?: null | string @go(VerifiedAccessTrustProviderID,*string)
}

// +kubebuilder:skipversion
#VolumeAttachment: {
	deleteOnTermination?: null | bool   @go(DeleteOnTermination,*bool)
	device?:              null | string @go(Device,*string)
	instanceID?:          null | string @go(InstanceID,*string)
	state?:               null | string @go(State,*string)
	volumeID?:            null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#VolumeDetail: {
	size?: null | int64 @go(Size,*int64)
}

// +kubebuilder:skipversion
#VolumeModification: {
	modificationState?:          null | string @go(ModificationState,*string)
	originalIOPS?:               null | int64  @go(OriginalIOPS,*int64)
	originalMultiAttachEnabled?: null | bool   @go(OriginalMultiAttachEnabled,*bool)
	originalSize?:               null | int64  @go(OriginalSize,*int64)
	originalThroughput?:         null | int64  @go(OriginalThroughput,*int64)
	originalVolumeType?:         null | string @go(OriginalVolumeType,*string)
	progress?:                   null | int64  @go(Progress,*int64)
	statusMessage?:              null | string @go(StatusMessage,*string)
	targetIOPS?:                 null | int64  @go(TargetIOPS,*int64)
	targetMultiAttachEnabled?:   null | bool   @go(TargetMultiAttachEnabled,*bool)
	targetSize?:                 null | int64  @go(TargetSize,*int64)
	targetThroughput?:           null | int64  @go(TargetThroughput,*int64)
	targetVolumeType?:           null | string @go(TargetVolumeType,*string)
	volumeID?:                   null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#VolumeStatusAction: {
	code?:        null | string @go(Code,*string)
	description?: null | string @go(Description,*string)
	eventID?:     null | string @go(EventID,*string)
	eventType?:   null | string @go(EventType,*string)
}

// +kubebuilder:skipversion
#VolumeStatusAttachmentStatus: {
	instanceID?:    null | string @go(InstanceID,*string)
	ioPerformance?: null | string @go(IOPerformance,*string)
}

// +kubebuilder:skipversion
#VolumeStatusDetails: {
	status?: null | string @go(Status,*string)
}

// +kubebuilder:skipversion
#VolumeStatusEvent: {
	description?: null | string @go(Description,*string)
	eventID?:     null | string @go(EventID,*string)
	eventType?:   null | string @go(EventType,*string)
	instanceID?:  null | string @go(InstanceID,*string)
}

// +kubebuilder:skipversion
#VolumeStatusItem: {
	availabilityZone?: null | string @go(AvailabilityZone,*string)
	outpostARN?:       null | string @go(OutpostARN,*string)
	volumeID?:         null | string @go(VolumeID,*string)
}

// +kubebuilder:skipversion
#Volume_SDK: {
	attachments?: [...null | #VolumeAttachment] @go(Attachments,[]*VolumeAttachment)
	availabilityZone?:   null | string @go(AvailabilityZone,*string)
	encrypted?:          null | bool   @go(Encrypted,*bool)
	fastRestored?:       null | bool   @go(FastRestored,*bool)
	iops?:               null | int64  @go(IOPS,*int64)
	kmsKeyID?:           null | string @go(KMSKeyID,*string)
	multiAttachEnabled?: null | bool   @go(MultiAttachEnabled,*bool)
	outpostARN?:         null | string @go(OutpostARN,*string)
	size?:               null | int64  @go(Size,*int64)
	snapshotID?:         null | string @go(SnapshotID,*string)
	state?:              null | string @go(State,*string)
	tags?: [...null | #Tag] @go(Tags,[]*Tag)
	throughput?: null | int64  @go(Throughput,*int64)
	volumeID?:   null | string @go(VolumeID,*string)
	volumeType?: null | string @go(VolumeType,*string)
}
