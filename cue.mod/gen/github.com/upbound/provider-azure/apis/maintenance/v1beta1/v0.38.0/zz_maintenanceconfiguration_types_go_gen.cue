// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-azure/apis/maintenance/v1beta1

package v1beta1

#InstallPatchesInitParameters: {
	// A linux block as defined above. This property only applies when scope is set to InGuestPatch
	linux?: [...#LinuxInitParameters] @go(Linux,[]LinuxInitParameters)

	// Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are Always, IfRequired and Never. This property only applies when scope is set to InGuestPatch.
	reboot?: null | string @go(Reboot,*string)

	// A windows block as defined above. This property only applies when scope is set to InGuestPatch
	windows?: [...#WindowsInitParameters] @go(Windows,[]WindowsInitParameters)
}

#InstallPatchesObservation: {
	// A linux block as defined above. This property only applies when scope is set to InGuestPatch
	linux?: [...#LinuxObservation] @go(Linux,[]LinuxObservation)

	// Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are Always, IfRequired and Never. This property only applies when scope is set to InGuestPatch.
	reboot?: null | string @go(Reboot,*string)

	// A windows block as defined above. This property only applies when scope is set to InGuestPatch
	windows?: [...#WindowsObservation] @go(Windows,[]WindowsObservation)
}

#InstallPatchesParameters: {
	// A linux block as defined above. This property only applies when scope is set to InGuestPatch
	// +kubebuilder:validation:Optional
	linux?: [...#LinuxParameters] @go(Linux,[]LinuxParameters)

	// Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are Always, IfRequired and Never. This property only applies when scope is set to InGuestPatch.
	// +kubebuilder:validation:Optional
	reboot?: null | string @go(Reboot,*string)

	// A windows block as defined above. This property only applies when scope is set to InGuestPatch
	// +kubebuilder:validation:Optional
	windows?: [...#WindowsParameters] @go(Windows,[]WindowsParameters)
}

#LinuxInitParameters: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of package names to be excluded from patching.
	packageNamesMaskToExclude?: [...null | string] @go(PackageNamesMaskToExclude,[]*string)

	// List of package names to be included for patching.
	packageNamesMaskToInclude?: [...null | string] @go(PackageNamesMaskToInclude,[]*string)
}

#LinuxObservation: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of package names to be excluded from patching.
	packageNamesMaskToExclude?: [...null | string] @go(PackageNamesMaskToExclude,[]*string)

	// List of package names to be included for patching.
	packageNamesMaskToInclude?: [...null | string] @go(PackageNamesMaskToInclude,[]*string)
}

#LinuxParameters: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	// +kubebuilder:validation:Optional
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of package names to be excluded from patching.
	// +kubebuilder:validation:Optional
	packageNamesMaskToExclude?: [...null | string] @go(PackageNamesMaskToExclude,[]*string)

	// List of package names to be included for patching.
	// +kubebuilder:validation:Optional
	packageNamesMaskToInclude?: [...null | string] @go(PackageNamesMaskToInclude,[]*string)
}

#MaintenanceConfigurationInitParameters: {
	// The in guest user patch mode. Possible values are Platform or User. Must be specified when scope is InGuestPatch.
	inGuestUserPatchMode?: null | string @go(InGuestUserPatchMode,*string)

	// An install_patches block as defined below.
	installPatches?: [...#InstallPatchesInitParameters] @go(InstallPatches,[]InstallPatchesInitParameters)

	// Specified the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	location?: null | string @go(Location,*string)

	// A mapping of properties to assign to the resource.
	properties?: {[string]: null | string} @go(Properties,map[string]*string)

	// The scope of the Maintenance Configuration. Possible values are Extension, Host, InGuestPatch, OSImage, SQLDB or SQLManagedInstance.
	scope?: null | string @go(Scope,*string)

	// A mapping of tags to assign to the resource. The key could not contain upper case letter.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// The visibility of the Maintenance Configuration. The only allowable value is Custom.
	visibility?: null | string @go(Visibility,*string)

	// A window block as defined below.
	window?: [...#WindowInitParameters] @go(Window,[]WindowInitParameters)
}

#MaintenanceConfigurationObservation: {
	// The ID of the Maintenance Configuration.
	id?: null | string @go(ID,*string)

	// The in guest user patch mode. Possible values are Platform or User. Must be specified when scope is InGuestPatch.
	inGuestUserPatchMode?: null | string @go(InGuestUserPatchMode,*string)

	// An install_patches block as defined below.
	installPatches?: [...#InstallPatchesObservation] @go(InstallPatches,[]InstallPatchesObservation)

	// Specified the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	location?: null | string @go(Location,*string)

	// A mapping of properties to assign to the resource.
	properties?: {[string]: null | string} @go(Properties,map[string]*string)

	// The name of the Resource Group where the Maintenance Configuration should exist. Changing this forces a new resource to be created.
	resourceGroupName?: null | string @go(ResourceGroupName,*string)

	// The scope of the Maintenance Configuration. Possible values are Extension, Host, InGuestPatch, OSImage, SQLDB or SQLManagedInstance.
	scope?: null | string @go(Scope,*string)

	// A mapping of tags to assign to the resource. The key could not contain upper case letter.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// The visibility of the Maintenance Configuration. The only allowable value is Custom.
	visibility?: null | string @go(Visibility,*string)

	// A window block as defined below.
	window?: [...#WindowObservation] @go(Window,[]WindowObservation)
}

#MaintenanceConfigurationParameters: {
	// The in guest user patch mode. Possible values are Platform or User. Must be specified when scope is InGuestPatch.
	// +kubebuilder:validation:Optional
	inGuestUserPatchMode?: null | string @go(InGuestUserPatchMode,*string)

	// An install_patches block as defined below.
	// +kubebuilder:validation:Optional
	installPatches?: [...#InstallPatchesParameters] @go(InstallPatches,[]InstallPatchesParameters)

	// Specified the supported Azure location where the resource exists. Changing this forces a new resource to be created.
	// +kubebuilder:validation:Optional
	location?: null | string @go(Location,*string)

	// A mapping of properties to assign to the resource.
	// +kubebuilder:validation:Optional
	properties?: {[string]: null | string} @go(Properties,map[string]*string)

	// The name of the Resource Group where the Maintenance Configuration should exist. Changing this forces a new resource to be created.
	// +crossplane:generate:reference:type=github.com/upbound/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	resourceGroupName?: null | string @go(ResourceGroupName,*string)

	// The scope of the Maintenance Configuration. Possible values are Extension, Host, InGuestPatch, OSImage, SQLDB or SQLManagedInstance.
	// +kubebuilder:validation:Optional
	scope?: null | string @go(Scope,*string)

	// A mapping of tags to assign to the resource. The key could not contain upper case letter.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// The visibility of the Maintenance Configuration. The only allowable value is Custom.
	// +kubebuilder:validation:Optional
	visibility?: null | string @go(Visibility,*string)

	// A window block as defined below.
	// +kubebuilder:validation:Optional
	window?: [...#WindowParameters] @go(Window,[]WindowParameters)
}

#WindowInitParameters: {
	// The duration of the maintenance window in HH:mm format.
	duration?: null | string @go(Duration,*string)

	// Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
	expirationDateTime?: null | string @go(ExpirationDateTime,*string)

	// The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
	recurEvery?: null | string @go(RecurEvery,*string)

	// Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
	startDateTime?: null | string @go(StartDateTime,*string)

	// The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
	timeZone?: null | string @go(TimeZone,*string)
}

#WindowObservation: {
	// The duration of the maintenance window in HH:mm format.
	duration?: null | string @go(Duration,*string)

	// Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
	expirationDateTime?: null | string @go(ExpirationDateTime,*string)

	// The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
	recurEvery?: null | string @go(RecurEvery,*string)

	// Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
	startDateTime?: null | string @go(StartDateTime,*string)

	// The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
	timeZone?: null | string @go(TimeZone,*string)
}

#WindowParameters: {
	// The duration of the maintenance window in HH:mm format.
	// +kubebuilder:validation:Optional
	duration?: null | string @go(Duration,*string)

	// Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
	// +kubebuilder:validation:Optional
	expirationDateTime?: null | string @go(ExpirationDateTime,*string)

	// The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
	// +kubebuilder:validation:Optional
	recurEvery?: null | string @go(RecurEvery,*string)

	// Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
	// +kubebuilder:validation:Optional
	startDateTime?: null | string @go(StartDateTime,*string)

	// The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
	// +kubebuilder:validation:Optional
	timeZone?: null | string @go(TimeZone,*string)
}

#WindowsInitParameters: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of KB numbers to be excluded from patching.
	kbNumbersToExclude?: [...null | string] @go(KbNumbersToExclude,[]*string)

	// List of KB numbers to be included for patching.
	kbNumbersToInclude?: [...null | string] @go(KbNumbersToInclude,[]*string)
}

#WindowsObservation: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of KB numbers to be excluded from patching.
	kbNumbersToExclude?: [...null | string] @go(KbNumbersToExclude,[]*string)

	// List of KB numbers to be included for patching.
	kbNumbersToInclude?: [...null | string] @go(KbNumbersToInclude,[]*string)
}

#WindowsParameters: {
	// List of Classification category of patches to be patched. Possible values are Critical, Security, UpdateRollup, FeaturePack, ServicePack, Definition, Tools and Updates.
	// +kubebuilder:validation:Optional
	classificationsToInclude?: [...null | string] @go(ClassificationsToInclude,[]*string)

	// List of KB numbers to be excluded from patching.
	// +kubebuilder:validation:Optional
	kbNumbersToExclude?: [...null | string] @go(KbNumbersToExclude,[]*string)

	// List of KB numbers to be included for patching.
	// +kubebuilder:validation:Optional
	kbNumbersToInclude?: [...null | string] @go(KbNumbersToInclude,[]*string)
}

// MaintenanceConfigurationSpec defines the desired state of MaintenanceConfiguration
#MaintenanceConfigurationSpec: {
	forProvider: #MaintenanceConfigurationParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #MaintenanceConfigurationInitParameters @go(InitProvider)
}

// MaintenanceConfigurationStatus defines the observed state of MaintenanceConfiguration.
#MaintenanceConfigurationStatus: {
	atProvider?: #MaintenanceConfigurationObservation @go(AtProvider)
}

// MaintenanceConfiguration is the Schema for the MaintenanceConfigurations API. Manages a Maintenance Configuration.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
#MaintenanceConfiguration: {
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.location) || (has(self.initProvider) && has(self.initProvider.location))",message="spec.forProvider.location is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.scope) || (has(self.initProvider) && has(self.initProvider.scope))",message="spec.forProvider.scope is a required parameter"
	spec:    #MaintenanceConfigurationSpec   @go(Spec)
	status?: #MaintenanceConfigurationStatus @go(Status)
}

// MaintenanceConfigurationList contains a list of MaintenanceConfigurations
#MaintenanceConfigurationList: {
	items: [...#MaintenanceConfiguration] @go(Items,[]MaintenanceConfiguration)
}
