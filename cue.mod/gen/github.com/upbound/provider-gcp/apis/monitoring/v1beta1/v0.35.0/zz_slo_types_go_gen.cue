// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/monitoring/v1beta1

package v1beta1

#AvailabilityInitParameters: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	enabled?: null | bool @go(Enabled,*bool)
}

#AvailabilityObservation: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	enabled?: null | bool @go(Enabled,*bool)
}

#AvailabilityParameters: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	enabled?: null | bool @go(Enabled,*bool)
}

#BasicSliInitParameters: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	availability?: [...#AvailabilityInitParameters] @go(Availability,[]AvailabilityInitParameters)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	latency?: [...#LatencyInitParameters] @go(Latency,[]LatencyInitParameters)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	version?: [...null | string] @go(Version,[]*string)
}

#BasicSliObservation: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	availability?: [...#AvailabilityObservation] @go(Availability,[]AvailabilityObservation)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	latency?: [...#LatencyObservation] @go(Latency,[]LatencyObservation)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	version?: [...null | string] @go(Version,[]*string)
}

#BasicSliParameters: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	availability?: [...#AvailabilityParameters] @go(Availability,[]AvailabilityParameters)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	latency?: [...#LatencyParameters] @go(Latency,[]LatencyParameters)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	version?: [...null | string] @go(Version,[]*string)
}

#BasicSliPerformanceAvailabilityInitParameters: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	enabled?: null | bool @go(Enabled,*bool)
}

#BasicSliPerformanceAvailabilityObservation: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	enabled?: null | bool @go(Enabled,*bool)
}

#BasicSliPerformanceAvailabilityParameters: {
	// Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
	// +kubebuilder:validation:Optional
	enabled?: null | bool @go(Enabled,*bool)
}

#BasicSliPerformanceInitParameters: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	availability?: [...#BasicSliPerformanceAvailabilityInitParameters] @go(Availability,[]BasicSliPerformanceAvailabilityInitParameters)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	latency?: [...#BasicSliPerformanceLatencyInitParameters] @go(Latency,[]BasicSliPerformanceLatencyInitParameters)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	version?: [...null | string] @go(Version,[]*string)
}

#BasicSliPerformanceLatencyInitParameters: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | string @go(Threshold,*string)
}

#BasicSliPerformanceLatencyObservation: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | string @go(Threshold,*string)
}

#BasicSliPerformanceLatencyParameters: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	threshold?: null | string @go(Threshold,*string)
}

#BasicSliPerformanceObservation: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	availability?: [...#BasicSliPerformanceAvailabilityObservation] @go(Availability,[]BasicSliPerformanceAvailabilityObservation)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	latency?: [...#BasicSliPerformanceLatencyObservation] @go(Latency,[]BasicSliPerformanceLatencyObservation)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	version?: [...null | string] @go(Version,[]*string)
}

#BasicSliPerformanceParameters: {
	// Availability based SLI, dervied from count of requests made to this service that return successfully.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	availability?: [...#BasicSliPerformanceAvailabilityParameters] @go(Availability,[]BasicSliPerformanceAvailabilityParameters)

	// Parameters for a latency threshold SLI.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	latency?: [...#BasicSliPerformanceLatencyParameters] @go(Latency,[]BasicSliPerformanceLatencyParameters)

	// An optional set of locations to which this SLI is relevant.
	// Telemetry from other locations will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// locations in which the Service has activity. For service types
	// that don't support breaking down by location, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	location?: [...null | string] @go(Location,[]*string)

	// An optional set of RPCs to which this SLI is relevant.
	// Telemetry from other methods will not be used to calculate
	// performance for this SLI. If omitted, this SLI applies to all
	// the Service's methods. For service types that don't support
	// breaking down by method, setting this field will result in an
	// error.
	// +kubebuilder:validation:Optional
	method?: [...null | string] @go(Method,[]*string)

	// The set of API versions to which this SLI is relevant.
	// Telemetry from other API versions will not be used to
	// calculate performance for this SLI. If omitted,
	// this SLI applies to all API versions. For service types
	// that don't support breaking down by version, setting this
	// field will result in an error.
	// +kubebuilder:validation:Optional
	version?: [...null | string] @go(Version,[]*string)
}

#DistributionCutInitParameters: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#RangeInitParameters] @go(Range,[]RangeInitParameters)
}

#DistributionCutObservation: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#RangeObservation] @go(Range,[]RangeObservation)
}

#DistributionCutParameters: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	range?: [...#RangeParameters] @go(Range,[]RangeParameters)
}

#DistributionCutRangeInitParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#DistributionCutRangeObservation: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#DistributionCutRangeParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	min?: null | float64 @go(Min,*float64)
}

#GoodTotalRatioInitParameters: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#GoodTotalRatioObservation: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#GoodTotalRatioParameters: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#GoodTotalRatioThresholdInitParameters: {
	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	basicSliPerformance?: [...#BasicSliPerformanceInitParameters] @go(BasicSliPerformance,[]BasicSliPerformanceInitParameters)

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	performance?: [...#PerformanceInitParameters] @go(Performance,[]PerformanceInitParameters)

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | float64 @go(Threshold,*float64)
}

#GoodTotalRatioThresholdObservation: {
	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	basicSliPerformance?: [...#BasicSliPerformanceObservation] @go(BasicSliPerformance,[]BasicSliPerformanceObservation)

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	performance?: [...#PerformanceObservation] @go(Performance,[]PerformanceObservation)

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | float64 @go(Threshold,*float64)
}

#GoodTotalRatioThresholdParameters: {
	// Basic SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	basicSliPerformance?: [...#BasicSliPerformanceParameters] @go(BasicSliPerformance,[]BasicSliPerformanceParameters)

	// Request-based SLI to evaluate to judge window quality.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	performance?: [...#PerformanceParameters] @go(Performance,[]PerformanceParameters)

	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	threshold?: null | float64 @go(Threshold,*float64)
}

#LatencyInitParameters: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | string @go(Threshold,*string)
}

#LatencyObservation: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	threshold?: null | string @go(Threshold,*string)
}

#LatencyParameters: {
	// A duration string, e.g. 10s.
	// Good service is defined to be the count of requests made to
	// this service that return in no more than threshold.
	// +kubebuilder:validation:Optional
	threshold?: null | string @go(Threshold,*string)
}

#MetricMeanInRangeInitParameters: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#MetricMeanInRangeRangeInitParameters] @go(Range,[]MetricMeanInRangeRangeInitParameters)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricMeanInRangeObservation: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#MetricMeanInRangeRangeObservation] @go(Range,[]MetricMeanInRangeRangeObservation)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricMeanInRangeParameters: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	range?: [...#MetricMeanInRangeRangeParameters] @go(Range,[]MetricMeanInRangeRangeParameters)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricMeanInRangeRangeInitParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#MetricMeanInRangeRangeObservation: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#MetricMeanInRangeRangeParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	min?: null | float64 @go(Min,*float64)
}

#MetricSumInRangeInitParameters: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#MetricSumInRangeRangeInitParameters] @go(Range,[]MetricSumInRangeRangeInitParameters)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricSumInRangeObservation: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#MetricSumInRangeRangeObservation] @go(Range,[]MetricSumInRangeRangeObservation)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricSumInRangeParameters: {
	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	range?: [...#MetricSumInRangeRangeParameters] @go(Range,[]MetricSumInRangeRangeParameters)

	// A monitoring filter
	// specifying the TimeSeries to use for evaluating window
	// quality. The provided TimeSeries must have
	// ValueType = INT64 or ValueType = DOUBLE and
	// MetricKind = GAUGE.
	// Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// +kubebuilder:validation:Optional
	timeSeries?: null | string @go(TimeSeries,*string)
}

#MetricSumInRangeRangeInitParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#MetricSumInRangeRangeObservation: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#MetricSumInRangeRangeParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	min?: null | float64 @go(Min,*float64)
}

#PerformanceDistributionCutInitParameters: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#DistributionCutRangeInitParameters] @go(Range,[]DistributionCutRangeInitParameters)
}

#PerformanceDistributionCutObservation: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	range?: [...#DistributionCutRangeObservation] @go(Range,[]DistributionCutRangeObservation)
}

#PerformanceDistributionCutParameters: {
	// A TimeSeries monitoring filter
	// aggregating values to quantify the good service provided.
	// Must have ValueType = DISTRIBUTION and
	// MetricKind = DELTA or MetricKind = CUMULATIVE.
	// +kubebuilder:validation:Optional
	distributionFilter?: null | string @go(DistributionFilter,*string)

	// Range of numerical values. The computed good_service
	// will be the count of values x in the Distribution such
	// that range.min <= x <= range.max. inclusive of min and
	// max. Open ranges can be defined by setting
	// just one of min or max. Summed value X should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	range?: [...#DistributionCutRangeParameters] @go(Range,[]DistributionCutRangeParameters)
}

#PerformanceGoodTotalRatioInitParameters: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#PerformanceGoodTotalRatioObservation: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#PerformanceGoodTotalRatioParameters: {
	// A TimeSeries monitoring filter
	// quantifying bad service provided, either demanded service that
	// was not provided or demanded service that was of inadequate
	// quality.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	badServiceFilter?: null | string @go(BadServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying good service provided.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	goodServiceFilter?: null | string @go(GoodServiceFilter,*string)

	// A TimeSeries monitoring filter
	// quantifying total demanded service.
	// Must have ValueType = DOUBLE or ValueType = INT64 and
	// must have MetricKind = DELTA or MetricKind = CUMULATIVE.
	// Exactly two of good_service_filter,bad_service_filter,total_service_filter
	// must be set (good + bad = total is assumed).
	// +kubebuilder:validation:Optional
	totalServiceFilter?: null | string @go(TotalServiceFilter,*string)
}

#PerformanceInitParameters: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	distributionCut?: [...#PerformanceDistributionCutInitParameters] @go(DistributionCut,[]PerformanceDistributionCutInitParameters)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	goodTotalRatio?: [...#PerformanceGoodTotalRatioInitParameters] @go(GoodTotalRatio,[]PerformanceGoodTotalRatioInitParameters)
}

#PerformanceObservation: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	distributionCut?: [...#PerformanceDistributionCutObservation] @go(DistributionCut,[]PerformanceDistributionCutObservation)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	goodTotalRatio?: [...#PerformanceGoodTotalRatioObservation] @go(GoodTotalRatio,[]PerformanceGoodTotalRatioObservation)
}

#PerformanceParameters: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	distributionCut?: [...#PerformanceDistributionCutParameters] @go(DistributionCut,[]PerformanceDistributionCutParameters)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	goodTotalRatio?: [...#PerformanceGoodTotalRatioParameters] @go(GoodTotalRatio,[]PerformanceGoodTotalRatioParameters)
}

#RangeInitParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#RangeObservation: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	min?: null | float64 @go(Min,*float64)
}

#RangeParameters: {
	// max value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	max?: null | float64 @go(Max,*float64)

	// Min value for the range (inclusive). If not given,
	// will be set to 0
	// +kubebuilder:validation:Optional
	min?: null | float64 @go(Min,*float64)
}

#RequestBasedSliInitParameters: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	distributionCut?: [...#DistributionCutInitParameters] @go(DistributionCut,[]DistributionCutInitParameters)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	goodTotalRatio?: [...#GoodTotalRatioInitParameters] @go(GoodTotalRatio,[]GoodTotalRatioInitParameters)
}

#RequestBasedSliObservation: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	distributionCut?: [...#DistributionCutObservation] @go(DistributionCut,[]DistributionCutObservation)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	goodTotalRatio?: [...#GoodTotalRatioObservation] @go(GoodTotalRatio,[]GoodTotalRatioObservation)
}

#RequestBasedSliParameters: {
	// Used when good_service is defined by a count of values aggregated in a
	// Distribution that fall into a good range. The total_service is the
	// total count of all values aggregated in the Distribution.
	// Defines a distribution TimeSeries filter and thresholds used for
	// measuring good service and total service.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	distributionCut?: [...#DistributionCutParameters] @go(DistributionCut,[]DistributionCutParameters)

	// A means to compute a ratio of good_service to total_service.
	// Defines computing this ratio with two TimeSeries monitoring filters
	// Must specify exactly two of good, bad, and total service filters.
	// The relationship good_service + bad_service = total_service
	// will be assumed.
	// Exactly one of distribution_cut or good_total_ratio can be set.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	goodTotalRatio?: [...#GoodTotalRatioParameters] @go(GoodTotalRatio,[]GoodTotalRatioParameters)
}

#SLOInitParameters: {
	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	basicSli?: [...#BasicSliInitParameters] @go(BasicSli,[]BasicSliInitParameters)

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	calendarPeriod?: null | string @go(CalendarPeriod,*string)

	// Name used for UI elements listing this SLO.
	displayName?: null | string @go(DisplayName,*string)

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	goal?: null | float64 @go(Goal,*float64)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	requestBasedSli?: [...#RequestBasedSliInitParameters] @go(RequestBasedSli,[]RequestBasedSliInitParameters)

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	rollingPeriodDays?: null | float64 @go(RollingPeriodDays,*float64)

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	sloId?: null | string @go(SLOID,*string)

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	windowsBasedSli?: [...#WindowsBasedSliInitParameters] @go(WindowsBasedSli,[]WindowsBasedSliInitParameters)
}

#SLOObservation: {
	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	basicSli?: [...#BasicSliObservation] @go(BasicSli,[]BasicSliObservation)

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	calendarPeriod?: null | string @go(CalendarPeriod,*string)

	// Name used for UI elements listing this SLO.
	displayName?: null | string @go(DisplayName,*string)

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	goal?: null | float64 @go(Goal,*float64)

	// an identifier for the resource with format {{name}}
	id?: null | string @go(ID,*string)

	// The full resource name for this service. The syntax is:
	// projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
	name?: null | string @go(Name,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	requestBasedSli?: [...#RequestBasedSliObservation] @go(RequestBasedSli,[]RequestBasedSliObservation)

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	rollingPeriodDays?: null | float64 @go(RollingPeriodDays,*float64)

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	sloId?: null | string @go(SLOID,*string)

	// ID of the service to which this SLO belongs.
	service?: null | string @go(Service,*string)

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	windowsBasedSli?: [...#WindowsBasedSliObservation] @go(WindowsBasedSli,[]WindowsBasedSliObservation)
}

#SLOParameters: {
	// Basic Service-Level Indicator (SLI) on a well-known service type.
	// Performance will be computed on the basis of pre-defined metrics.
	// SLIs are used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	basicSli?: [...#BasicSliParameters] @go(BasicSli,[]BasicSliParameters)

	// A calendar period, semantically "since the start of the current
	// ".
	// Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
	// +kubebuilder:validation:Optional
	calendarPeriod?: null | string @go(CalendarPeriod,*string)

	// Name used for UI elements listing this SLO.
	// +kubebuilder:validation:Optional
	displayName?: null | string @go(DisplayName,*string)

	// The fraction of service that must be good in order for this objective
	// to be met. 0 < goal <= 0.999
	// +kubebuilder:validation:Optional
	goal?: null | float64 @go(Goal,*float64)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// A request-based SLI defines a SLI for which atomic units of
	// service are counted directly.
	// A SLI describes a good service.
	// It is used to measure and calculate the quality of the Service's
	// performance with respect to a single aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	requestBasedSli?: [...#RequestBasedSliParameters] @go(RequestBasedSli,[]RequestBasedSliParameters)

	// A rolling time period, semantically "in the past X days".
	// Must be between 1 to 30 days, inclusive.
	// +kubebuilder:validation:Optional
	rollingPeriodDays?: null | float64 @go(RollingPeriodDays,*float64)

	// The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
	// +kubebuilder:validation:Optional
	sloId?: null | string @go(SLOID,*string)

	// ID of the service to which this SLO belongs.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/monitoring/v1beta1.CustomService
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("service_id",false)
	// +kubebuilder:validation:Optional
	service?: null | string @go(Service,*string)

	// This field is intended to be used for organizing and identifying the AlertPolicy
	// objects.The field can contain up to 64 entries. Each key and value is limited
	// to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
	// can contain only lowercase letters, numerals, underscores, and dashes. Keys
	// must begin with a letter.
	// +kubebuilder:validation:Optional
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)

	// A windows-based SLI defines the criteria for time windows.
	// good_service is defined based off the count of these time windows
	// for which the provided service was of good quality.
	// A SLI describes a good service. It is used to measure and calculate
	// the quality of the Service's performance with respect to a single
	// aspect of service quality.
	// Exactly one of the following must be set:
	// basic_sli, request_based_sli, windows_based_sli
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	windowsBasedSli?: [...#WindowsBasedSliParameters] @go(WindowsBasedSli,[]WindowsBasedSliParameters)
}

#WindowsBasedSliInitParameters: {
	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	goodBadMetricFilter?: null | string @go(GoodBadMetricFilter,*string)

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	goodTotalRatioThreshold?: [...#GoodTotalRatioThresholdInitParameters] @go(GoodTotalRatioThreshold,[]GoodTotalRatioThresholdInitParameters)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	metricMeanInRange?: [...#MetricMeanInRangeInitParameters] @go(MetricMeanInRange,[]MetricMeanInRangeInitParameters)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	metricSumInRange?: [...#MetricSumInRangeInitParameters] @go(MetricSumInRange,[]MetricSumInRangeInitParameters)

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	windowPeriod?: null | string @go(WindowPeriod,*string)
}

#WindowsBasedSliObservation: {
	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	goodBadMetricFilter?: null | string @go(GoodBadMetricFilter,*string)

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	goodTotalRatioThreshold?: [...#GoodTotalRatioThresholdObservation] @go(GoodTotalRatioThreshold,[]GoodTotalRatioThresholdObservation)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	metricMeanInRange?: [...#MetricMeanInRangeObservation] @go(MetricMeanInRange,[]MetricMeanInRangeObservation)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	metricSumInRange?: [...#MetricSumInRangeObservation] @go(MetricSumInRange,[]MetricSumInRangeObservation)

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	windowPeriod?: null | string @go(WindowPeriod,*string)
}

#WindowsBasedSliParameters: {
	// A TimeSeries monitoring filter
	// with ValueType = BOOL. The window is good if any true values
	// appear in the window. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// +kubebuilder:validation:Optional
	goodBadMetricFilter?: null | string @go(GoodBadMetricFilter,*string)

	// Criterion that describes a window as good if its performance is
	// high enough. One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	goodTotalRatioThreshold?: [...#GoodTotalRatioThresholdParameters] @go(GoodTotalRatioThreshold,[]GoodTotalRatioThresholdParameters)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, averaged across returned streams.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Average value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	metricMeanInRange?: [...#MetricMeanInRangeParameters] @go(MetricMeanInRange,[]MetricMeanInRangeParameters)

	// Criterion that describes a window as good if the metric's value
	// is in a good range, summed across returned streams.
	// Summed value X of time_series should satisfy
	// range.min <= X <= range.max for a good window.
	// One of good_bad_metric_filter,
	// good_total_ratio_threshold, metric_mean_in_range,
	// metric_sum_in_range must be set for windows_based_sli.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	metricSumInRange?: [...#MetricSumInRangeParameters] @go(MetricSumInRange,[]MetricSumInRangeParameters)

	// Duration over which window quality is evaluated, given as a
	// duration string "{X}s" representing X seconds. Must be an
	// integer fraction of a day and at least 60s.
	// +kubebuilder:validation:Optional
	windowPeriod?: null | string @go(WindowPeriod,*string)
}

// SLOSpec defines the desired state of SLO
#SLOSpec: {
	forProvider: #SLOParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #SLOInitParameters @go(InitProvider)
}

// SLOStatus defines the observed state of SLO.
#SLOStatus: {
	atProvider?: #SLOObservation @go(AtProvider)
}

// SLO is the Schema for the SLOs API. A Service-Level Objective (SLO) describes the level of desired good service.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp},path=sloes
#SLO: {
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.goal) || has(self.initProvider.goal)",message="goal is a required parameter"
	spec:    #SLOSpec   @go(Spec)
	status?: #SLOStatus @go(Status)
}

// SLOList contains a list of SLOs
#SLOList: {
	items: [...#SLO] @go(Items,[]SLO)
}
