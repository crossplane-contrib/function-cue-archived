// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/accesscontextmanager/v1beta1

package v1beta1

#AccessLevelConditionDevicePolicyInitParameters: {
	// A list of allowed device management levels.
	// An empty list allows all management levels.
	// Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
	allowedDeviceManagementLevels?: [...null | string] @go(AllowedDeviceManagementLevels,[]*string)

	// A list of allowed encryptions statuses.
	// An empty list allows all statuses.
	// Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
	allowedEncryptionStatuses?: [...null | string] @go(AllowedEncryptionStatuses,[]*string)

	// A list of allowed OS versions.
	// An empty list allows all types and all versions.
	// Structure is documented below.
	osConstraints?: [...#DevicePolicyOsConstraintsInitParameters] @go(OsConstraints,[]DevicePolicyOsConstraintsInitParameters)

	// Whether the device needs to be approved by the customer admin.
	requireAdminApproval?: null | bool @go(RequireAdminApproval,*bool)

	// Whether the device needs to be corp owned.
	requireCorpOwned?: null | bool @go(RequireCorpOwned,*bool)

	// Whether or not screenlock is required for the DevicePolicy
	// to be true. Defaults to false.
	requireScreenLock?: null | bool @go(RequireScreenLock,*bool)
}

#AccessLevelConditionDevicePolicyObservation: {
	// A list of allowed device management levels.
	// An empty list allows all management levels.
	// Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
	allowedDeviceManagementLevels?: [...null | string] @go(AllowedDeviceManagementLevels,[]*string)

	// A list of allowed encryptions statuses.
	// An empty list allows all statuses.
	// Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
	allowedEncryptionStatuses?: [...null | string] @go(AllowedEncryptionStatuses,[]*string)

	// A list of allowed OS versions.
	// An empty list allows all types and all versions.
	// Structure is documented below.
	osConstraints?: [...#DevicePolicyOsConstraintsObservation] @go(OsConstraints,[]DevicePolicyOsConstraintsObservation)

	// Whether the device needs to be approved by the customer admin.
	requireAdminApproval?: null | bool @go(RequireAdminApproval,*bool)

	// Whether the device needs to be corp owned.
	requireCorpOwned?: null | bool @go(RequireCorpOwned,*bool)

	// Whether or not screenlock is required for the DevicePolicy
	// to be true. Defaults to false.
	requireScreenLock?: null | bool @go(RequireScreenLock,*bool)
}

#AccessLevelConditionDevicePolicyParameters: {
	// A list of allowed device management levels.
	// An empty list allows all management levels.
	// Each value may be one of: MANAGEMENT_UNSPECIFIED, NONE, BASIC, COMPLETE.
	// +kubebuilder:validation:Optional
	allowedDeviceManagementLevels?: [...null | string] @go(AllowedDeviceManagementLevels,[]*string)

	// A list of allowed encryptions statuses.
	// An empty list allows all statuses.
	// Each value may be one of: ENCRYPTION_UNSPECIFIED, ENCRYPTION_UNSUPPORTED, UNENCRYPTED, ENCRYPTED.
	// +kubebuilder:validation:Optional
	allowedEncryptionStatuses?: [...null | string] @go(AllowedEncryptionStatuses,[]*string)

	// A list of allowed OS versions.
	// An empty list allows all types and all versions.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	osConstraints?: [...#DevicePolicyOsConstraintsParameters] @go(OsConstraints,[]DevicePolicyOsConstraintsParameters)

	// Whether the device needs to be approved by the customer admin.
	// +kubebuilder:validation:Optional
	requireAdminApproval?: null | bool @go(RequireAdminApproval,*bool)

	// Whether the device needs to be corp owned.
	// +kubebuilder:validation:Optional
	requireCorpOwned?: null | bool @go(RequireCorpOwned,*bool)

	// Whether or not screenlock is required for the DevicePolicy
	// to be true. Defaults to false.
	// +kubebuilder:validation:Optional
	requireScreenLock?: null | bool @go(RequireScreenLock,*bool)
}

#AccessLevelConditionInitParameters: {
	// Device specific restrictions, all restrictions must hold for
	// the Condition to be true. If not specified, all devices are
	// allowed.
	// Structure is documented below.
	devicePolicy?: [...#AccessLevelConditionDevicePolicyInitParameters] @go(DevicePolicy,[]AccessLevelConditionDevicePolicyInitParameters)

	// A list of CIDR block IP subnetwork specification. May be IPv4
	// or IPv6.
	// Note that for a CIDR IP address block, the specified IP address
	// portion must be properly truncated (i.e. all the host bits must
	// be zero) or the input is considered malformed. For example,
	// "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly,
	// for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32"
	// is not. The originating IP of a request must be in one of the
	// listed subnets in order for this Condition to be true.
	// If empty, all IP addresses are allowed.
	ipSubnetworks?: [...null | string] @go(IPSubnetworks,[]*string)

	// An allowed list of members (users, service accounts).
	// Using groups is not supported yet.
	// The signed-in user originating the request must be a part of one
	// of the provided members. If not specified, a request may come
	// from any user (logged in/not logged in, not present in any
	// groups, etc.).
	// Formats: user:{emailid}, serviceAccount:{emailid}
	members?: [...null | string] @go(Members,[]*string)

	// Whether to negate the Condition. If true, the Condition becomes
	// a NAND over its non-empty fields, each field must be false for
	// the Condition overall to be satisfied. Defaults to false.
	negate?: null | bool @go(Negate,*bool)

	// The request must originate from one of the provided
	// countries/regions.
	// Format: A valid ISO 3166-1 alpha-2 code.
	regions?: [...null | string] @go(Regions,[]*string)

	// A list of other access levels defined in the same Policy,
	// referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be
	// granted for the Condition to be true.
	// Format: accessPolicies/{policy_id}/accessLevels/{short_name}
	requiredAccessLevels?: [...null | string] @go(RequiredAccessLevels,[]*string)
}

#AccessLevelConditionObservation: {
	// The name of the Access Level to add this condition to.
	accessLevel?: null | string @go(AccessLevel,*string)

	// Device specific restrictions, all restrictions must hold for
	// the Condition to be true. If not specified, all devices are
	// allowed.
	// Structure is documented below.
	devicePolicy?: [...#AccessLevelConditionDevicePolicyObservation] @go(DevicePolicy,[]AccessLevelConditionDevicePolicyObservation)

	// an identifier for the resource with format {{access_level}}
	id?: null | string @go(ID,*string)

	// A list of CIDR block IP subnetwork specification. May be IPv4
	// or IPv6.
	// Note that for a CIDR IP address block, the specified IP address
	// portion must be properly truncated (i.e. all the host bits must
	// be zero) or the input is considered malformed. For example,
	// "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly,
	// for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32"
	// is not. The originating IP of a request must be in one of the
	// listed subnets in order for this Condition to be true.
	// If empty, all IP addresses are allowed.
	ipSubnetworks?: [...null | string] @go(IPSubnetworks,[]*string)

	// An allowed list of members (users, service accounts).
	// Using groups is not supported yet.
	// The signed-in user originating the request must be a part of one
	// of the provided members. If not specified, a request may come
	// from any user (logged in/not logged in, not present in any
	// groups, etc.).
	// Formats: user:{emailid}, serviceAccount:{emailid}
	members?: [...null | string] @go(Members,[]*string)

	// Whether to negate the Condition. If true, the Condition becomes
	// a NAND over its non-empty fields, each field must be false for
	// the Condition overall to be satisfied. Defaults to false.
	negate?: null | bool @go(Negate,*bool)

	// The request must originate from one of the provided
	// countries/regions.
	// Format: A valid ISO 3166-1 alpha-2 code.
	regions?: [...null | string] @go(Regions,[]*string)

	// A list of other access levels defined in the same Policy,
	// referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be
	// granted for the Condition to be true.
	// Format: accessPolicies/{policy_id}/accessLevels/{short_name}
	requiredAccessLevels?: [...null | string] @go(RequiredAccessLevels,[]*string)
}

#AccessLevelConditionParameters: {
	// The name of the Access Level to add this condition to.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/accesscontextmanager/v1beta1.AccessLevel
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	accessLevel?: null | string @go(AccessLevel,*string)

	// Device specific restrictions, all restrictions must hold for
	// the Condition to be true. If not specified, all devices are
	// allowed.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	devicePolicy?: [...#AccessLevelConditionDevicePolicyParameters] @go(DevicePolicy,[]AccessLevelConditionDevicePolicyParameters)

	// A list of CIDR block IP subnetwork specification. May be IPv4
	// or IPv6.
	// Note that for a CIDR IP address block, the specified IP address
	// portion must be properly truncated (i.e. all the host bits must
	// be zero) or the input is considered malformed. For example,
	// "192.0.2.0/24" is accepted but "192.0.2.1/24" is not. Similarly,
	// for IPv6, "2001:db8::/32" is accepted whereas "2001:db8::1/32"
	// is not. The originating IP of a request must be in one of the
	// listed subnets in order for this Condition to be true.
	// If empty, all IP addresses are allowed.
	// +kubebuilder:validation:Optional
	ipSubnetworks?: [...null | string] @go(IPSubnetworks,[]*string)

	// An allowed list of members (users, service accounts).
	// Using groups is not supported yet.
	// The signed-in user originating the request must be a part of one
	// of the provided members. If not specified, a request may come
	// from any user (logged in/not logged in, not present in any
	// groups, etc.).
	// Formats: user:{emailid}, serviceAccount:{emailid}
	// +kubebuilder:validation:Optional
	members?: [...null | string] @go(Members,[]*string)

	// Whether to negate the Condition. If true, the Condition becomes
	// a NAND over its non-empty fields, each field must be false for
	// the Condition overall to be satisfied. Defaults to false.
	// +kubebuilder:validation:Optional
	negate?: null | bool @go(Negate,*bool)

	// The request must originate from one of the provided
	// countries/regions.
	// Format: A valid ISO 3166-1 alpha-2 code.
	// +kubebuilder:validation:Optional
	regions?: [...null | string] @go(Regions,[]*string)

	// A list of other access levels defined in the same Policy,
	// referenced by resource name. Referencing an AccessLevel which
	// does not exist is an error. All access levels listed must be
	// granted for the Condition to be true.
	// Format: accessPolicies/{policy_id}/accessLevels/{short_name}
	// +kubebuilder:validation:Optional
	requiredAccessLevels?: [...null | string] @go(RequiredAccessLevels,[]*string)
}

#DevicePolicyOsConstraintsInitParameters: {
	// The minimum allowed OS version. If not set, any version
	// of this OS satisfies the constraint.
	// Format: "major.minor.patch" such as "10.5.301", "9.2.1".
	minimumVersion?: null | string @go(MinimumVersion,*string)

	// The operating system type of the device.
	// Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
	osType?: null | string @go(OsType,*string)
}

#DevicePolicyOsConstraintsObservation: {
	// The minimum allowed OS version. If not set, any version
	// of this OS satisfies the constraint.
	// Format: "major.minor.patch" such as "10.5.301", "9.2.1".
	minimumVersion?: null | string @go(MinimumVersion,*string)

	// The operating system type of the device.
	// Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
	osType?: null | string @go(OsType,*string)
}

#DevicePolicyOsConstraintsParameters: {
	// The minimum allowed OS version. If not set, any version
	// of this OS satisfies the constraint.
	// Format: "major.minor.patch" such as "10.5.301", "9.2.1".
	// +kubebuilder:validation:Optional
	minimumVersion?: null | string @go(MinimumVersion,*string)

	// The operating system type of the device.
	// Possible values are: OS_UNSPECIFIED, DESKTOP_MAC, DESKTOP_WINDOWS, DESKTOP_LINUX, DESKTOP_CHROME_OS, ANDROID, IOS.
	// +kubebuilder:validation:Optional
	osType?: null | string @go(OsType,*string)
}

// AccessLevelConditionSpec defines the desired state of AccessLevelCondition
#AccessLevelConditionSpec: {
	forProvider: #AccessLevelConditionParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #AccessLevelConditionInitParameters @go(InitProvider)
}

// AccessLevelConditionStatus defines the observed state of AccessLevelCondition.
#AccessLevelConditionStatus: {
	atProvider?: #AccessLevelConditionObservation @go(AtProvider)
}

// AccessLevelCondition is the Schema for the AccessLevelConditions API. Allows configuring a single access level condition to be appended to an access level's conditions.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#AccessLevelCondition: {
	spec:    #AccessLevelConditionSpec   @go(Spec)
	status?: #AccessLevelConditionStatus @go(Status)
}

// AccessLevelConditionList contains a list of AccessLevelConditions
#AccessLevelConditionList: {
	items: [...#AccessLevelCondition] @go(Items,[]AccessLevelCondition)
}
