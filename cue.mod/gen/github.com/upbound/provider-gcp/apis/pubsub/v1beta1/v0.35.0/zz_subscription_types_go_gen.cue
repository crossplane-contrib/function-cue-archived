// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/pubsub/v1beta1

package v1beta1

#BigqueryConfigInitParameters: {
	// When true and useTopicSchema is true, any fields that are a part of the topic schema that are not part of the BigQuery table schema are dropped when writing to BigQuery.
	// Otherwise, the schemas must be kept in sync and any messages with extra fields are not written and remain in the subscription's backlog.
	dropUnknownFields?: null | bool @go(DropUnknownFields,*bool)

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	table?: null | string @go(Table,*string)

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	useTopicSchema?: null | bool @go(UseTopicSchema,*bool)

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	writeMetadata?: null | bool @go(WriteMetadata,*bool)
}

#BigqueryConfigObservation: {
	// When true and useTopicSchema is true, any fields that are a part of the topic schema that are not part of the BigQuery table schema are dropped when writing to BigQuery.
	// Otherwise, the schemas must be kept in sync and any messages with extra fields are not written and remain in the subscription's backlog.
	dropUnknownFields?: null | bool @go(DropUnknownFields,*bool)

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	table?: null | string @go(Table,*string)

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	useTopicSchema?: null | bool @go(UseTopicSchema,*bool)

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	writeMetadata?: null | bool @go(WriteMetadata,*bool)
}

#BigqueryConfigParameters: {
	// When true and useTopicSchema is true, any fields that are a part of the topic schema that are not part of the BigQuery table schema are dropped when writing to BigQuery.
	// Otherwise, the schemas must be kept in sync and any messages with extra fields are not written and remain in the subscription's backlog.
	// +kubebuilder:validation:Optional
	dropUnknownFields?: null | bool @go(DropUnknownFields,*bool)

	// The name of the table to which to write data, of the form {projectId}:{datasetId}.{tableId}
	// +kubebuilder:validation:Optional
	table?: null | string @go(Table,*string)

	// When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
	// +kubebuilder:validation:Optional
	useTopicSchema?: null | bool @go(UseTopicSchema,*bool)

	// When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
	// The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
	// +kubebuilder:validation:Optional
	writeMetadata?: null | bool @go(WriteMetadata,*bool)
}

#DeadLetterPolicyInitParameters: {
	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	maxDeliveryAttempts?: null | float64 @go(MaxDeliveryAttempts,*float64)
}

#DeadLetterPolicyObservation: {
	// The name of the topic to which dead letter messages should be published.
	// Format is projects/{project}/topics/{topic}.
	// The Cloud Pub/Sub service account associated with the enclosing subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Publish() to this topic.
	// The operation will fail if the topic does not exist.
	// Users should ensure that there is a subscription attached to this topic
	// since messages published to a topic with no subscriptions are lost.
	deadLetterTopic?: null | string @go(DeadLetterTopic,*string)

	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	maxDeliveryAttempts?: null | float64 @go(MaxDeliveryAttempts,*float64)
}

#DeadLetterPolicyParameters: {
	// The name of the topic to which dead letter messages should be published.
	// Format is projects/{project}/topics/{topic}.
	// The Cloud Pub/Sub service account associated with the enclosing subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Publish() to this topic.
	// The operation will fail if the topic does not exist.
	// Users should ensure that there is a subscription attached to this topic
	// since messages published to a topic with no subscriptions are lost.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/pubsub/v1beta1.Topic
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	deadLetterTopic?: null | string @go(DeadLetterTopic,*string)

	// The maximum number of delivery attempts for any message. The value must be
	// between 5 and 100.
	// The number of delivery attempts is defined as 1 + (the sum of number of
	// NACKs and number of times the acknowledgement deadline has been exceeded for the message).
	// A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
	// client libraries may automatically extend ack_deadlines.
	// This field will be honored on a best effort basis.
	// If this parameter is 0, a default value of 5 is used.
	// +kubebuilder:validation:Optional
	maxDeliveryAttempts?: null | float64 @go(MaxDeliveryAttempts,*float64)
}

#ExpirationPolicyInitParameters: {
	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	ttl?: null | string @go(TTL,*string)
}

#ExpirationPolicyObservation: {
	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	ttl?: null | string @go(TTL,*string)
}

#ExpirationPolicyParameters: {
	// Specifies the "time-to-live" duration for an associated resource. The
	// resource expires if it is not active for a period of ttl.
	// If ttl is set to "", the associated resource never expires.
	// A duration in seconds with up to nine fractional digits, terminated by 's'.
	// Example - "3.5s".
	// +kubebuilder:validation:Optional
	ttl?: null | string @go(TTL,*string)
}

#OidcTokenInitParameters: {
	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	audience?: null | string @go(Audience,*string)

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	serviceAccountEmail?: null | string @go(ServiceAccountEmail,*string)
}

#OidcTokenObservation: {
	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	audience?: null | string @go(Audience,*string)

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	serviceAccountEmail?: null | string @go(ServiceAccountEmail,*string)
}

#OidcTokenParameters: {
	// Audience to be used when generating OIDC token. The audience claim
	// identifies the recipients that the JWT is intended for. The audience
	// value is a single case-sensitive string. Having multiple values (array)
	// for the audience field is not supported. More info about the OIDC JWT
	// token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
	// Note: if not specified, the Push endpoint URL will be used.
	// +kubebuilder:validation:Optional
	audience?: null | string @go(Audience,*string)

	// Service account email to be used for generating the OIDC token.
	// The caller (for subscriptions.create, subscriptions.patch, and
	// subscriptions.modifyPushConfig RPCs) must have the
	// iam.serviceAccounts.actAs permission for the service account.
	// +kubebuilder:validation:Optional
	serviceAccountEmail?: null | string @go(ServiceAccountEmail,*string)
}

#PushConfigInitParameters: {
	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	oidcToken?: [...#OidcTokenInitParameters] @go(OidcToken,[]OidcTokenInitParameters)

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	pushEndpoint?: null | string @go(PushEndpoint,*string)
}

#PushConfigObservation: {
	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	oidcToken?: [...#OidcTokenObservation] @go(OidcToken,[]OidcTokenObservation)

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	pushEndpoint?: null | string @go(PushEndpoint,*string)
}

#PushConfigParameters: {
	// Endpoint configuration attributes.
	// Every endpoint has a set of API supported attributes that can
	// be used to control different aspects of the message delivery.
	// The currently supported attribute is x-goog-version, which you
	// can use to change the format of the pushed message. This
	// attribute indicates the version of the data expected by
	// the endpoint. This controls the shape of the pushed message
	// (i.e., its fields and metadata). The endpoint version is
	// based on the version of the Pub/Sub API.
	// If not present during the subscriptions.create call,
	// it will default to the version of the API used to make
	// such call. If not present during a subscriptions.modifyPushConfig
	// call, its value will not be changed. subscriptions.get
	// calls will always return a valid version, even if the
	// subscription was created without this attribute.
	// The possible values for this attribute are:
	// +kubebuilder:validation:Optional
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// If specified, Pub/Sub will generate and attach an OIDC JWT token as
	// an Authorization header in the HTTP request for every pushed message.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	oidcToken?: [...#OidcTokenParameters] @go(OidcToken,[]OidcTokenParameters)

	// A URL locating the endpoint to which messages should be pushed.
	// For example, a Webhook endpoint might use
	// "https://example.com/push".
	// +kubebuilder:validation:Optional
	pushEndpoint?: null | string @go(PushEndpoint,*string)
}

#RetryPolicyInitParameters: {
	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	maximumBackoff?: null | string @go(MaximumBackoff,*string)

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	minimumBackoff?: null | string @go(MinimumBackoff,*string)
}

#RetryPolicyObservation: {
	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	maximumBackoff?: null | string @go(MaximumBackoff,*string)

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	minimumBackoff?: null | string @go(MinimumBackoff,*string)
}

#RetryPolicyParameters: {
	// The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	maximumBackoff?: null | string @go(MaximumBackoff,*string)

	// The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	minimumBackoff?: null | string @go(MinimumBackoff,*string)
}

#SubscriptionInitParameters: {
	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	ackDeadlineSeconds?: null | float64 @go(AckDeadlineSeconds,*float64)

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig or bigQueryConfig can be set, but not both.
	// If both are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	bigqueryConfig?: [...#BigqueryConfigInitParameters] @go(BigqueryConfig,[]BigqueryConfigInitParameters)

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	deadLetterPolicy?: [...#DeadLetterPolicyInitParameters] @go(DeadLetterPolicy,[]DeadLetterPolicyInitParameters)

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	enableExactlyOnceDelivery?: null | bool @go(EnableExactlyOnceDelivery,*bool)

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	enableMessageOrdering?: null | bool @go(EnableMessageOrdering,*bool)

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	expirationPolicy?: [...#ExpirationPolicyInitParameters] @go(ExpirationPolicy,[]ExpirationPolicyInitParameters)

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	filter?: null | string @go(Filter,*string)

	// A set of key/value label pairs to assign to this Subscription.
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	messageRetentionDuration?: null | string @go(MessageRetentionDuration,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	pushConfig?: [...#PushConfigInitParameters] @go(PushConfig,[]PushConfigInitParameters)

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	retainAckedMessages?: null | bool @go(RetainAckedMessages,*bool)

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	retryPolicy?: [...#RetryPolicyInitParameters] @go(RetryPolicy,[]RetryPolicyInitParameters)
}

#SubscriptionObservation: {
	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	ackDeadlineSeconds?: null | float64 @go(AckDeadlineSeconds,*float64)

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig or bigQueryConfig can be set, but not both.
	// If both are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	bigqueryConfig?: [...#BigqueryConfigObservation] @go(BigqueryConfig,[]BigqueryConfigObservation)

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	deadLetterPolicy?: [...#DeadLetterPolicyObservation] @go(DeadLetterPolicy,[]DeadLetterPolicyObservation)

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	enableExactlyOnceDelivery?: null | bool @go(EnableExactlyOnceDelivery,*bool)

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	enableMessageOrdering?: null | bool @go(EnableMessageOrdering,*bool)

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	expirationPolicy?: [...#ExpirationPolicyObservation] @go(ExpirationPolicy,[]ExpirationPolicyObservation)

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	filter?: null | string @go(Filter,*string)

	// an identifier for the resource with format projects/{{project}}/subscriptions/{{name}}
	id?: null | string @go(ID,*string)

	// A set of key/value label pairs to assign to this Subscription.
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	messageRetentionDuration?: null | string @go(MessageRetentionDuration,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	pushConfig?: [...#PushConfigObservation] @go(PushConfig,[]PushConfigObservation)

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	retainAckedMessages?: null | bool @go(RetainAckedMessages,*bool)

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	retryPolicy?: [...#RetryPolicyObservation] @go(RetryPolicy,[]RetryPolicyObservation)

	// A reference to a Topic resource.
	topic?: null | string @go(Topic,*string)
}

#SubscriptionParameters: {
	// This value is the maximum time after a subscriber receives a message
	// before the subscriber should acknowledge the message. After message
	// delivery but before the ack deadline expires and before the message is
	// acknowledged, it is an outstanding message and will not be delivered
	// again during that time (on a best-effort basis).
	// For pull subscriptions, this value is used as the initial value for
	// the ack deadline. To override this value for a given message, call
	// subscriptions.modifyAckDeadline with the corresponding ackId if using
	// pull. The minimum custom deadline you can specify is 10 seconds. The
	// maximum custom deadline you can specify is 600 seconds (10 minutes).
	// If this parameter is 0, a default value of 10 seconds is used.
	// For push delivery, this value is also used to set the request timeout
	// for the call to the push endpoint.
	// If the subscriber never acknowledges the message, the Pub/Sub system
	// will eventually redeliver the message.
	// +kubebuilder:validation:Optional
	ackDeadlineSeconds?: null | float64 @go(AckDeadlineSeconds,*float64)

	// If delivery to BigQuery is used with this subscription, this field is used to configure it.
	// Either pushConfig or bigQueryConfig can be set, but not both.
	// If both are empty, then the subscriber will pull and ack messages using API methods.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	bigqueryConfig?: [...#BigqueryConfigParameters] @go(BigqueryConfig,[]BigqueryConfigParameters)

	// A policy that specifies the conditions for dead lettering messages in
	// this subscription. If dead_letter_policy is not set, dead lettering
	// is disabled.
	// The Cloud Pub/Sub service account associated with this subscription's
	// parent project (i.e.,
	// service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
	// permission to Acknowledge() messages on this subscription.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	deadLetterPolicy?: [...#DeadLetterPolicyParameters] @go(DeadLetterPolicy,[]DeadLetterPolicyParameters)

	// If true, Pub/Sub provides the following guarantees for the delivery
	// of a message with a given value of messageId on this Subscriptions':
	// +kubebuilder:validation:Optional
	enableExactlyOnceDelivery?: null | bool @go(EnableExactlyOnceDelivery,*bool)

	// If true, messages published with the same orderingKey in PubsubMessage will be delivered to
	// the subscribers in the order in which they are received by the Pub/Sub system. Otherwise, they
	// may be delivered in any order.
	// +kubebuilder:validation:Optional
	enableMessageOrdering?: null | bool @go(EnableMessageOrdering,*bool)

	// A policy that specifies the conditions for this subscription's expiration.
	// A subscription is considered active as long as any connected subscriber
	// is successfully consuming messages from the subscription or is issuing
	// operations on the subscription. If expirationPolicy is not set, a default
	// policy with ttl of 31 days will be used.  If it is set but ttl is "", the
	// resource never expires.  The minimum allowed value for expirationPolicy.ttl
	// is 1 day.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	expirationPolicy?: [...#ExpirationPolicyParameters] @go(ExpirationPolicy,[]ExpirationPolicyParameters)

	// The subscription only delivers the messages that match the filter.
	// Pub/Sub automatically acknowledges the messages that don't match the filter. You can filter messages
	// by their attributes. The maximum length of a filter is 256 bytes. After creating the subscription,
	// you can't modify the filter.
	// +kubebuilder:validation:Optional
	filter?: null | string @go(Filter,*string)

	// A set of key/value label pairs to assign to this Subscription.
	// +kubebuilder:validation:Optional
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// How long to retain unacknowledged messages in the subscription's
	// backlog, from the moment a message is published. If
	// retain_acked_messages is true, then this also configures the retention
	// of acknowledged messages, and thus configures how far back in time a
	// subscriptions.seek can be done. Defaults to 7 days. Cannot be more
	// than 7 days ("604800s") or less than 10 minutes ("600s").
	// A duration in seconds with up to nine fractional digits, terminated
	// by 's'. Example: "600.5s".
	// +kubebuilder:validation:Optional
	messageRetentionDuration?: null | string @go(MessageRetentionDuration,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// If push delivery is used with this subscription, this field is used to
	// configure it. An empty pushConfig signifies that the subscriber will
	// pull and ack messages using API methods.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	pushConfig?: [...#PushConfigParameters] @go(PushConfig,[]PushConfigParameters)

	// Indicates whether to retain acknowledged messages. If true, then
	// messages are not expunged from the subscription's backlog, even if
	// they are acknowledged, until they fall out of the
	// messageRetentionDuration window.
	// +kubebuilder:validation:Optional
	retainAckedMessages?: null | bool @go(RetainAckedMessages,*bool)

	// A policy that specifies how Pub/Sub retries message delivery for this subscription.
	// If not set, the default retry policy is applied. This generally implies that messages will be retried as soon as possible for healthy subscribers.
	// RetryPolicy will be triggered on NACKs or acknowledgement deadline exceeded events for a given message
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#RetryPolicyParameters] @go(RetryPolicy,[]RetryPolicyParameters)

	// A reference to a Topic resource.
	// +crossplane:generate:reference:type=Topic
	// +kubebuilder:validation:Optional
	topic?: null | string @go(Topic,*string)
}

// SubscriptionSpec defines the desired state of Subscription
#SubscriptionSpec: {
	forProvider: #SubscriptionParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #SubscriptionInitParameters @go(InitProvider)
}

// SubscriptionStatus defines the observed state of Subscription.
#SubscriptionStatus: {
	atProvider?: #SubscriptionObservation @go(AtProvider)
}

// Subscription is the Schema for the Subscriptions API. A named resource representing the stream of messages from a single, specific topic, to be delivered to the subscribing application.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#Subscription: {
	spec:    #SubscriptionSpec   @go(Spec)
	status?: #SubscriptionStatus @go(Status)
}

// SubscriptionList contains a list of Subscriptions
#SubscriptionList: {
	items: [...#Subscription] @go(Items,[]Subscription)
}
