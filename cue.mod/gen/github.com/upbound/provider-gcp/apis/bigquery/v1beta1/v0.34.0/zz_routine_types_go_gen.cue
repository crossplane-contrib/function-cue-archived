// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/bigquery/v1beta1

package v1beta1

#ArgumentsObservation: {
	// Defaults to FIXED_TYPE.
	// Default value is FIXED_TYPE.
	// Possible values are: FIXED_TYPE, ANY_TYPE.
	argumentKind?: null | string @go(ArgumentKind,*string)

	// A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
	// ~>NOTE: Because this field expects a JSON string, any changes to the string
	// will create a diff, even if the JSON itself hasn't changed. If the API returns
	// a different value for the same schema, e.g. it switched the order of values
	// or replaced STRUCT field type with RECORD field type, we currently cannot
	// suppress the recurring diff this causes. As a workaround, we recommend using
	// the schema as returned by the API.
	dataType?: null | string @go(DataType,*string)

	// Specifies whether the argument is input or output. Can be set for procedures only.
	// Possible values are: IN, OUT, INOUT.
	mode?: null | string @go(Mode,*string)

	// The name of this argument. Can be absent for function return argument.
	name?: null | string @go(Name,*string)
}

#ArgumentsParameters: {
	// Defaults to FIXED_TYPE.
	// Default value is FIXED_TYPE.
	// Possible values are: FIXED_TYPE, ANY_TYPE.
	// +kubebuilder:validation:Optional
	argumentKind?: null | string @go(ArgumentKind,*string)

	// A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
	// ~>NOTE: Because this field expects a JSON string, any changes to the string
	// will create a diff, even if the JSON itself hasn't changed. If the API returns
	// a different value for the same schema, e.g. it switched the order of values
	// or replaced STRUCT field type with RECORD field type, we currently cannot
	// suppress the recurring diff this causes. As a workaround, we recommend using
	// the schema as returned by the API.
	// +kubebuilder:validation:Optional
	dataType?: null | string @go(DataType,*string)

	// Specifies whether the argument is input or output. Can be set for procedures only.
	// Possible values are: IN, OUT, INOUT.
	// +kubebuilder:validation:Optional
	mode?: null | string @go(Mode,*string)

	// The name of this argument. Can be absent for function return argument.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#RoutineObservation_2: {
	// Input/output argument of a function or a stored procedure.
	// Structure is documented below.
	arguments?: [...#ArgumentsObservation] @go(Arguments,[]ArgumentsObservation)

	// The time when this routine was created, in milliseconds since the
	// epoch.
	creationTime?: null | float64 @go(CreationTime,*float64)

	// The ID of the dataset containing this routine
	datasetId?: null | string @go(DatasetID,*string)

	// The body of the routine. For functions, this is the expression in the AS clause.
	// If language=SQL, it is the substring inside (but excluding) the parentheses.
	definitionBody?: null | string @go(DefinitionBody,*string)

	// The description of the routine if defined.
	description?: null | string @go(Description,*string)

	// The determinism level of the JavaScript UDF if defined.
	// Possible values are: DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, NOT_DETERMINISTIC.
	determinismLevel?: null | string @go(DeterminismLevel,*string)

	// an identifier for the resource with format projects/{{project}}/datasets/{{dataset_id}}/routines/{{routine_id}}
	id?: null | string @go(ID,*string)

	// Optional. If language = "JAVASCRIPT", this field stores the path of the
	// imported JAVASCRIPT libraries.
	importedLibraries?: [...null | string] @go(ImportedLibraries,[]*string)

	// The language of the routine.
	// Possible values are: SQL, JAVASCRIPT.
	language?: null | string @go(Language,*string)

	// The time when this routine was modified, in milliseconds since the
	// epoch.
	lastModifiedTime?: null | float64 @go(LastModifiedTime,*float64)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION".
	// If absent, the return table type is inferred from definitionBody at query time in each query
	// that references this routine. If present, then the columns in the evaluated table result will
	// be cast to match the column types specificed in return table type, at query time.
	returnTableType?: null | string @go(ReturnTableType,*string)

	// A JSON schema for the return type. Optional if language = "SQL"; required otherwise.
	// If absent, the return type is inferred from definitionBody at query time in each query
	// that references this routine. If present, then the evaluated result will be cast to
	// the specified returned type at query time. ~>NOTE: Because this field expects a JSON
	// string, any changes to the string will create a diff, even if the JSON itself hasn't
	// changed. If the API returns a different value for the same schema, e.g. it switche
	// d the order of values or replaced STRUCT field type with RECORD field type, we currently
	// cannot suppress the recurring diff this causes. As a workaround, we recommend using
	// the schema as returned by the API.
	returnType?: null | string @go(ReturnType,*string)

	// The type of routine.
	// Possible values are: SCALAR_FUNCTION, PROCEDURE, TABLE_VALUED_FUNCTION.
	routineType?: null | string @go(RoutineType,*string)
}

#RoutineParameters_2: {
	// Input/output argument of a function or a stored procedure.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	arguments?: [...#ArgumentsParameters] @go(Arguments,[]ArgumentsParameters)

	// The ID of the dataset containing this routine
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/bigquery/v1beta1.Dataset
	// +kubebuilder:validation:Optional
	datasetId?: null | string @go(DatasetID,*string)

	// The body of the routine. For functions, this is the expression in the AS clause.
	// If language=SQL, it is the substring inside (but excluding) the parentheses.
	// +kubebuilder:validation:Optional
	definitionBody?: null | string @go(DefinitionBody,*string)

	// The description of the routine if defined.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// The determinism level of the JavaScript UDF if defined.
	// Possible values are: DETERMINISM_LEVEL_UNSPECIFIED, DETERMINISTIC, NOT_DETERMINISTIC.
	// +kubebuilder:validation:Optional
	determinismLevel?: null | string @go(DeterminismLevel,*string)

	// Optional. If language = "JAVASCRIPT", this field stores the path of the
	// imported JAVASCRIPT libraries.
	// +kubebuilder:validation:Optional
	importedLibraries?: [...null | string] @go(ImportedLibraries,[]*string)

	// The language of the routine.
	// Possible values are: SQL, JAVASCRIPT.
	// +kubebuilder:validation:Optional
	language?: null | string @go(Language,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// Optional. Can be set only if routineType = "TABLE_VALUED_FUNCTION".
	// If absent, the return table type is inferred from definitionBody at query time in each query
	// that references this routine. If present, then the columns in the evaluated table result will
	// be cast to match the column types specificed in return table type, at query time.
	// +kubebuilder:validation:Optional
	returnTableType?: null | string @go(ReturnTableType,*string)

	// A JSON schema for the return type. Optional if language = "SQL"; required otherwise.
	// If absent, the return type is inferred from definitionBody at query time in each query
	// that references this routine. If present, then the evaluated result will be cast to
	// the specified returned type at query time. ~>NOTE: Because this field expects a JSON
	// string, any changes to the string will create a diff, even if the JSON itself hasn't
	// changed. If the API returns a different value for the same schema, e.g. it switche
	// d the order of values or replaced STRUCT field type with RECORD field type, we currently
	// cannot suppress the recurring diff this causes. As a workaround, we recommend using
	// the schema as returned by the API.
	// +kubebuilder:validation:Optional
	returnType?: null | string @go(ReturnType,*string)

	// The type of routine.
	// Possible values are: SCALAR_FUNCTION, PROCEDURE, TABLE_VALUED_FUNCTION.
	// +kubebuilder:validation:Optional
	routineType?: null | string @go(RoutineType,*string)
}

// RoutineSpec defines the desired state of Routine
#RoutineSpec: {
	forProvider: #RoutineParameters_2 @go(ForProvider)
}

// RoutineStatus defines the observed state of Routine.
#RoutineStatus: {
	atProvider?: #RoutineObservation_2 @go(AtProvider)
}

// Routine is the Schema for the Routines API. A user-defined function or a stored procedure that belongs to a Dataset
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#Routine: {
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.definitionBody)",message="definitionBody is a required parameter"
	spec:    #RoutineSpec   @go(Spec)
	status?: #RoutineStatus @go(Status)
}

// RoutineList contains a list of Routines
#RoutineList: {
	items: [...#Routine] @go(Items,[]Routine)
}
