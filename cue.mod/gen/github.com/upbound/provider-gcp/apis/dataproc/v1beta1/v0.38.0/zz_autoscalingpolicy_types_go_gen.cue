// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/dataproc/v1beta1

package v1beta1

#AutoscalingPolicyInitParameters: {
	// Basic algorithm for autoscaling.
	// Structure is documented below.
	basicAlgorithm?: [...#BasicAlgorithmInitParameters] @go(BasicAlgorithm,[]BasicAlgorithmInitParameters)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// Describes how the autoscaler will operate for secondary workers.
	// Structure is documented below.
	secondaryWorkerConfig?: [...#SecondaryWorkerConfigInitParameters] @go(SecondaryWorkerConfig,[]SecondaryWorkerConfigInitParameters)

	// Describes how the autoscaler will operate for primary workers.
	// Structure is documented below.
	workerConfig?: [...#WorkerConfigInitParameters] @go(WorkerConfig,[]WorkerConfigInitParameters)
}

#AutoscalingPolicyObservation: {
	// Basic algorithm for autoscaling.
	// Structure is documented below.
	basicAlgorithm?: [...#BasicAlgorithmObservation] @go(BasicAlgorithm,[]BasicAlgorithmObservation)

	// an identifier for the resource with format projects/{{project}}/locations/{{location}}/autoscalingPolicies/{{policy_id}}
	id?: null | string @go(ID,*string)

	// The  location where the autoscaling policy should reside.
	// The default value is global.
	location?: null | string @go(Location,*string)

	// The "resource name" of the autoscaling policy.
	name?: null | string @go(Name,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// Describes how the autoscaler will operate for secondary workers.
	// Structure is documented below.
	secondaryWorkerConfig?: [...#SecondaryWorkerConfigObservation] @go(SecondaryWorkerConfig,[]SecondaryWorkerConfigObservation)

	// Describes how the autoscaler will operate for primary workers.
	// Structure is documented below.
	workerConfig?: [...#WorkerConfigObservation] @go(WorkerConfig,[]WorkerConfigObservation)
}

#AutoscalingPolicyParameters: {
	// Basic algorithm for autoscaling.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	basicAlgorithm?: [...#BasicAlgorithmParameters] @go(BasicAlgorithm,[]BasicAlgorithmParameters)

	// The  location where the autoscaling policy should reside.
	// The default value is global.
	// +kubebuilder:validation:Optional
	location?: null | string @go(Location,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// Describes how the autoscaler will operate for secondary workers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	secondaryWorkerConfig?: [...#SecondaryWorkerConfigParameters] @go(SecondaryWorkerConfig,[]SecondaryWorkerConfigParameters)

	// Describes how the autoscaler will operate for primary workers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	workerConfig?: [...#WorkerConfigParameters] @go(WorkerConfig,[]WorkerConfigParameters)
}

#BasicAlgorithmInitParameters: {
	// Duration between scaling events. A scaling period starts after the
	// update operation from the previous event has completed.
	// Bounds: [2m, 1d]. Default: 2m.
	cooldownPeriod?: null | string @go(CooldownPeriod,*string)

	// YARN autoscaling configuration.
	// Structure is documented below.
	yarnConfig?: [...#YarnConfigInitParameters] @go(YarnConfig,[]YarnConfigInitParameters)
}

#BasicAlgorithmObservation: {
	// Duration between scaling events. A scaling period starts after the
	// update operation from the previous event has completed.
	// Bounds: [2m, 1d]. Default: 2m.
	cooldownPeriod?: null | string @go(CooldownPeriod,*string)

	// YARN autoscaling configuration.
	// Structure is documented below.
	yarnConfig?: [...#YarnConfigObservation] @go(YarnConfig,[]YarnConfigObservation)
}

#BasicAlgorithmParameters: {
	// Duration between scaling events. A scaling period starts after the
	// update operation from the previous event has completed.
	// Bounds: [2m, 1d]. Default: 2m.
	// +kubebuilder:validation:Optional
	cooldownPeriod?: null | string @go(CooldownPeriod,*string)

	// YARN autoscaling configuration.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	yarnConfig: [...#YarnConfigParameters] @go(YarnConfig,[]YarnConfigParameters)
}

#SecondaryWorkerConfigInitParameters: {
	// Maximum number of instances for this group. Note that by default, clusters will not use
	// secondary workers. Required for secondary workers if the minimum secondary instances is set.
	// Bounds: [minInstances, ). Defaults to 0.
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [0, maxInstances]. Defaults to 0.
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	weight?: null | float64 @go(Weight,*float64)
}

#SecondaryWorkerConfigObservation: {
	// Maximum number of instances for this group. Note that by default, clusters will not use
	// secondary workers. Required for secondary workers if the minimum secondary instances is set.
	// Bounds: [minInstances, ). Defaults to 0.
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [0, maxInstances]. Defaults to 0.
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	weight?: null | float64 @go(Weight,*float64)
}

#SecondaryWorkerConfigParameters: {
	// Maximum number of instances for this group. Note that by default, clusters will not use
	// secondary workers. Required for secondary workers if the minimum secondary instances is set.
	// Bounds: [minInstances, ). Defaults to 0.
	// +kubebuilder:validation:Optional
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [0, maxInstances]. Defaults to 0.
	// +kubebuilder:validation:Optional
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

#WorkerConfigInitParameters: {
	// Maximum number of instances for this group.
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [2, maxInstances]. Defaults to 2.
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	weight?: null | float64 @go(Weight,*float64)
}

#WorkerConfigObservation: {
	// Maximum number of instances for this group.
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [2, maxInstances]. Defaults to 2.
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	weight?: null | float64 @go(Weight,*float64)
}

#WorkerConfigParameters: {
	// Maximum number of instances for this group.
	// +kubebuilder:validation:Optional
	maxInstances?: null | float64 @go(MaxInstances,*float64)

	// Minimum number of instances for this group. Bounds: [2, maxInstances]. Defaults to 2.
	// +kubebuilder:validation:Optional
	minInstances?: null | float64 @go(MinInstances,*float64)

	// Weight for the instance group, which is used to determine the fraction of total workers
	// in the cluster from this instance group. For example, if primary workers have weight 2,
	// and secondary workers have weight 1, the cluster will have approximately 2 primary workers
	// for each secondary worker.
	// The cluster may not reach the specified balance if constrained by min/max bounds or other
	// autoscaling settings. For example, if maxInstances for secondary workers is 0, then only
	// primary workers will be added. The cluster can also be out of balance when created.
	// If weight is not set on any instance group, the cluster will default to equal weight for
	// all groups: the cluster will attempt to maintain an equal number of workers in each group
	// within the configured size bounds for each group. If weight is set for one group only,
	// the cluster will default to zero weight on the unset group. For example if weight is set
	// only on primary workers, the cluster will use primary workers only and no secondary workers.
	// +kubebuilder:validation:Optional
	weight?: null | float64 @go(Weight,*float64)
}

#YarnConfigInitParameters: {
	// Timeout for YARN graceful decommissioning of Node Managers. Specifies the
	// duration to wait for jobs to complete before forcefully removing workers
	// (and potentially interrupting jobs). Only applicable to downscaling operations.
	// Bounds: [0s, 1d].
	gracefulDecommissionTimeout?: null | string @go(GracefulDecommissionTimeout,*string)

	// Fraction of average pending memory in the last cooldown period for which to
	// remove workers. A scale-down factor of 1 will result in scaling down so that there
	// is no available memory remaining after the update (more aggressive scaling).
	// A scale-down factor of 0 disables removing workers, which can be beneficial for
	// autoscaling a single job.
	// Bounds: [0.0, 1.0].
	scaleDownFactor?: null | float64 @go(ScaleDownFactor,*float64)

	// Minimum scale-down threshold as a fraction of total cluster size before scaling occurs.
	// For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must
	// recommend at least a 2 worker scale-down for the cluster to scale. A threshold of 0
	// means the autoscaler will scale down on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	scaleDownMinWorkerFraction?: null | float64 @go(ScaleDownMinWorkerFraction,*float64)

	// Fraction of average pending memory in the last cooldown period for which to
	// add workers. A scale-up factor of 1.0 will result in scaling up so that there
	// is no pending memory remaining after the update (more aggressive scaling).
	// A scale-up factor closer to 0 will result in a smaller magnitude of scaling up
	// (less aggressive scaling).
	// Bounds: [0.0, 1.0].
	scaleUpFactor?: null | float64 @go(ScaleUpFactor,*float64)

	// Minimum scale-up threshold as a fraction of total cluster size before scaling
	// occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler
	// must recommend at least a 2-worker scale-up for the cluster to scale. A threshold of
	// 0 means the autoscaler will scale up on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	scaleUpMinWorkerFraction?: null | float64 @go(ScaleUpMinWorkerFraction,*float64)
}

#YarnConfigObservation: {
	// Timeout for YARN graceful decommissioning of Node Managers. Specifies the
	// duration to wait for jobs to complete before forcefully removing workers
	// (and potentially interrupting jobs). Only applicable to downscaling operations.
	// Bounds: [0s, 1d].
	gracefulDecommissionTimeout?: null | string @go(GracefulDecommissionTimeout,*string)

	// Fraction of average pending memory in the last cooldown period for which to
	// remove workers. A scale-down factor of 1 will result in scaling down so that there
	// is no available memory remaining after the update (more aggressive scaling).
	// A scale-down factor of 0 disables removing workers, which can be beneficial for
	// autoscaling a single job.
	// Bounds: [0.0, 1.0].
	scaleDownFactor?: null | float64 @go(ScaleDownFactor,*float64)

	// Minimum scale-down threshold as a fraction of total cluster size before scaling occurs.
	// For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must
	// recommend at least a 2 worker scale-down for the cluster to scale. A threshold of 0
	// means the autoscaler will scale down on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	scaleDownMinWorkerFraction?: null | float64 @go(ScaleDownMinWorkerFraction,*float64)

	// Fraction of average pending memory in the last cooldown period for which to
	// add workers. A scale-up factor of 1.0 will result in scaling up so that there
	// is no pending memory remaining after the update (more aggressive scaling).
	// A scale-up factor closer to 0 will result in a smaller magnitude of scaling up
	// (less aggressive scaling).
	// Bounds: [0.0, 1.0].
	scaleUpFactor?: null | float64 @go(ScaleUpFactor,*float64)

	// Minimum scale-up threshold as a fraction of total cluster size before scaling
	// occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler
	// must recommend at least a 2-worker scale-up for the cluster to scale. A threshold of
	// 0 means the autoscaler will scale up on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	scaleUpMinWorkerFraction?: null | float64 @go(ScaleUpMinWorkerFraction,*float64)
}

#YarnConfigParameters: {
	// Timeout for YARN graceful decommissioning of Node Managers. Specifies the
	// duration to wait for jobs to complete before forcefully removing workers
	// (and potentially interrupting jobs). Only applicable to downscaling operations.
	// Bounds: [0s, 1d].
	// +kubebuilder:validation:Optional
	gracefulDecommissionTimeout?: null | string @go(GracefulDecommissionTimeout,*string)

	// Fraction of average pending memory in the last cooldown period for which to
	// remove workers. A scale-down factor of 1 will result in scaling down so that there
	// is no available memory remaining after the update (more aggressive scaling).
	// A scale-down factor of 0 disables removing workers, which can be beneficial for
	// autoscaling a single job.
	// Bounds: [0.0, 1.0].
	// +kubebuilder:validation:Optional
	scaleDownFactor?: null | float64 @go(ScaleDownFactor,*float64)

	// Minimum scale-down threshold as a fraction of total cluster size before scaling occurs.
	// For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler must
	// recommend at least a 2 worker scale-down for the cluster to scale. A threshold of 0
	// means the autoscaler will scale down on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	// +kubebuilder:validation:Optional
	scaleDownMinWorkerFraction?: null | float64 @go(ScaleDownMinWorkerFraction,*float64)

	// Fraction of average pending memory in the last cooldown period for which to
	// add workers. A scale-up factor of 1.0 will result in scaling up so that there
	// is no pending memory remaining after the update (more aggressive scaling).
	// A scale-up factor closer to 0 will result in a smaller magnitude of scaling up
	// (less aggressive scaling).
	// Bounds: [0.0, 1.0].
	// +kubebuilder:validation:Optional
	scaleUpFactor?: null | float64 @go(ScaleUpFactor,*float64)

	// Minimum scale-up threshold as a fraction of total cluster size before scaling
	// occurs. For example, in a 20-worker cluster, a threshold of 0.1 means the autoscaler
	// must recommend at least a 2-worker scale-up for the cluster to scale. A threshold of
	// 0 means the autoscaler will scale up on any recommended change.
	// Bounds: [0.0, 1.0]. Default: 0.0.
	// +kubebuilder:validation:Optional
	scaleUpMinWorkerFraction?: null | float64 @go(ScaleUpMinWorkerFraction,*float64)
}

// AutoscalingPolicySpec defines the desired state of AutoscalingPolicy
#AutoscalingPolicySpec: {
	forProvider: #AutoscalingPolicyParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #AutoscalingPolicyInitParameters @go(InitProvider)
}

// AutoscalingPolicyStatus defines the observed state of AutoscalingPolicy.
#AutoscalingPolicyStatus: {
	atProvider?: #AutoscalingPolicyObservation @go(AtProvider)
}

// AutoscalingPolicy is the Schema for the AutoscalingPolicys API. Describes an autoscaling policy for Dataproc cluster autoscaler.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#AutoscalingPolicy: {
	spec:    #AutoscalingPolicySpec   @go(Spec)
	status?: #AutoscalingPolicyStatus @go(Status)
}

// AutoscalingPolicyList contains a list of AutoscalingPolicys
#AutoscalingPolicyList: {
	items: [...#AutoscalingPolicy] @go(Items,[]AutoscalingPolicy)
}
