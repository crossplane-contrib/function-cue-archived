// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/certificatemanager/v1beta1

package v1beta1

#AuthorizationAttemptInfoInitParameters: {
}

#AuthorizationAttemptInfoObservation: {
	// (Output)
	// Human readable explanation about the issue. Provided to help address
	// the configuration issues.
	// Not guaranteed to be stable. For programmatic access use reason field.
	details?: null | string @go(Details,*string)

	// (Output)
	// Domain name of the authorization attempt.
	domain?: null | string @go(Domain,*string)

	// (Output)
	// Reason for failure of the authorization attempt for the domain.
	failureReason?: null | string @go(FailureReason,*string)

	// (Output)
	// A state of this Managed Certificate.
	state?: null | string @go(State,*string)
}

#AuthorizationAttemptInfoParameters: {
}

#CertificateInitParameters: {
	// A human-readable description of the resource.
	description?: null | string @go(Description,*string)

	// Set of label tags associated with the Certificate resource.
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	managed?: [...#ManagedInitParameters] @go(Managed,[]ManagedInitParameters)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,
	// served from non-core Google data centers.
	// Currently allowed only for managed certificates.
	scope?: null | string @go(Scope,*string)

	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	selfManaged?: [...#SelfManagedInitParameters] @go(SelfManaged,[]SelfManagedInitParameters)
}

#CertificateObservation: {
	// A human-readable description of the resource.
	description?: null | string @go(Description,*string)

	// an identifier for the resource with format projects/{{project}}/locations/{{location}}/certificates/{{name}}
	id?: null | string @go(ID,*string)

	// Set of label tags associated with the Certificate resource.
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// The Certificate Manager location. If not specified, "global" is used.
	location?: null | string @go(Location,*string)

	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	managed?: [...#ManagedObservation] @go(Managed,[]ManagedObservation)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,
	// served from non-core Google data centers.
	// Currently allowed only for managed certificates.
	scope?: null | string @go(Scope,*string)

	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	selfManaged?: [...#SelfManagedObservation] @go(SelfManaged,[]SelfManagedObservation)
}

#CertificateParameters: {
	// A human-readable description of the resource.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// Set of label tags associated with the Certificate resource.
	// +kubebuilder:validation:Optional
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// The Certificate Manager location. If not specified, "global" is used.
	// +kubebuilder:validation:Optional
	location?: null | string @go(Location,*string)

	// Configuration and state of a Managed Certificate.
	// Certificate Manager provisions and renews Managed Certificates
	// automatically, for as long as it's authorized to do so.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	managed?: [...#ManagedParameters] @go(Managed,[]ManagedParameters)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// The scope of the certificate.
	// DEFAULT: Certificates with default scope are served from core Google data centers.
	// If unsure, choose this option.
	// EDGE_CACHE: Certificates with scope EDGE_CACHE are special-purposed certificates,
	// served from non-core Google data centers.
	// Currently allowed only for managed certificates.
	// +kubebuilder:validation:Optional
	scope?: null | string @go(Scope,*string)

	// Certificate data for a SelfManaged Certificate.
	// SelfManaged Certificates are uploaded by the user. Updating such
	// certificates before they expire remains the user's responsibility.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	selfManaged?: [...#SelfManagedParameters] @go(SelfManaged,[]SelfManagedParameters)
}

#ManagedInitParameters: {
	// Authorizations that will be used for performing domain authorization. Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	dnsAuthorizations?: [...null | string] @go(DNSAuthorizations,[]*string)

	// The domains for which a managed SSL certificate will be generated.
	// Wildcard domains are only supported with DNS challenge resolution
	domains?: [...null | string] @go(Domains,[]*string)

	// The resource name for a CertificateIssuanceConfig used to configure private PKI certificates in the format projects//locations//certificateIssuanceConfigs/*.
	// If this field is not set, the certificates will instead be publicly signed as documented at https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
	// Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	issuanceConfig?: null | string @go(IssuanceConfig,*string)
}

#ManagedObservation: {
	// (Output)
	// Detailed state of the latest authorization attempt for each domain
	// specified for this Managed Certificate.
	// Structure is documented below.
	authorizationAttemptInfo?: [...#AuthorizationAttemptInfoObservation] @go(AuthorizationAttemptInfo,[]AuthorizationAttemptInfoObservation)

	// Authorizations that will be used for performing domain authorization. Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	dnsAuthorizations?: [...null | string] @go(DNSAuthorizations,[]*string)

	// The domains for which a managed SSL certificate will be generated.
	// Wildcard domains are only supported with DNS challenge resolution
	domains?: [...null | string] @go(Domains,[]*string)

	// The resource name for a CertificateIssuanceConfig used to configure private PKI certificates in the format projects//locations//certificateIssuanceConfigs/*.
	// If this field is not set, the certificates will instead be publicly signed as documented at https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
	// Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	issuanceConfig?: null | string @go(IssuanceConfig,*string)

	// (Output)
	// Information about issues with provisioning this Managed Certificate.
	// Structure is documented below.
	provisioningIssue?: [...#ProvisioningIssueObservation] @go(ProvisioningIssue,[]ProvisioningIssueObservation)

	// (Output)
	// A state of this Managed Certificate.
	state?: null | string @go(State,*string)
}

#ManagedParameters: {
	// Authorizations that will be used for performing domain authorization. Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	// +kubebuilder:validation:Optional
	dnsAuthorizations?: [...null | string] @go(DNSAuthorizations,[]*string)

	// The domains for which a managed SSL certificate will be generated.
	// Wildcard domains are only supported with DNS challenge resolution
	// +kubebuilder:validation:Optional
	domains?: [...null | string] @go(Domains,[]*string)

	// The resource name for a CertificateIssuanceConfig used to configure private PKI certificates in the format projects//locations//certificateIssuanceConfigs/*.
	// If this field is not set, the certificates will instead be publicly signed as documented at https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
	// Either issuanceConfig or dnsAuthorizations should be specificed, but not both.
	// +kubebuilder:validation:Optional
	issuanceConfig?: null | string @go(IssuanceConfig,*string)
}

#ProvisioningIssueInitParameters: {
}

#ProvisioningIssueObservation: {
	// (Output)
	// Human readable explanation about the issue. Provided to help address
	// the configuration issues.
	// Not guaranteed to be stable. For programmatic access use reason field.
	details?: null | string @go(Details,*string)

	// (Output)
	// Reason for provisioning failures.
	reason?: null | string @go(Reason,*string)
}

#ProvisioningIssueParameters: {
}

#SelfManagedInitParameters: {
	// The certificate chain in PEM-encoded form.
	// Leaf certificate comes first, followed by intermediate ones if any.
	pemCertificate?: null | string @go(PemCertificate,*string)
}

#SelfManagedObservation: {
	// The certificate chain in PEM-encoded form.
	// Leaf certificate comes first, followed by intermediate ones if any.
	pemCertificate?: null | string @go(PemCertificate,*string)
}

#SelfManagedParameters: {
	// The certificate chain in PEM-encoded form.
	// Leaf certificate comes first, followed by intermediate ones if any.
	// +kubebuilder:validation:Optional
	pemCertificate?: null | string @go(PemCertificate,*string)
}

// CertificateSpec defines the desired state of Certificate
#CertificateSpec: {
	forProvider: #CertificateParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #CertificateInitParameters @go(InitProvider)
}

// CertificateStatus defines the observed state of Certificate.
#CertificateStatus: {
	atProvider?: #CertificateObservation @go(AtProvider)
}

// Certificate is the Schema for the Certificates API. Certificate represents a HTTP-reachable backend for a Certificate.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#Certificate: {
	spec:    #CertificateSpec   @go(Spec)
	status?: #CertificateStatus @go(Status)
}

// CertificateList contains a list of Certificates
#CertificateList: {
	items: [...#Certificate] @go(Items,[]Certificate)
}
