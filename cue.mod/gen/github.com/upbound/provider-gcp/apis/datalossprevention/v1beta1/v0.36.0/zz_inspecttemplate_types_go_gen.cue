// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/datalossprevention/v1beta1

package v1beta1

#CloudStoragePathInitParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#CloudStoragePathObservation: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#CloudStoragePathParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)
}

#CustomInfoTypesInitParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#DictionaryInitParameters] @go(Dictionary,[]DictionaryInitParameters)

	// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
	// Possible values are: EXCLUSION_TYPE_EXCLUDE.
	exclusionType?: null | string @go(ExclusionType,*string)

	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#InfoTypeInitParameters] @go(InfoType,[]InfoTypeInitParameters)

	// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
	// specified by the rule.
	// Default value is VERY_LIKELY.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	likelihood?: null | string @go(Likelihood,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#RegexInitParameters] @go(Regex,[]RegexInitParameters)

	// A reference to a StoredInfoType to use with scanning.
	// Structure is documented below.
	storedType?: [...#StoredTypeInitParameters] @go(StoredType,[]StoredTypeInitParameters)

	// Message for detecting output from deidentification transformations that support reversing.
	surrogateType?: [...#SurrogateTypeInitParameters] @go(SurrogateType,[]SurrogateTypeInitParameters)
}

#CustomInfoTypesObservation: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#DictionaryObservation] @go(Dictionary,[]DictionaryObservation)

	// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
	// Possible values are: EXCLUSION_TYPE_EXCLUDE.
	exclusionType?: null | string @go(ExclusionType,*string)

	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#InfoTypeObservation] @go(InfoType,[]InfoTypeObservation)

	// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
	// specified by the rule.
	// Default value is VERY_LIKELY.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	likelihood?: null | string @go(Likelihood,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#RegexObservation] @go(Regex,[]RegexObservation)

	// A reference to a StoredInfoType to use with scanning.
	// Structure is documented below.
	storedType?: [...#StoredTypeObservation] @go(StoredType,[]StoredTypeObservation)

	// Message for detecting output from deidentification transformations that support reversing.
	surrogateType?: [...#SurrogateTypeParameters] @go(SurrogateType,[]SurrogateTypeParameters)
}

#CustomInfoTypesParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	dictionary?: [...#DictionaryParameters] @go(Dictionary,[]DictionaryParameters)

	// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
	// Possible values are: EXCLUSION_TYPE_EXCLUDE.
	// +kubebuilder:validation:Optional
	exclusionType?: null | string @go(ExclusionType,*string)

	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoType: [...#InfoTypeParameters] @go(InfoType,[]InfoTypeParameters)

	// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
	// specified by the rule.
	// Default value is VERY_LIKELY.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	likelihood?: null | string @go(Likelihood,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	regex?: [...#RegexParameters] @go(Regex,[]RegexParameters)

	// A reference to a StoredInfoType to use with scanning.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	storedType?: [...#StoredTypeParameters] @go(StoredType,[]StoredTypeParameters)

	// Message for detecting output from deidentification transformations that support reversing.
	// +kubebuilder:validation:Optional
	surrogateType?: [...#SurrogateTypeParameters] @go(SurrogateType,[]SurrogateTypeParameters)
}

#DictionaryCloudStoragePathInitParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#DictionaryCloudStoragePathObservation: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#DictionaryCloudStoragePathParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)
}

#DictionaryInitParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#CloudStoragePathInitParameters] @go(CloudStoragePath,[]CloudStoragePathInitParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#DictionaryWordListInitParameters] @go(WordList,[]DictionaryWordListInitParameters)
}

#DictionaryObservation: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#CloudStoragePathObservation] @go(CloudStoragePath,[]CloudStoragePathObservation)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#DictionaryWordListObservation] @go(WordList,[]DictionaryWordListObservation)
}

#DictionaryParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cloudStoragePath?: [...#CloudStoragePathParameters] @go(CloudStoragePath,[]CloudStoragePathParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	wordList?: [...#DictionaryWordListParameters] @go(WordList,[]DictionaryWordListParameters)
}

#DictionaryWordListInitParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#DictionaryWordListObservation: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#DictionaryWordListParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	// +kubebuilder:validation:Optional
	words: [...null | string] @go(Words,[]*string)
}

#ExcludeByHotwordInitParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#HotwordRegexInitParameters] @go(HotwordRegex,[]HotwordRegexInitParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#ProximityInitParameters] @go(Proximity,[]ProximityInitParameters)
}

#ExcludeByHotwordObservation: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#HotwordRegexObservation] @go(HotwordRegex,[]HotwordRegexObservation)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#ProximityObservation] @go(Proximity,[]ProximityObservation)
}

#ExcludeByHotwordParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRegex: [...#HotwordRegexParameters] @go(HotwordRegex,[]HotwordRegexParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	proximity: [...#ProximityParameters] @go(Proximity,[]ProximityParameters)
}

#ExcludeInfoTypesInfoTypesInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#ExcludeInfoTypesInfoTypesObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#ExcludeInfoTypesInfoTypesParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#ExcludeInfoTypesInitParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#ExcludeInfoTypesInfoTypesInitParameters] @go(InfoTypes,[]ExcludeInfoTypesInfoTypesInitParameters)
}

#ExcludeInfoTypesObservation: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#ExcludeInfoTypesInfoTypesObservation] @go(InfoTypes,[]ExcludeInfoTypesInfoTypesObservation)
}

#ExcludeInfoTypesParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoTypes: [...#ExcludeInfoTypesInfoTypesParameters] @go(InfoTypes,[]ExcludeInfoTypesInfoTypesParameters)
}

#ExclusionRuleDictionaryInitParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#DictionaryCloudStoragePathInitParameters] @go(CloudStoragePath,[]DictionaryCloudStoragePathInitParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#ExclusionRuleDictionaryWordListInitParameters] @go(WordList,[]ExclusionRuleDictionaryWordListInitParameters)
}

#ExclusionRuleDictionaryObservation: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#DictionaryCloudStoragePathObservation] @go(CloudStoragePath,[]DictionaryCloudStoragePathObservation)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#ExclusionRuleDictionaryWordListObservation] @go(WordList,[]ExclusionRuleDictionaryWordListObservation)
}

#ExclusionRuleDictionaryParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cloudStoragePath?: [...#DictionaryCloudStoragePathParameters] @go(CloudStoragePath,[]DictionaryCloudStoragePathParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	wordList?: [...#ExclusionRuleDictionaryWordListParameters] @go(WordList,[]ExclusionRuleDictionaryWordListParameters)
}

#ExclusionRuleDictionaryWordListInitParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#ExclusionRuleDictionaryWordListObservation: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#ExclusionRuleDictionaryWordListParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	// +kubebuilder:validation:Optional
	words: [...null | string] @go(Words,[]*string)
}

#ExclusionRuleInitParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#ExclusionRuleDictionaryInitParameters] @go(Dictionary,[]ExclusionRuleDictionaryInitParameters)

	// Drop if the hotword rule is contained in the proximate context.
	// For tabular data, the context includes the column name.
	// Structure is documented below.
	excludeByHotword?: [...#ExcludeByHotwordInitParameters] @go(ExcludeByHotword,[]ExcludeByHotwordInitParameters)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: [...#ExcludeInfoTypesInitParameters] @go(ExcludeInfoTypes,[]ExcludeInfoTypesInitParameters)

	// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
	// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
	matchingType?: null | string @go(MatchingType,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#ExclusionRuleRegexInitParameters] @go(Regex,[]ExclusionRuleRegexInitParameters)
}

#ExclusionRuleObservation: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#ExclusionRuleDictionaryObservation] @go(Dictionary,[]ExclusionRuleDictionaryObservation)

	// Drop if the hotword rule is contained in the proximate context.
	// For tabular data, the context includes the column name.
	// Structure is documented below.
	excludeByHotword?: [...#ExcludeByHotwordObservation] @go(ExcludeByHotword,[]ExcludeByHotwordObservation)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: [...#ExcludeInfoTypesObservation] @go(ExcludeInfoTypes,[]ExcludeInfoTypesObservation)

	// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
	// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
	matchingType?: null | string @go(MatchingType,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#ExclusionRuleRegexObservation] @go(Regex,[]ExclusionRuleRegexObservation)
}

#ExclusionRuleParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	dictionary?: [...#ExclusionRuleDictionaryParameters] @go(Dictionary,[]ExclusionRuleDictionaryParameters)

	// Drop if the hotword rule is contained in the proximate context.
	// For tabular data, the context includes the column name.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	excludeByHotword?: [...#ExcludeByHotwordParameters] @go(ExcludeByHotword,[]ExcludeByHotwordParameters)

	// When true, excludes type information of the findings.
	// +kubebuilder:validation:Optional
	excludeInfoTypes?: [...#ExcludeInfoTypesParameters] @go(ExcludeInfoTypes,[]ExcludeInfoTypesParameters)

	// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
	// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
	// +kubebuilder:validation:Optional
	matchingType?: null | string @go(MatchingType,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	regex?: [...#ExclusionRuleRegexParameters] @go(Regex,[]ExclusionRuleRegexParameters)
}

#ExclusionRuleRegexInitParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#ExclusionRuleRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#ExclusionRuleRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRegexInitParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRuleHotwordRegexInitParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRuleHotwordRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRuleHotwordRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#HotwordRuleInitParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#HotwordRuleHotwordRegexInitParameters] @go(HotwordRegex,[]HotwordRuleHotwordRegexInitParameters)

	// Likelihood adjustment to apply to all matching findings.
	// Structure is documented below.
	likelihoodAdjustment?: [...#LikelihoodAdjustmentInitParameters] @go(LikelihoodAdjustment,[]LikelihoodAdjustmentInitParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#HotwordRuleProximityInitParameters] @go(Proximity,[]HotwordRuleProximityInitParameters)
}

#HotwordRuleObservation: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#HotwordRuleHotwordRegexObservation] @go(HotwordRegex,[]HotwordRuleHotwordRegexObservation)

	// Likelihood adjustment to apply to all matching findings.
	// Structure is documented below.
	likelihoodAdjustment?: [...#LikelihoodAdjustmentObservation] @go(LikelihoodAdjustment,[]LikelihoodAdjustmentObservation)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#HotwordRuleProximityObservation] @go(Proximity,[]HotwordRuleProximityObservation)
}

#HotwordRuleParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRegex: [...#HotwordRuleHotwordRegexParameters] @go(HotwordRegex,[]HotwordRuleHotwordRegexParameters)

	// Likelihood adjustment to apply to all matching findings.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	likelihoodAdjustment: [...#LikelihoodAdjustmentParameters] @go(LikelihoodAdjustment,[]LikelihoodAdjustmentParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	proximity: [...#HotwordRuleProximityParameters] @go(Proximity,[]HotwordRuleProximityParameters)
}

#HotwordRuleProximityInitParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#HotwordRuleProximityObservation: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#HotwordRuleProximityParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	// +kubebuilder:validation:Optional
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	// +kubebuilder:validation:Optional
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#InfoTypeInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InfoTypeObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InfoTypeParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#InspectConfigInfoTypesInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InspectConfigInfoTypesObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InspectConfigInfoTypesParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#InspectConfigInitParameters: {
	// List of options defining data content to scan. If empty, text, images, and other content will be included.
	// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
	contentOptions?: [...null | string] @go(ContentOptions,[]*string)

	// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
	// Structure is documented below.
	customInfoTypes?: [...#CustomInfoTypesInitParameters] @go(CustomInfoTypes,[]CustomInfoTypesInitParameters)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: null | bool @go(ExcludeInfoTypes,*bool)

	// When true, a contextual quote from the data that triggered a finding is included in the response.
	includeQuote?: null | bool @go(IncludeQuote,*bool)

	// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
	// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
	// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
	// By default this may be all types, but may change over time as detectors are updated.
	// Structure is documented below.
	infoTypes?: [...#InspectConfigInfoTypesInitParameters] @go(InfoTypes,[]InspectConfigInfoTypesInitParameters)

	// Configuration to control the number of findings returned.
	// Structure is documented below.
	limits?: [...#LimitsInitParameters] @go(Limits,[]LimitsInitParameters)

	// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
	// Default value is POSSIBLE.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	minLikelihood?: null | string @go(MinLikelihood,*string)

	// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
	// other rules are executed in the order they are specified for each info type.
	// Structure is documented below.
	ruleSet?: [...#RuleSetInitParameters] @go(RuleSet,[]RuleSetInitParameters)
}

#InspectConfigObservation: {
	// List of options defining data content to scan. If empty, text, images, and other content will be included.
	// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
	contentOptions?: [...null | string] @go(ContentOptions,[]*string)

	// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
	// Structure is documented below.
	customInfoTypes?: [...#CustomInfoTypesObservation] @go(CustomInfoTypes,[]CustomInfoTypesObservation)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: null | bool @go(ExcludeInfoTypes,*bool)

	// When true, a contextual quote from the data that triggered a finding is included in the response.
	includeQuote?: null | bool @go(IncludeQuote,*bool)

	// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
	// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
	// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
	// By default this may be all types, but may change over time as detectors are updated.
	// Structure is documented below.
	infoTypes?: [...#InspectConfigInfoTypesObservation] @go(InfoTypes,[]InspectConfigInfoTypesObservation)

	// Configuration to control the number of findings returned.
	// Structure is documented below.
	limits?: [...#LimitsObservation] @go(Limits,[]LimitsObservation)

	// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
	// Default value is POSSIBLE.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	minLikelihood?: null | string @go(MinLikelihood,*string)

	// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
	// other rules are executed in the order they are specified for each info type.
	// Structure is documented below.
	ruleSet?: [...#RuleSetObservation] @go(RuleSet,[]RuleSetObservation)
}

#InspectConfigParameters: {
	// List of options defining data content to scan. If empty, text, images, and other content will be included.
	// Each value may be one of: CONTENT_TEXT, CONTENT_IMAGE.
	// +kubebuilder:validation:Optional
	contentOptions?: [...null | string] @go(ContentOptions,[]*string)

	// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	customInfoTypes?: [...#CustomInfoTypesParameters] @go(CustomInfoTypes,[]CustomInfoTypesParameters)

	// When true, excludes type information of the findings.
	// +kubebuilder:validation:Optional
	excludeInfoTypes?: null | bool @go(ExcludeInfoTypes,*bool)

	// When true, a contextual quote from the data that triggered a finding is included in the response.
	// +kubebuilder:validation:Optional
	includeQuote?: null | bool @go(IncludeQuote,*bool)

	// Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
	// or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
	// When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
	// By default this may be all types, but may change over time as detectors are updated.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoTypes?: [...#InspectConfigInfoTypesParameters] @go(InfoTypes,[]InspectConfigInfoTypesParameters)

	// Configuration to control the number of findings returned.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	limits?: [...#LimitsParameters] @go(Limits,[]LimitsParameters)

	// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
	// Default value is POSSIBLE.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	minLikelihood?: null | string @go(MinLikelihood,*string)

	// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
	// other rules are executed in the order they are specified for each info type.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ruleSet?: [...#RuleSetParameters] @go(RuleSet,[]RuleSetParameters)
}

#InspectTemplateInitParameters: {
	// A description of the inspect template.
	description?: null | string @go(Description,*string)

	// User set display name of the inspect template.
	displayName?: null | string @go(DisplayName,*string)

	// The core content of the template.
	// Structure is documented below.
	inspectConfig?: [...#InspectConfigInitParameters] @go(InspectConfig,[]InspectConfigInitParameters)

	// The parent of the inspect template in any of the following formats:
	parent?: null | string @go(Parent,*string)
}

#InspectTemplateObservation: {
	// A description of the inspect template.
	description?: null | string @go(Description,*string)

	// User set display name of the inspect template.
	displayName?: null | string @go(DisplayName,*string)

	// an identifier for the resource with format {{parent}}/inspectTemplates/{{name}}
	id?: null | string @go(ID,*string)

	// The core content of the template.
	// Structure is documented below.
	inspectConfig?: [...#InspectConfigObservation] @go(InspectConfig,[]InspectConfigObservation)

	// The resource name of the inspect template. Set by the server.
	name?: null | string @go(Name,*string)

	// The parent of the inspect template in any of the following formats:
	parent?: null | string @go(Parent,*string)
}

#InspectTemplateParameters: {
	// A description of the inspect template.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// User set display name of the inspect template.
	// +kubebuilder:validation:Optional
	displayName?: null | string @go(DisplayName,*string)

	// The core content of the template.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	inspectConfig?: [...#InspectConfigParameters] @go(InspectConfig,[]InspectConfigParameters)

	// The parent of the inspect template in any of the following formats:
	// +kubebuilder:validation:Optional
	parent?: null | string @go(Parent,*string)
}

#LikelihoodAdjustmentInitParameters: {
	// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	fixedLikelihood?: null | string @go(FixedLikelihood,*string)

	// Increase or decrease the likelihood by the specified number of levels. For example,
	// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
	// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
	// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
	// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
	// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
	relativeLikelihood?: null | float64 @go(RelativeLikelihood,*float64)
}

#LikelihoodAdjustmentObservation: {
	// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	fixedLikelihood?: null | string @go(FixedLikelihood,*string)

	// Increase or decrease the likelihood by the specified number of levels. For example,
	// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
	// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
	// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
	// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
	// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
	relativeLikelihood?: null | float64 @go(RelativeLikelihood,*float64)
}

#LikelihoodAdjustmentParameters: {
	// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	fixedLikelihood?: null | string @go(FixedLikelihood,*string)

	// Increase or decrease the likelihood by the specified number of levels. For example,
	// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
	// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
	// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
	// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
	// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
	// +kubebuilder:validation:Optional
	relativeLikelihood?: null | float64 @go(RelativeLikelihood,*float64)
}

#LimitsInitParameters: {
	// Configuration of findings limit given for specified infoTypes.
	// Structure is documented below.
	maxFindingsPerInfoType?: [...#MaxFindingsPerInfoTypeInitParameters] @go(MaxFindingsPerInfoType,[]MaxFindingsPerInfoTypeInitParameters)

	// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
	maxFindingsPerItem?: null | float64 @go(MaxFindingsPerItem,*float64)

	// Max number of findings that will be returned per request/job. The maximum returned is 2000.
	maxFindingsPerRequest?: null | float64 @go(MaxFindingsPerRequest,*float64)
}

#LimitsObservation: {
	// Configuration of findings limit given for specified infoTypes.
	// Structure is documented below.
	maxFindingsPerInfoType?: [...#MaxFindingsPerInfoTypeObservation] @go(MaxFindingsPerInfoType,[]MaxFindingsPerInfoTypeObservation)

	// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
	maxFindingsPerItem?: null | float64 @go(MaxFindingsPerItem,*float64)

	// Max number of findings that will be returned per request/job. The maximum returned is 2000.
	maxFindingsPerRequest?: null | float64 @go(MaxFindingsPerRequest,*float64)
}

#LimitsParameters: {
	// Configuration of findings limit given for specified infoTypes.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	maxFindingsPerInfoType?: [...#MaxFindingsPerInfoTypeParameters] @go(MaxFindingsPerInfoType,[]MaxFindingsPerInfoTypeParameters)

	// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
	// +kubebuilder:validation:Optional
	maxFindingsPerItem?: null | float64 @go(MaxFindingsPerItem,*float64)

	// Max number of findings that will be returned per request/job. The maximum returned is 2000.
	// +kubebuilder:validation:Optional
	maxFindingsPerRequest?: null | float64 @go(MaxFindingsPerRequest,*float64)
}

#MaxFindingsPerInfoTypeInfoTypeInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#MaxFindingsPerInfoTypeInfoTypeObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#MaxFindingsPerInfoTypeInfoTypeParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#MaxFindingsPerInfoTypeInitParameters: {
	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#MaxFindingsPerInfoTypeInfoTypeInitParameters] @go(InfoType,[]MaxFindingsPerInfoTypeInfoTypeInitParameters)

	// Max findings limit for the given infoType.
	maxFindings?: null | float64 @go(MaxFindings,*float64)
}

#MaxFindingsPerInfoTypeObservation: {
	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#MaxFindingsPerInfoTypeInfoTypeObservation] @go(InfoType,[]MaxFindingsPerInfoTypeInfoTypeObservation)

	// Max findings limit for the given infoType.
	maxFindings?: null | float64 @go(MaxFindings,*float64)
}

#MaxFindingsPerInfoTypeParameters: {
	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoType: [...#MaxFindingsPerInfoTypeInfoTypeParameters] @go(InfoType,[]MaxFindingsPerInfoTypeInfoTypeParameters)

	// Max findings limit for the given infoType.
	// +kubebuilder:validation:Optional
	maxFindings?: null | float64 @go(MaxFindings,*float64)
}

#ProximityInitParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#ProximityObservation: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#ProximityParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	// +kubebuilder:validation:Optional
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	// +kubebuilder:validation:Optional
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#RegexInitParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#RegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#RegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#RuleSetInfoTypesInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#RuleSetInfoTypesObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#RuleSetInfoTypesParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#RuleSetInitParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#RuleSetInfoTypesInitParameters] @go(InfoTypes,[]RuleSetInfoTypesInitParameters)

	// Set of rules to be applied to infoTypes. The rules are applied in order.
	// Structure is documented below.
	rules?: [...#RulesInitParameters] @go(Rules,[]RulesInitParameters)
}

#RuleSetObservation: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#RuleSetInfoTypesObservation] @go(InfoTypes,[]RuleSetInfoTypesObservation)

	// Set of rules to be applied to infoTypes. The rules are applied in order.
	// Structure is documented below.
	rules?: [...#RulesObservation] @go(Rules,[]RulesObservation)
}

#RuleSetParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoTypes: [...#RuleSetInfoTypesParameters] @go(InfoTypes,[]RuleSetInfoTypesParameters)

	// Set of rules to be applied to infoTypes. The rules are applied in order.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	rules: [...#RulesParameters] @go(Rules,[]RulesParameters)
}

#RulesInitParameters: {
	// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
	// Structure is documented below.
	exclusionRule?: [...#ExclusionRuleInitParameters] @go(ExclusionRule,[]ExclusionRuleInitParameters)

	// Hotword-based detection rule.
	// Structure is documented below.
	hotwordRule?: [...#HotwordRuleInitParameters] @go(HotwordRule,[]HotwordRuleInitParameters)
}

#RulesObservation: {
	// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
	// Structure is documented below.
	exclusionRule?: [...#ExclusionRuleObservation] @go(ExclusionRule,[]ExclusionRuleObservation)

	// Hotword-based detection rule.
	// Structure is documented below.
	hotwordRule?: [...#HotwordRuleObservation] @go(HotwordRule,[]HotwordRuleObservation)
}

#RulesParameters: {
	// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	exclusionRule?: [...#ExclusionRuleParameters] @go(ExclusionRule,[]ExclusionRuleParameters)

	// Hotword-based detection rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRule?: [...#HotwordRuleParameters] @go(HotwordRule,[]HotwordRuleParameters)
}

#StoredTypeInitParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)
}

#StoredTypeObservation: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	name?: null | string @go(Name,*string)
}

#StoredTypeParameters: {
	// Resource name of the requested StoredInfoType, for example organizations/433245324/storedInfoTypes/432452342
	// or projects/project-id/storedInfoTypes/432452342.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#SurrogateTypeInitParameters: {
}

#SurrogateTypeObservation: {
}

#SurrogateTypeParameters: {
}

// InspectTemplateSpec defines the desired state of InspectTemplate
#InspectTemplateSpec: {
	forProvider: #InspectTemplateParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #InspectTemplateInitParameters @go(InitProvider)
}

// InspectTemplateStatus defines the observed state of InspectTemplate.
#InspectTemplateStatus: {
	atProvider?: #InspectTemplateObservation @go(AtProvider)
}

// InspectTemplate is the Schema for the InspectTemplates API. An inspect job template.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#InspectTemplate: {
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.parent) || has(self.initProvider.parent)",message="parent is a required parameter"
	spec:    #InspectTemplateSpec   @go(Spec)
	status?: #InspectTemplateStatus @go(Status)
}

// InspectTemplateList contains a list of InspectTemplates
#InspectTemplateList: {
	items: [...#InspectTemplate] @go(Items,[]InspectTemplate)
}
