// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/datalossprevention/v1beta1

package v1beta1

#ActionsObservation: {
	// Create a de-identified copy of the requested table or files.
	// Structure is documented below.
	deidentify?: [...#DeidentifyObservation] @go(Deidentify,[]DeidentifyObservation)

	// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
	jobNotificationEmails?: [...#JobNotificationEmailsParameters] @go(JobNotificationEmails,[]JobNotificationEmailsParameters)

	// Publish a message into a given Pub/Sub topic when the job completes.
	// Structure is documented below.
	pubSub?: [...#PubSubObservation] @go(PubSub,[]PubSubObservation)

	// Publish findings of a DlpJob to Data Catalog.
	publishFindingsToCloudDataCatalog?: [...#PublishFindingsToCloudDataCatalogParameters] @go(PublishFindingsToCloudDataCatalog,[]PublishFindingsToCloudDataCatalogParameters)

	// Publish the result summary of a DlpJob to the Cloud Security Command Center.
	publishSummaryToCscc?: [...#PublishSummaryToCsccParameters] @go(PublishSummaryToCscc,[]PublishSummaryToCsccParameters)

	// Enable Stackdriver metric dlp.googleapis.com/findingCount.
	publishToStackdriver?: [...#PublishToStackdriverParameters] @go(PublishToStackdriver,[]PublishToStackdriverParameters)

	// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
	// Structure is documented below.
	saveFindings?: [...#SaveFindingsObservation] @go(SaveFindings,[]SaveFindingsObservation)
}

#ActionsParameters: {
	// Create a de-identified copy of the requested table or files.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	deidentify?: [...#DeidentifyParameters] @go(Deidentify,[]DeidentifyParameters)

	// Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
	// +kubebuilder:validation:Optional
	jobNotificationEmails?: [...#JobNotificationEmailsParameters] @go(JobNotificationEmails,[]JobNotificationEmailsParameters)

	// Publish a message into a given Pub/Sub topic when the job completes.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	pubSub?: [...#PubSubParameters] @go(PubSub,[]PubSubParameters)

	// Publish findings of a DlpJob to Data Catalog.
	// +kubebuilder:validation:Optional
	publishFindingsToCloudDataCatalog?: [...#PublishFindingsToCloudDataCatalogParameters] @go(PublishFindingsToCloudDataCatalog,[]PublishFindingsToCloudDataCatalogParameters)

	// Publish the result summary of a DlpJob to the Cloud Security Command Center.
	// +kubebuilder:validation:Optional
	publishSummaryToCscc?: [...#PublishSummaryToCsccParameters] @go(PublishSummaryToCscc,[]PublishSummaryToCsccParameters)

	// Enable Stackdriver metric dlp.googleapis.com/findingCount.
	// +kubebuilder:validation:Optional
	publishToStackdriver?: [...#PublishToStackdriverParameters] @go(PublishToStackdriver,[]PublishToStackdriverParameters)

	// If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	saveFindings?: [...#SaveFindingsParameters] @go(SaveFindings,[]SaveFindingsParameters)
}

#BigQueryOptionsObservation: {
	// The columns that are the primary keys for table objects included in ContentItem. A copy of this
	// cell's value will stored alongside alongside each finding so that the finding can be traced to
	// the specific row it came from. No more than 3 may be provided.
	// Structure is documented below.
	identifyingFields?: [...#IdentifyingFieldsObservation] @go(IdentifyingFields,[]IdentifyingFieldsObservation)

	// Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
	// If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
	// specified. Cannot be used in conjunction with TimespanConfig.
	rowsLimit?: null | float64 @go(RowsLimit,*float64)

	// Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
	// rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
	rowsLimitPercent?: null | float64 @go(RowsLimitPercent,*float64)

	// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
	// If not specified, scanning would start from the top.
	// Possible values are: TOP, RANDOM_START.
	sampleMethod?: null | string @go(SampleMethod,*string)

	// Set of files to scan.
	// Structure is documented below.
	tableReference?: [...#TableReferenceObservation] @go(TableReference,[]TableReferenceObservation)
}

#BigQueryOptionsParameters: {
	// The columns that are the primary keys for table objects included in ContentItem. A copy of this
	// cell's value will stored alongside alongside each finding so that the finding can be traced to
	// the specific row it came from. No more than 3 may be provided.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	identifyingFields?: [...#IdentifyingFieldsParameters] @go(IdentifyingFields,[]IdentifyingFieldsParameters)

	// Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
	// If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
	// specified. Cannot be used in conjunction with TimespanConfig.
	// +kubebuilder:validation:Optional
	rowsLimit?: null | float64 @go(RowsLimit,*float64)

	// Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
	// rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
	// +kubebuilder:validation:Optional
	rowsLimitPercent?: null | float64 @go(RowsLimitPercent,*float64)

	// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
	// If not specified, scanning would start from the top.
	// Possible values are: TOP, RANDOM_START.
	// +kubebuilder:validation:Optional
	sampleMethod?: null | string @go(SampleMethod,*string)

	// Set of files to scan.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	tableReference: [...#TableReferenceParameters] @go(TableReference,[]TableReferenceParameters)
}

#CloudStorageOptionsObservation: {
	// Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
	// then the rest of the bytes are omitted.
	bytesLimitPerFile?: null | float64 @go(BytesLimitPerFile,*float64)

	// Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
	bytesLimitPerFilePercent?: null | float64 @go(BytesLimitPerFilePercent,*float64)

	// Set of files to scan.
	// Structure is documented below.
	fileSet?: [...#FileSetObservation] @go(FileSet,[]FileSetObservation)

	// List of file type groups to include in the scan. If empty, all files are scanned and available data
	// format processors are applied. In addition, the binary content of the selected files is always scanned as well.
	// Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
	// Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV.
	fileTypes?: [...null | string] @go(FileTypes,[]*string)

	// Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
	filesLimitPercent?: null | float64 @go(FilesLimitPercent,*float64)

	// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
	// If not specified, scanning would start from the top.
	// Possible values are: TOP, RANDOM_START.
	sampleMethod?: null | string @go(SampleMethod,*string)
}

#CloudStorageOptionsParameters: {
	// Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
	// then the rest of the bytes are omitted.
	// +kubebuilder:validation:Optional
	bytesLimitPerFile?: null | float64 @go(BytesLimitPerFile,*float64)

	// Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
	// +kubebuilder:validation:Optional
	bytesLimitPerFilePercent?: null | float64 @go(BytesLimitPerFilePercent,*float64)

	// Set of files to scan.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	fileSet: [...#FileSetParameters] @go(FileSet,[]FileSetParameters)

	// List of file type groups to include in the scan. If empty, all files are scanned and available data
	// format processors are applied. In addition, the binary content of the selected files is always scanned as well.
	// Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
	// Each value may be one of: BINARY_FILE, TEXT_FILE, IMAGE, WORD, PDF, AVRO, CSV, TSV.
	// +kubebuilder:validation:Optional
	fileTypes?: [...null | string] @go(FileTypes,[]*string)

	// Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
	// Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
	// +kubebuilder:validation:Optional
	filesLimitPercent?: null | float64 @go(FilesLimitPercent,*float64)

	// How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
	// If not specified, scanning would start from the top.
	// Possible values are: TOP, RANDOM_START.
	// +kubebuilder:validation:Optional
	sampleMethod?: null | string @go(SampleMethod,*string)
}

#CustomInfoTypesDictionaryCloudStoragePathObservation: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#CustomInfoTypesDictionaryCloudStoragePathParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	// +kubebuilder:validation:Required
	path?: null | string @go(Path,*string)
}

#CustomInfoTypesDictionaryObservation: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#CustomInfoTypesDictionaryCloudStoragePathObservation] @go(CloudStoragePath,[]CustomInfoTypesDictionaryCloudStoragePathObservation)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#CustomInfoTypesDictionaryWordListObservation] @go(WordList,[]CustomInfoTypesDictionaryWordListObservation)
}

#CustomInfoTypesDictionaryParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cloudStoragePath?: [...#CustomInfoTypesDictionaryCloudStoragePathParameters] @go(CloudStoragePath,[]CustomInfoTypesDictionaryCloudStoragePathParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	wordList?: [...#CustomInfoTypesDictionaryWordListParameters] @go(WordList,[]CustomInfoTypesDictionaryWordListParameters)
}

#CustomInfoTypesDictionaryWordListObservation: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#CustomInfoTypesDictionaryWordListParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	// +kubebuilder:validation:Required
	words: [...null | string] @go(Words,[]*string)
}

#CustomInfoTypesInfoTypeObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#CustomInfoTypesInfoTypeParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#CustomInfoTypesRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#CustomInfoTypesRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Required
	pattern?: null | string @go(Pattern,*string)
}

#CustomInfoTypesStoredTypeObservation: {
	// (Output)
	// The creation timestamp of an inspectTemplate. Set by the server.
	createTime?: null | string @go(CreateTime,*string)

	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)
}

#CustomInfoTypesStoredTypeParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#CustomInfoTypesSurrogateTypeObservation: {
}

#CustomInfoTypesSurrogateTypeParameters: {
}

#DatastoreOptionsObservation: {
	// A representation of a Datastore kind.
	// Structure is documented below.
	kind?: [...#KindObservation] @go(Kind,[]KindObservation)

	// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
	// is always by project and namespace, however the namespace ID may be empty.
	// Structure is documented below.
	partitionId?: [...#PartitionIDObservation] @go(PartitionID,[]PartitionIDObservation)
}

#DatastoreOptionsParameters: {
	// A representation of a Datastore kind.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	kind: [...#KindParameters] @go(Kind,[]KindParameters)

	// Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
	// is always by project and namespace, however the namespace ID may be empty.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	partitionId: [...#PartitionIDParameters] @go(PartitionID,[]PartitionIDParameters)
}

#DeidentifyObservation: {
	// User settable Cloud Storage bucket and folders to store de-identified files.
	// This field must be set for cloud storage deidentification.
	// The output Cloud Storage bucket must be different from the input bucket.
	// De-identified files will overwrite files in the output path.
	// Form of: gs://bucket/folder/ or gs://bucket
	cloudStorageOutput?: null | string @go(CloudStorageOutput,*string)

	// List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
	// If empty, all supported files will be transformed. Supported types may be automatically added over time.
	// If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
	// Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
	fileTypesToTransform?: [...null | string] @go(FileTypesToTransform,[]*string)

	// User specified deidentify templates and configs for structured, unstructured, and image files.
	// Structure is documented below.
	transformationConfig?: [...#TransformationConfigObservation] @go(TransformationConfig,[]TransformationConfigObservation)

	// Config for storing transformation details.
	// Structure is documented below.
	transformationDetailsStorageConfig?: [...#TransformationDetailsStorageConfigObservation] @go(TransformationDetailsStorageConfig,[]TransformationDetailsStorageConfigObservation)
}

#DeidentifyParameters: {
	// User settable Cloud Storage bucket and folders to store de-identified files.
	// This field must be set for cloud storage deidentification.
	// The output Cloud Storage bucket must be different from the input bucket.
	// De-identified files will overwrite files in the output path.
	// Form of: gs://bucket/folder/ or gs://bucket
	// +kubebuilder:validation:Required
	cloudStorageOutput?: null | string @go(CloudStorageOutput,*string)

	// List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
	// If empty, all supported files will be transformed. Supported types may be automatically added over time.
	// If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
	// Each value may be one of: IMAGE, TEXT_FILE, CSV, TSV.
	// +kubebuilder:validation:Optional
	fileTypesToTransform?: [...null | string] @go(FileTypesToTransform,[]*string)

	// User specified deidentify templates and configs for structured, unstructured, and image files.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	transformationConfig?: [...#TransformationConfigParameters] @go(TransformationConfig,[]TransformationConfigParameters)

	// Config for storing transformation details.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	transformationDetailsStorageConfig?: [...#TransformationDetailsStorageConfigParameters] @go(TransformationDetailsStorageConfig,[]TransformationDetailsStorageConfigParameters)
}

#ExcludeByHotwordHotwordRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#ExcludeByHotwordHotwordRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#ExcludeByHotwordProximityObservation: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#ExcludeByHotwordProximityParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	// +kubebuilder:validation:Optional
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	// +kubebuilder:validation:Optional
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#ExclusionRuleDictionaryCloudStoragePathObservation: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	path?: null | string @go(Path,*string)
}

#ExclusionRuleDictionaryCloudStoragePathParameters: {
	// A url representing a file or path (no wildcards) in Cloud Storage. Example: gs://[BUCKET_NAME]/dictionary.txt
	// +kubebuilder:validation:Required
	path?: null | string @go(Path,*string)
}

#ExclusionRuleExcludeByHotwordObservation: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#ExcludeByHotwordHotwordRegexObservation] @go(HotwordRegex,[]ExcludeByHotwordHotwordRegexObservation)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#ExcludeByHotwordProximityObservation] @go(Proximity,[]ExcludeByHotwordProximityObservation)
}

#ExclusionRuleExcludeByHotwordParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRegex?: [...#ExcludeByHotwordHotwordRegexParameters] @go(HotwordRegex,[]ExcludeByHotwordHotwordRegexParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	proximity?: [...#ExcludeByHotwordProximityParameters] @go(Proximity,[]ExcludeByHotwordProximityParameters)
}

#ExclusionRuleExcludeInfoTypesInfoTypesObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#ExclusionRuleExcludeInfoTypesInfoTypesParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#ExclusionRuleExcludeInfoTypesObservation: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#ExclusionRuleExcludeInfoTypesInfoTypesObservation] @go(InfoTypes,[]ExclusionRuleExcludeInfoTypesInfoTypesObservation)
}

#ExclusionRuleExcludeInfoTypesParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	infoTypes: [...#ExclusionRuleExcludeInfoTypesInfoTypesParameters] @go(InfoTypes,[]ExclusionRuleExcludeInfoTypesInfoTypesParameters)
}

#FileSetObservation: {
	// The regex-filtered set of files to scan.
	// Structure is documented below.
	regexFileSet?: [...#RegexFileSetObservation] @go(RegexFileSet,[]RegexFileSetObservation)

	// The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard
	// in the path is allowed.
	// If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
	// non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is
	// equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
	url?: null | string @go(URL,*string)
}

#FileSetParameters: {
	// The regex-filtered set of files to scan.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	regexFileSet?: [...#RegexFileSetParameters] @go(RegexFileSet,[]RegexFileSetParameters)

	// The Cloud Storage url of the file(s) to scan, in the format gs://<bucket>/<path>. Trailing wildcard
	// in the path is allowed.
	// If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
	// non-recursively (content in sub-directories will not be scanned). This means that gs://mybucket/ is
	// equivalent to gs://mybucket/*, and gs://mybucket/directory/ is equivalent to gs://mybucket/directory/*.
	// +kubebuilder:validation:Optional
	url?: null | string @go(URL,*string)
}

#HotwordRuleLikelihoodAdjustmentObservation: {
	// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	fixedLikelihood?: null | string @go(FixedLikelihood,*string)

	// Increase or decrease the likelihood by the specified number of levels. For example,
	// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
	// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
	// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
	// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
	// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
	relativeLikelihood?: null | float64 @go(RelativeLikelihood,*float64)
}

#HotwordRuleLikelihoodAdjustmentParameters: {
	// Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	fixedLikelihood?: null | string @go(FixedLikelihood,*string)

	// Increase or decrease the likelihood by the specified number of levels. For example,
	// if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
	// then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
	// Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
	// adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
	// will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
	// +kubebuilder:validation:Optional
	relativeLikelihood?: null | float64 @go(RelativeLikelihood,*float64)
}

#HybridOptionsObservation: {
	// A description of the job trigger.
	description?: null | string @go(Description,*string)

	// To organize findings, these labels will be added to each finding.
	// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
	// Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?.
	// No more than 10 labels can be associated with a given finding.
	// Examples:
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// These are labels that each inspection request must include within their 'finding_labels' map. Request
	// may contain others, but any missing one of these will be rejected.
	// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
	// No more than 10 keys can be required.
	requiredFindingLabelKeys?: [...null | string] @go(RequiredFindingLabelKeys,[]*string)

	// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
	// Structure is documented below.
	tableOptions?: [...#TableOptionsObservation] @go(TableOptions,[]TableOptionsObservation)
}

#HybridOptionsParameters: {
	// A description of the job trigger.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// To organize findings, these labels will be added to each finding.
	// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
	// Label values must be between 0 and 63 characters long and must conform to the regular expression ([a-z]([-a-z0-9]*[a-z0-9])?)?.
	// No more than 10 labels can be associated with a given finding.
	// Examples:
	// +kubebuilder:validation:Optional
	labels?: {[string]: null | string} @go(Labels,map[string]*string)

	// These are labels that each inspection request must include within their 'finding_labels' map. Request
	// may contain others, but any missing one of these will be rejected.
	// Label keys must be between 1 and 63 characters long and must conform to the following regular expression: [a-z]([-a-z0-9]*[a-z0-9])?.
	// No more than 10 keys can be required.
	// +kubebuilder:validation:Optional
	requiredFindingLabelKeys?: [...null | string] @go(RequiredFindingLabelKeys,[]*string)

	// If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	tableOptions?: [...#TableOptionsParameters] @go(TableOptions,[]TableOptionsParameters)
}

#IdentifyingFieldsObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)
}

#IdentifyingFieldsParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#InspectConfigCustomInfoTypesObservation: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#CustomInfoTypesDictionaryObservation] @go(Dictionary,[]CustomInfoTypesDictionaryObservation)

	// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
	// Possible values are: EXCLUSION_TYPE_EXCLUDE.
	exclusionType?: null | string @go(ExclusionType,*string)

	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#CustomInfoTypesInfoTypeObservation] @go(InfoType,[]CustomInfoTypesInfoTypeObservation)

	// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
	// specified by the rule.
	// Default value is VERY_LIKELY.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	likelihood?: null | string @go(Likelihood,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#CustomInfoTypesRegexObservation] @go(Regex,[]CustomInfoTypesRegexObservation)

	// A reference to a StoredInfoType to use with scanning.
	// Structure is documented below.
	storedType?: [...#CustomInfoTypesStoredTypeObservation] @go(StoredType,[]CustomInfoTypesStoredTypeObservation)

	// Message for detecting output from deidentification transformations that support reversing.
	surrogateType?: [...#CustomInfoTypesSurrogateTypeParameters] @go(SurrogateType,[]CustomInfoTypesSurrogateTypeParameters)
}

#InspectConfigCustomInfoTypesParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	dictionary?: [...#CustomInfoTypesDictionaryParameters] @go(Dictionary,[]CustomInfoTypesDictionaryParameters)

	// If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
	// Possible values are: EXCLUSION_TYPE_EXCLUDE.
	// +kubebuilder:validation:Optional
	exclusionType?: null | string @go(ExclusionType,*string)

	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	infoType: [...#CustomInfoTypesInfoTypeParameters] @go(InfoType,[]CustomInfoTypesInfoTypeParameters)

	// Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
	// specified by the rule.
	// Default value is VERY_LIKELY.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	likelihood?: null | string @go(Likelihood,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	regex?: [...#CustomInfoTypesRegexParameters] @go(Regex,[]CustomInfoTypesRegexParameters)

	// A reference to a StoredInfoType to use with scanning.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	storedType?: [...#CustomInfoTypesStoredTypeParameters] @go(StoredType,[]CustomInfoTypesStoredTypeParameters)

	// Message for detecting output from deidentification transformations that support reversing.
	// +kubebuilder:validation:Optional
	surrogateType?: [...#CustomInfoTypesSurrogateTypeParameters] @go(SurrogateType,[]CustomInfoTypesSurrogateTypeParameters)
}

#InspectConfigLimitsObservation: {
	// Configuration of findings limit given for specified infoTypes.
	// Structure is documented below.
	maxFindingsPerInfoType?: [...#LimitsMaxFindingsPerInfoTypeObservation] @go(MaxFindingsPerInfoType,[]LimitsMaxFindingsPerInfoTypeObservation)

	// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
	maxFindingsPerItem?: null | float64 @go(MaxFindingsPerItem,*float64)

	// Max number of findings that will be returned per request/job. The maximum returned is 2000.
	maxFindingsPerRequest?: null | float64 @go(MaxFindingsPerRequest,*float64)
}

#InspectConfigLimitsParameters: {
	// Configuration of findings limit given for specified infoTypes.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	maxFindingsPerInfoType?: [...#LimitsMaxFindingsPerInfoTypeParameters] @go(MaxFindingsPerInfoType,[]LimitsMaxFindingsPerInfoTypeParameters)

	// Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
	// +kubebuilder:validation:Optional
	maxFindingsPerItem?: null | float64 @go(MaxFindingsPerItem,*float64)

	// Max number of findings that will be returned per request/job. The maximum returned is 2000.
	// +kubebuilder:validation:Optional
	maxFindingsPerRequest?: null | float64 @go(MaxFindingsPerRequest,*float64)
}

#InspectConfigRuleSetInfoTypesObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InspectConfigRuleSetInfoTypesParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#InspectConfigRuleSetObservation: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#InspectConfigRuleSetInfoTypesObservation] @go(InfoTypes,[]InspectConfigRuleSetInfoTypesObservation)

	// Set of rules to be applied to infoTypes. The rules are applied in order.
	// Structure is documented below.
	rules?: [...#RuleSetRulesObservation] @go(Rules,[]RuleSetRulesObservation)
}

#InspectConfigRuleSetParameters: {
	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoTypes?: [...#InspectConfigRuleSetInfoTypesParameters] @go(InfoTypes,[]InspectConfigRuleSetInfoTypesParameters)

	// Set of rules to be applied to infoTypes. The rules are applied in order.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	rules: [...#RuleSetRulesParameters] @go(Rules,[]RuleSetRulesParameters)
}

#InspectJobInspectConfigInfoTypesObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#InspectJobInspectConfigInfoTypesParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#InspectJobInspectConfigObservation: {
	// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
	// Structure is documented below.
	customInfoTypes?: [...#InspectConfigCustomInfoTypesObservation] @go(CustomInfoTypes,[]InspectConfigCustomInfoTypesObservation)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: null | bool @go(ExcludeInfoTypes,*bool)

	// When true, a contextual quote from the data that triggered a finding is included in the response.
	includeQuote?: null | bool @go(IncludeQuote,*bool)

	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	infoTypes?: [...#InspectJobInspectConfigInfoTypesObservation] @go(InfoTypes,[]InspectJobInspectConfigInfoTypesObservation)

	// Configuration to control the number of findings returned.
	// Structure is documented below.
	limits?: [...#InspectConfigLimitsObservation] @go(Limits,[]InspectConfigLimitsObservation)

	// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
	// Default value is POSSIBLE.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	minLikelihood?: null | string @go(MinLikelihood,*string)

	// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
	// other rules are executed in the order they are specified for each info type.
	// Structure is documented below.
	ruleSet?: [...#InspectConfigRuleSetObservation] @go(RuleSet,[]InspectConfigRuleSetObservation)
}

#InspectJobInspectConfigParameters: {
	// Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	customInfoTypes?: [...#InspectConfigCustomInfoTypesParameters] @go(CustomInfoTypes,[]InspectConfigCustomInfoTypesParameters)

	// When true, excludes type information of the findings.
	// +kubebuilder:validation:Optional
	excludeInfoTypes?: null | bool @go(ExcludeInfoTypes,*bool)

	// When true, a contextual quote from the data that triggered a finding is included in the response.
	// +kubebuilder:validation:Optional
	includeQuote?: null | bool @go(IncludeQuote,*bool)

	// List of infoTypes this rule set is applied to.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoTypes?: [...#InspectJobInspectConfigInfoTypesParameters] @go(InfoTypes,[]InspectJobInspectConfigInfoTypesParameters)

	// Configuration to control the number of findings returned.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	limits?: [...#InspectConfigLimitsParameters] @go(Limits,[]InspectConfigLimitsParameters)

	// Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
	// Default value is POSSIBLE.
	// Possible values are: VERY_UNLIKELY, UNLIKELY, POSSIBLE, LIKELY, VERY_LIKELY.
	// +kubebuilder:validation:Optional
	minLikelihood?: null | string @go(MinLikelihood,*string)

	// Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
	// other rules are executed in the order they are specified for each info type.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	ruleSet?: [...#InspectConfigRuleSetParameters] @go(RuleSet,[]InspectConfigRuleSetParameters)
}

#InspectJobObservation: {
	// A task to execute on the completion of a job.
	// Structure is documented below.
	actions?: [...#ActionsObservation] @go(Actions,[]ActionsObservation)

	// The core content of the template.
	// Structure is documented below.
	inspectConfig?: [...#InspectJobInspectConfigObservation] @go(InspectConfig,[]InspectJobInspectConfigObservation)

	// The name of the template to run when this job is triggered.
	inspectTemplateName?: null | string @go(InspectTemplateName,*string)

	// Information on where to inspect
	// Structure is documented below.
	storageConfig?: [...#StorageConfigObservation] @go(StorageConfig,[]StorageConfigObservation)
}

#InspectJobParameters: {
	// A task to execute on the completion of a job.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	actions: [...#ActionsParameters] @go(Actions,[]ActionsParameters)

	// The core content of the template.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	inspectConfig?: [...#InspectJobInspectConfigParameters] @go(InspectConfig,[]InspectJobInspectConfigParameters)

	// The name of the template to run when this job is triggered.
	// +kubebuilder:validation:Required
	inspectTemplateName?: null | string @go(InspectTemplateName,*string)

	// Information on where to inspect
	// Structure is documented below.
	// +kubebuilder:validation:Required
	storageConfig: [...#StorageConfigParameters] @go(StorageConfig,[]StorageConfigParameters)
}

#JobNotificationEmailsObservation: {
}

#JobNotificationEmailsParameters: {
}

#JobTriggerObservation: {
	// The creation timestamp of an inspectTemplate. Set by the server.
	createTime?: null | string @go(CreateTime,*string)

	// A description of the job trigger.
	description?: null | string @go(Description,*string)

	// User set display name of the job trigger.
	displayName?: null | string @go(DisplayName,*string)

	// an identifier for the resource with format {{parent}}/jobTriggers/{{name}}
	id?: null | string @go(ID,*string)

	// Controls what and how to inspect for findings.
	// Structure is documented below.
	inspectJob?: [...#InspectJobObservation] @go(InspectJob,[]InspectJobObservation)

	// The timestamp of the last time this trigger executed.
	lastRunTime?: null | string @go(LastRunTime,*string)

	// The resource name of the job trigger. Set by the server.
	name?: null | string @go(Name,*string)

	// The parent of the trigger, either in the format projects/{{project}}
	// or projects/{{project}}/locations/{{location}}
	parent?: null | string @go(Parent,*string)

	// Whether the trigger is currently active.
	// Default value is HEALTHY.
	// Possible values are: PAUSED, HEALTHY, CANCELLED.
	status?: null | string @go(Status,*string)

	// What event needs to occur for a new job to be started.
	// Structure is documented below.
	triggers?: [...#TriggersObservation] @go(Triggers,[]TriggersObservation)

	// The last update timestamp of an inspectTemplate. Set by the server.
	updateTime?: null | string @go(UpdateTime,*string)
}

#JobTriggerParameters: {
	// A description of the job trigger.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// User set display name of the job trigger.
	// +kubebuilder:validation:Optional
	displayName?: null | string @go(DisplayName,*string)

	// Controls what and how to inspect for findings.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	inspectJob?: [...#InspectJobParameters] @go(InspectJob,[]InspectJobParameters)

	// The parent of the trigger, either in the format projects/{{project}}
	// or projects/{{project}}/locations/{{location}}
	// +kubebuilder:validation:Optional
	parent?: null | string @go(Parent,*string)

	// Whether the trigger is currently active.
	// Default value is HEALTHY.
	// Possible values are: PAUSED, HEALTHY, CANCELLED.
	// +kubebuilder:validation:Optional
	status?: null | string @go(Status,*string)

	// What event needs to occur for a new job to be started.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	triggers?: [...#TriggersParameters] @go(Triggers,[]TriggersParameters)
}

#KindObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)
}

#KindParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#LimitsMaxFindingsPerInfoTypeInfoTypeObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	version?: null | string @go(Version,*string)
}

#LimitsMaxFindingsPerInfoTypeInfoTypeParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)

	// Version of the information type to use. By default, the version is set to stable
	// +kubebuilder:validation:Optional
	version?: null | string @go(Version,*string)
}

#LimitsMaxFindingsPerInfoTypeObservation: {
	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	infoType?: [...#LimitsMaxFindingsPerInfoTypeInfoTypeObservation] @go(InfoType,[]LimitsMaxFindingsPerInfoTypeInfoTypeObservation)

	// Max findings limit for the given infoType.
	maxFindings?: null | float64 @go(MaxFindings,*float64)
}

#LimitsMaxFindingsPerInfoTypeParameters: {
	// Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
	// not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
	// specified in another InfoTypeLimit.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	infoType?: [...#LimitsMaxFindingsPerInfoTypeInfoTypeParameters] @go(InfoType,[]LimitsMaxFindingsPerInfoTypeInfoTypeParameters)

	// Max findings limit for the given infoType.
	// +kubebuilder:validation:Optional
	maxFindings?: null | float64 @go(MaxFindings,*float64)
}

#ManualObservation: {
}

#ManualParameters: {
}

#OutputConfigObservation: {
	// Schema used for writing the findings for Inspect jobs. This field is only used for
	// Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
	// object. If appending to an existing table, any columns from the predefined schema
	// that are missing will be added. No columns in the existing table will be deleted.
	// If unspecified, then all available columns will be used for a new table or an (existing)
	// table with no schema, and no changes will be made to an existing table that has a schema.
	// Only for use with external storage.
	// Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
	outputSchema?: null | string @go(OutputSchema,*string)

	// The BigQuery table in which to store the output.
	// Structure is documented below.
	table?: [...#OutputConfigTableObservation] @go(Table,[]OutputConfigTableObservation)
}

#OutputConfigParameters: {
	// Schema used for writing the findings for Inspect jobs. This field is only used for
	// Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
	// object. If appending to an existing table, any columns from the predefined schema
	// that are missing will be added. No columns in the existing table will be deleted.
	// If unspecified, then all available columns will be used for a new table or an (existing)
	// table with no schema, and no changes will be made to an existing table that has a schema.
	// Only for use with external storage.
	// Possible values are: BASIC_COLUMNS, GCS_COLUMNS, DATASTORE_COLUMNS, BIG_QUERY_COLUMNS, ALL_COLUMNS.
	// +kubebuilder:validation:Optional
	outputSchema?: null | string @go(OutputSchema,*string)

	// The BigQuery table in which to store the output.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	table: [...#OutputConfigTableParameters] @go(Table,[]OutputConfigTableParameters)
}

#OutputConfigTableObservation: {
	// The ID of the dataset containing this table.
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	tableId?: null | string @go(TableID,*string)
}

#OutputConfigTableParameters: {
	// The ID of the dataset containing this table.
	// +kubebuilder:validation:Required
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	// +kubebuilder:validation:Required
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	// +kubebuilder:validation:Optional
	tableId?: null | string @go(TableID,*string)
}

#PartitionIDObservation: {
	// If not empty, the ID of the namespace to which the entities belong.
	namespaceId?: null | string @go(NamespaceID,*string)

	// The ID of the project containing this table.
	projectId?: null | string @go(ProjectID,*string)
}

#PartitionIDParameters: {
	// If not empty, the ID of the namespace to which the entities belong.
	// +kubebuilder:validation:Optional
	namespaceId?: null | string @go(NamespaceID,*string)

	// The ID of the project containing this table.
	// +kubebuilder:validation:Required
	projectId?: null | string @go(ProjectID,*string)
}

#PubSubObservation: {
	// Cloud Pub/Sub topic to send notifications to.
	topic?: null | string @go(Topic,*string)
}

#PubSubParameters: {
	// Cloud Pub/Sub topic to send notifications to.
	// +kubebuilder:validation:Required
	topic?: null | string @go(Topic,*string)
}

#PublishFindingsToCloudDataCatalogObservation: {
}

#PublishFindingsToCloudDataCatalogParameters: {
}

#PublishSummaryToCsccObservation: {
}

#PublishSummaryToCsccParameters: {
}

#PublishToStackdriverObservation: {
}

#PublishToStackdriverParameters: {
}

#RegexFileSetObservation: {
	// The name of a Cloud Storage bucket.
	bucketName?: null | string @go(BucketName,*string)

	// A list of regular expressions matching file paths to exclude. All files in the bucket that match at
	// least one of these regular expressions will be excluded from the scan.
	excludeRegex?: [...null | string] @go(ExcludeRegex,[]*string)

	// A list of regular expressions matching file paths to include. All files in the bucket
	// that match at least one of these regular expressions will be included in the set of files,
	// except for those that also match an item in excludeRegex. Leaving this field empty will
	// match all files by default (this is equivalent to including .* in the list)
	includeRegex?: [...null | string] @go(IncludeRegex,[]*string)
}

#RegexFileSetParameters: {
	// The name of a Cloud Storage bucket.
	// +kubebuilder:validation:Required
	bucketName?: null | string @go(BucketName,*string)

	// A list of regular expressions matching file paths to exclude. All files in the bucket that match at
	// least one of these regular expressions will be excluded from the scan.
	// +kubebuilder:validation:Optional
	excludeRegex?: [...null | string] @go(ExcludeRegex,[]*string)

	// A list of regular expressions matching file paths to include. All files in the bucket
	// that match at least one of these regular expressions will be included in the set of files,
	// except for those that also match an item in excludeRegex. Leaving this field empty will
	// match all files by default (this is equivalent to including .* in the list)
	// +kubebuilder:validation:Optional
	includeRegex?: [...null | string] @go(IncludeRegex,[]*string)
}

#RuleSetRulesObservation: {
	// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
	// Structure is documented below.
	exclusionRule?: [...#RulesExclusionRuleObservation] @go(ExclusionRule,[]RulesExclusionRuleObservation)

	// Hotword-based detection rule.
	// Structure is documented below.
	hotwordRule?: [...#RulesHotwordRuleObservation] @go(HotwordRule,[]RulesHotwordRuleObservation)
}

#RuleSetRulesParameters: {
	// The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	exclusionRule?: [...#RulesExclusionRuleParameters] @go(ExclusionRule,[]RulesExclusionRuleParameters)

	// Hotword-based detection rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRule?: [...#RulesHotwordRuleParameters] @go(HotwordRule,[]RulesHotwordRuleParameters)
}

#RulesExclusionRuleDictionaryObservation: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	cloudStoragePath?: [...#ExclusionRuleDictionaryCloudStoragePathObservation] @go(CloudStoragePath,[]ExclusionRuleDictionaryCloudStoragePathObservation)

	// List of words or phrases to search for.
	// Structure is documented below.
	wordList?: [...#RulesExclusionRuleDictionaryWordListObservation] @go(WordList,[]RulesExclusionRuleDictionaryWordListObservation)
}

#RulesExclusionRuleDictionaryParameters: {
	// Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cloudStoragePath?: [...#ExclusionRuleDictionaryCloudStoragePathParameters] @go(CloudStoragePath,[]ExclusionRuleDictionaryCloudStoragePathParameters)

	// List of words or phrases to search for.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	wordList?: [...#RulesExclusionRuleDictionaryWordListParameters] @go(WordList,[]RulesExclusionRuleDictionaryWordListParameters)
}

#RulesExclusionRuleDictionaryWordListObservation: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	words?: [...null | string] @go(Words,[]*string)
}

#RulesExclusionRuleDictionaryWordListParameters: {
	// Words or phrases defining the dictionary. The dictionary must contain at least one
	// phrase and every phrase must contain at least 2 characters that are letters or digits.
	// +kubebuilder:validation:Required
	words: [...null | string] @go(Words,[]*string)
}

#RulesExclusionRuleObservation: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	dictionary?: [...#RulesExclusionRuleDictionaryObservation] @go(Dictionary,[]RulesExclusionRuleDictionaryObservation)

	// Drop if the hotword rule is contained in the proximate context.
	// Structure is documented below.
	excludeByHotword?: [...#ExclusionRuleExcludeByHotwordObservation] @go(ExcludeByHotword,[]ExclusionRuleExcludeByHotwordObservation)

	// When true, excludes type information of the findings.
	excludeInfoTypes?: [...#ExclusionRuleExcludeInfoTypesObservation] @go(ExcludeInfoTypes,[]ExclusionRuleExcludeInfoTypesObservation)

	// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
	// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
	matchingType?: null | string @go(MatchingType,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	regex?: [...#RulesExclusionRuleRegexObservation] @go(Regex,[]RulesExclusionRuleRegexObservation)
}

#RulesExclusionRuleParameters: {
	// Dictionary which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	dictionary?: [...#RulesExclusionRuleDictionaryParameters] @go(Dictionary,[]RulesExclusionRuleDictionaryParameters)

	// Drop if the hotword rule is contained in the proximate context.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	excludeByHotword?: [...#ExclusionRuleExcludeByHotwordParameters] @go(ExcludeByHotword,[]ExclusionRuleExcludeByHotwordParameters)

	// When true, excludes type information of the findings.
	// +kubebuilder:validation:Optional
	excludeInfoTypes?: [...#ExclusionRuleExcludeInfoTypesParameters] @go(ExcludeInfoTypes,[]ExclusionRuleExcludeInfoTypesParameters)

	// How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
	// Possible values are: MATCHING_TYPE_FULL_MATCH, MATCHING_TYPE_PARTIAL_MATCH, MATCHING_TYPE_INVERSE_MATCH.
	// +kubebuilder:validation:Required
	matchingType?: null | string @go(MatchingType,*string)

	// Regular expression which defines the rule.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	regex?: [...#RulesExclusionRuleRegexParameters] @go(Regex,[]RulesExclusionRuleRegexParameters)
}

#RulesExclusionRuleRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#RulesExclusionRuleRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Required
	pattern?: null | string @go(Pattern,*string)
}

#RulesHotwordRuleHotwordRegexObservation: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	pattern?: null | string @go(Pattern,*string)
}

#RulesHotwordRuleHotwordRegexParameters: {
	// The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
	// +kubebuilder:validation:Optional
	groupIndexes?: [...null | float64] @go(GroupIndexes,[]*float64)

	// Pattern defining the regular expression.
	// Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
	// +kubebuilder:validation:Optional
	pattern?: null | string @go(Pattern,*string)
}

#RulesHotwordRuleObservation: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	hotwordRegex?: [...#RulesHotwordRuleHotwordRegexObservation] @go(HotwordRegex,[]RulesHotwordRuleHotwordRegexObservation)

	// Likelihood adjustment to apply to all matching findings.
	// Structure is documented below.
	likelihoodAdjustment?: [...#HotwordRuleLikelihoodAdjustmentObservation] @go(LikelihoodAdjustment,[]HotwordRuleLikelihoodAdjustmentObservation)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	proximity?: [...#RulesHotwordRuleProximityObservation] @go(Proximity,[]RulesHotwordRuleProximityObservation)
}

#RulesHotwordRuleParameters: {
	// Regular expression pattern defining what qualifies as a hotword.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hotwordRegex?: [...#RulesHotwordRuleHotwordRegexParameters] @go(HotwordRegex,[]RulesHotwordRuleHotwordRegexParameters)

	// Likelihood adjustment to apply to all matching findings.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	likelihoodAdjustment?: [...#HotwordRuleLikelihoodAdjustmentParameters] @go(LikelihoodAdjustment,[]HotwordRuleLikelihoodAdjustmentParameters)

	// Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
	// exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
	// used to match substrings of the finding itself. For example, the certainty of a phone number regex
	// (\d{3}) \d{3}-\d{4} could be adjusted upwards if the area code is known to be the local area code of a company
	// office using the hotword regex (xxx), where xxx is the area code in question.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	proximity?: [...#RulesHotwordRuleProximityParameters] @go(Proximity,[]RulesHotwordRuleProximityParameters)
}

#RulesHotwordRuleProximityObservation: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#RulesHotwordRuleProximityParameters: {
	// Number of characters after the finding to consider. Either this or window_before must be specified
	// +kubebuilder:validation:Optional
	windowAfter?: null | float64 @go(WindowAfter,*float64)

	// Number of characters before the finding to consider. Either this or window_after must be specified
	// +kubebuilder:validation:Optional
	windowBefore?: null | float64 @go(WindowBefore,*float64)
}

#SaveFindingsObservation: {
	// Information on where to store output
	// Structure is documented below.
	outputConfig?: [...#OutputConfigObservation] @go(OutputConfig,[]OutputConfigObservation)
}

#SaveFindingsParameters: {
	// Information on where to store output
	// Structure is documented below.
	// +kubebuilder:validation:Required
	outputConfig: [...#OutputConfigParameters] @go(OutputConfig,[]OutputConfigParameters)
}

#ScheduleObservation: {
	// With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
	// A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
	// This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	recurrencePeriodDuration?: null | string @go(RecurrencePeriodDuration,*string)
}

#ScheduleParameters: {
	// With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
	// A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
	// This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
	// A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	recurrencePeriodDuration?: null | string @go(RecurrencePeriodDuration,*string)
}

#StorageConfigObservation: {
	// Options defining BigQuery table and row identifiers.
	// Structure is documented below.
	bigQueryOptions?: [...#BigQueryOptionsObservation] @go(BigQueryOptions,[]BigQueryOptionsObservation)

	// Options defining a file or a set of files within a Google Cloud Storage bucket.
	// Structure is documented below.
	cloudStorageOptions?: [...#CloudStorageOptionsObservation] @go(CloudStorageOptions,[]CloudStorageOptionsObservation)

	// Options defining a data set within Google Cloud Datastore.
	// Structure is documented below.
	datastoreOptions?: [...#DatastoreOptionsObservation] @go(DatastoreOptions,[]DatastoreOptionsObservation)

	// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
	// Structure is documented below.
	hybridOptions?: [...#HybridOptionsObservation] @go(HybridOptions,[]HybridOptionsObservation)

	// Information on where to inspect
	// Structure is documented below.
	timespanConfig?: [...#TimespanConfigObservation] @go(TimespanConfig,[]TimespanConfigObservation)
}

#StorageConfigParameters: {
	// Options defining BigQuery table and row identifiers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	bigQueryOptions?: [...#BigQueryOptionsParameters] @go(BigQueryOptions,[]BigQueryOptionsParameters)

	// Options defining a file or a set of files within a Google Cloud Storage bucket.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cloudStorageOptions?: [...#CloudStorageOptionsParameters] @go(CloudStorageOptions,[]CloudStorageOptionsParameters)

	// Options defining a data set within Google Cloud Datastore.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	datastoreOptions?: [...#DatastoreOptionsParameters] @go(DatastoreOptions,[]DatastoreOptionsParameters)

	// Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	hybridOptions?: [...#HybridOptionsParameters] @go(HybridOptions,[]HybridOptionsParameters)

	// Information on where to inspect
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	timespanConfig?: [...#TimespanConfigParameters] @go(TimespanConfig,[]TimespanConfigParameters)
}

#TableObservation: {
	// The ID of the dataset containing this table.
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	tableId?: null | string @go(TableID,*string)
}

#TableOptionsIdentifyingFieldsObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)
}

#TableOptionsIdentifyingFieldsParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#TableOptionsObservation: {
	// The columns that are the primary keys for table objects included in ContentItem. A copy of this
	// cell's value will stored alongside alongside each finding so that the finding can be traced to
	// the specific row it came from. No more than 3 may be provided.
	// Structure is documented below.
	identifyingFields?: [...#TableOptionsIdentifyingFieldsObservation] @go(IdentifyingFields,[]TableOptionsIdentifyingFieldsObservation)
}

#TableOptionsParameters: {
	// The columns that are the primary keys for table objects included in ContentItem. A copy of this
	// cell's value will stored alongside alongside each finding so that the finding can be traced to
	// the specific row it came from. No more than 3 may be provided.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	identifyingFields?: [...#TableOptionsIdentifyingFieldsParameters] @go(IdentifyingFields,[]TableOptionsIdentifyingFieldsParameters)
}

#TableParameters: {
	// The ID of the dataset containing this table.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/bigquery/v1beta1.Dataset
	// +kubebuilder:validation:Optional
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	// +kubebuilder:validation:Required
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/bigquery/v1beta1.Table
	// +kubebuilder:validation:Optional
	tableId?: null | string @go(TableID,*string)
}

#TableReferenceObservation: {
	// The ID of the dataset containing this table.
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	tableId?: null | string @go(TableID,*string)
}

#TableReferenceParameters: {
	// The ID of the dataset containing this table.
	// +kubebuilder:validation:Required
	datasetId?: null | string @go(DatasetID,*string)

	// The ID of the project containing this table.
	// +kubebuilder:validation:Required
	projectId?: null | string @go(ProjectID,*string)

	// The ID of the table. The ID must contain only letters (a-z,
	// A-Z), numbers (0-9), or underscores (_). The maximum length
	// is 1,024 characters.
	// +kubebuilder:validation:Required
	tableId?: null | string @go(TableID,*string)
}

#TimespanConfigObservation: {
	// When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
	// scanning files that have not been modified since the last time the JobTrigger executed. This will
	// be based on the time of the execution of the last run of the JobTrigger.
	enableAutoPopulationOfTimespanConfig?: null | bool @go(EnableAutoPopulationOfTimespanConfig,*bool)

	// Exclude files or rows newer than this value. If set to zero, no upper time limit is applied.
	endTime?: null | string @go(EndTime,*string)

	// Exclude files or rows older than this value.
	startTime?: null | string @go(StartTime,*string)

	// Information on where to inspect
	// Structure is documented below.
	timestampField?: [...#TimestampFieldObservation] @go(TimestampField,[]TimestampFieldObservation)
}

#TimespanConfigParameters: {
	// When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
	// scanning files that have not been modified since the last time the JobTrigger executed. This will
	// be based on the time of the execution of the last run of the JobTrigger.
	// +kubebuilder:validation:Optional
	enableAutoPopulationOfTimespanConfig?: null | bool @go(EnableAutoPopulationOfTimespanConfig,*bool)

	// Exclude files or rows newer than this value. If set to zero, no upper time limit is applied.
	// +kubebuilder:validation:Optional
	endTime?: null | string @go(EndTime,*string)

	// Exclude files or rows older than this value.
	// +kubebuilder:validation:Optional
	startTime?: null | string @go(StartTime,*string)

	// Information on where to inspect
	// Structure is documented below.
	// +kubebuilder:validation:Required
	timestampField: [...#TimestampFieldParameters] @go(TimestampField,[]TimestampFieldParameters)
}

#TimestampFieldObservation: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	name?: null | string @go(Name,*string)
}

#TimestampFieldParameters: {
	// Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
	// For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
	// modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
	// field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
	// For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
	// timestamp property does not exist or its value is empty or invalid.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#TransformationConfigObservation: {
	// If this template is specified, it will serve as the default de-identify template.
	deidentifyTemplate?: null | string @go(DeidentifyTemplate,*string)

	// If this template is specified, it will serve as the de-identify template for images.
	imageRedactTemplate?: null | string @go(ImageRedactTemplate,*string)

	// If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
	structuredDeidentifyTemplate?: null | string @go(StructuredDeidentifyTemplate,*string)
}

#TransformationConfigParameters: {
	// If this template is specified, it will serve as the default de-identify template.
	// +kubebuilder:validation:Optional
	deidentifyTemplate?: null | string @go(DeidentifyTemplate,*string)

	// If this template is specified, it will serve as the de-identify template for images.
	// +kubebuilder:validation:Optional
	imageRedactTemplate?: null | string @go(ImageRedactTemplate,*string)

	// If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
	// +kubebuilder:validation:Optional
	structuredDeidentifyTemplate?: null | string @go(StructuredDeidentifyTemplate,*string)
}

#TransformationDetailsStorageConfigObservation: {
	// The BigQuery table in which to store the output.
	// Structure is documented below.
	table?: [...#TableObservation] @go(Table,[]TableObservation)
}

#TransformationDetailsStorageConfigParameters: {
	// The BigQuery table in which to store the output.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	table: [...#TableParameters] @go(Table,[]TableParameters)
}

#TriggersObservation: {
	// For use with hybrid jobs. Jobs must be manually created and finished.
	manual?: [...#ManualParameters] @go(Manual,[]ManualParameters)

	// Schedule for triggered jobs
	// Structure is documented below.
	schedule?: [...#ScheduleObservation] @go(Schedule,[]ScheduleObservation)
}

#TriggersParameters: {
	// For use with hybrid jobs. Jobs must be manually created and finished.
	// +kubebuilder:validation:Optional
	manual?: [...#ManualParameters] @go(Manual,[]ManualParameters)

	// Schedule for triggered jobs
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	schedule?: [...#ScheduleParameters] @go(Schedule,[]ScheduleParameters)
}

// JobTriggerSpec defines the desired state of JobTrigger
#JobTriggerSpec: {
	forProvider: #JobTriggerParameters @go(ForProvider)
}

// JobTriggerStatus defines the observed state of JobTrigger.
#JobTriggerStatus: {
	atProvider?: #JobTriggerObservation @go(AtProvider)
}

// JobTrigger is the Schema for the JobTriggers API. A job trigger configuration.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#JobTrigger: {
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.parent)",message="parent is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.triggers)",message="triggers is a required parameter"
	spec:    #JobTriggerSpec   @go(Spec)
	status?: #JobTriggerStatus @go(Status)
}

// JobTriggerList contains a list of JobTriggers
#JobTriggerList: {
	items: [...#JobTrigger] @go(Items,[]JobTrigger)
}
