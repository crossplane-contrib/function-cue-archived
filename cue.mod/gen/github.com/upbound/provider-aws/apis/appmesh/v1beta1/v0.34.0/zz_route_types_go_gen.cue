// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appmesh/v1beta1

package v1beta1

#ActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#ActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	weight?: null | float64 @go(Weight,*float64)
}

#GRPCRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#WeightedTargetObservation] @go(WeightedTarget,[]WeightedTargetObservation)
}

#GRPCRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	weightedTarget: [...#WeightedTargetParameters] @go(WeightedTarget,[]WeightedTargetParameters)
}

#GRPCRouteMatchObservation: {
	// Data to match from the gRPC request.
	metadata?: [...#MetadataObservation] @go(Metadata,[]MetadataObservation)

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	methodName?: null | string @go(MethodName,*string)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Fully qualified domain name for the service to match from the request.
	serviceName?: null | string @go(ServiceName,*string)
}

#GRPCRouteMatchParameters: {
	// Data to match from the gRPC request.
	// +kubebuilder:validation:Optional
	metadata?: [...#MetadataParameters] @go(Metadata,[]MetadataParameters)

	// Method name to match from the request. If you specify a name, you must also specify a service_name.
	// +kubebuilder:validation:Optional
	methodName?: null | string @go(MethodName,*string)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Fully qualified domain name for the service to match from the request.
	// +kubebuilder:validation:Optional
	serviceName?: null | string @go(ServiceName,*string)
}

#HTTPRouteActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#HTTPRouteActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	weight?: null | float64 @go(Weight,*float64)
}

#HTTPRouteRetryPolicyObservation: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#HTTPRouteRetryPolicyPerRetryTimeoutObservation] @go(PerRetryTimeout,[]HTTPRouteRetryPolicyPerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#HTTPRouteRetryPolicyParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	perRetryTimeout: [...#HTTPRouteRetryPolicyPerRetryTimeoutParameters] @go(PerRetryTimeout,[]HTTPRouteRetryPolicyPerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#HTTPRouteRetryPolicyPerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteRetryPolicyPerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPRouteTimeoutIdleObservation] @go(Idle,[]HTTPRouteTimeoutIdleObservation)

	// Per request timeout.
	perRequest?: [...#HTTPRouteTimeoutPerRequestObservation] @go(PerRequest,[]HTTPRouteTimeoutPerRequestObservation)
}

#HTTPRouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#HTTPRouteTimeoutIdleParameters] @go(Idle,[]HTTPRouteTimeoutIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#HTTPRouteTimeoutPerRequestParameters] @go(PerRequest,[]HTTPRouteTimeoutPerRequestParameters)
}

#HTTPRouteTimeoutPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPRouteTimeoutPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#HeaderMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#MatchRangeObservation] @go(Range,[]MatchRangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#HeaderMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#MatchRangeParameters] @go(Range,[]MatchRangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#HeaderMatchRangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#HeaderMatchRangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Required
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	start?: null | float64 @go(Start,*float64)
}

#HeaderObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#HeaderMatchObservation] @go(Match,[]HeaderMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#HeaderParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#HeaderMatchParameters] @go(Match,[]HeaderMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#Http2RouteRetryPolicyObservation: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#RetryPolicyPerRetryTimeoutObservation] @go(PerRetryTimeout,[]RetryPolicyPerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#Http2RouteRetryPolicyParameters: {
	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	perRetryTimeout: [...#RetryPolicyPerRetryTimeoutParameters] @go(PerRetryTimeout,[]RetryPolicyPerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#Http2RouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TimeoutIdleObservation] @go(Idle,[]TimeoutIdleObservation)

	// Per request timeout.
	perRequest?: [...#TimeoutPerRequestObservation] @go(PerRequest,[]TimeoutPerRequestObservation)
}

#Http2RouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TimeoutIdleParameters] @go(Idle,[]TimeoutIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#TimeoutPerRequestParameters] @go(PerRequest,[]TimeoutPerRequestParameters)
}

#IdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#IdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#MatchHeaderMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#HeaderMatchRangeObservation] @go(Range,[]HeaderMatchRangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#MatchHeaderMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#HeaderMatchRangeParameters] @go(Range,[]HeaderMatchRangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#MatchHeaderObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#MatchHeaderMatchObservation] @go(Match,[]MatchHeaderMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#MatchHeaderParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#MatchHeaderMatchParameters] @go(Match,[]MatchHeaderMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#MatchRangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#MatchRangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Required
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	start?: null | float64 @go(Start,*float64)
}

#MetadataMatchObservation: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	range?: [...#RangeObservation] @go(Range,[]RangeObservation)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	suffix?: null | string @go(Suffix,*string)
}

#MetadataMatchParameters: {
	// Value sent by the client must match the specified value exactly. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	exact?: null | string @go(Exact,*string)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	prefix?: null | string @go(Prefix,*string)

	// Object that specifies the range of numbers that the value sent by the client must be included in.
	// +kubebuilder:validation:Optional
	range?: [...#RangeParameters] @go(Range,[]RangeParameters)

	// Value sent by the client must include the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	regex?: null | string @go(Regex,*string)

	// Value sent by the client must end with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	suffix?: null | string @go(Suffix,*string)
}

#MetadataObservation: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	match?: [...#MetadataMatchObservation] @go(Match,[]MetadataMatchObservation)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)
}

#MetadataParameters: {
	// If true, the match is on the opposite of the match criteria. Default is false.
	// +kubebuilder:validation:Optional
	invert?: null | bool @go(Invert,*bool)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#MetadataMatchParameters] @go(Match,[]MetadataMatchParameters)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	name?: null | string @go(Name,*string)
}

#PerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#PerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#PerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#RangeObservation: {
	// End of the range.
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	start?: null | float64 @go(Start,*float64)
}

#RangeParameters: {
	// End of the range.
	// +kubebuilder:validation:Required
	end?: null | float64 @go(End,*float64)

	// (Requited) Start of the range.
	// +kubebuilder:validation:Required
	start?: null | float64 @go(Start,*float64)
}

#RetryPolicyObservation: {
	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	grpcRetryEvents?: [...null | string] @go(GRPCRetryEvents,[]*string)

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	perRetryTimeout?: [...#PerRetryTimeoutObservation] @go(PerRetryTimeout,[]PerRetryTimeoutObservation)

	// List of TCP retry events. The only valid value is connection-error.
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#RetryPolicyParameters: {
	// List of gRPC retry events.
	// Valid values: cancelled, deadline-exceeded, internal, resource-exhausted, unavailable.
	// +kubebuilder:validation:Optional
	grpcRetryEvents?: [...null | string] @go(GRPCRetryEvents,[]*string)

	// List of HTTP retry events.
	// Valid values: client-error (HTTP status code 409), gateway-error (HTTP status codes 502, 503, and 504), server-error (HTTP status codes 500, 501, 502, 503, 504, 505, 506, 507, 508, 510, and 511), stream-error (retry on refused stream).
	// +kubebuilder:validation:Optional
	httpRetryEvents?: [...null | string] @go(HTTPRetryEvents,[]*string)

	// Maximum number of retries.
	// +kubebuilder:validation:Required
	maxRetries?: null | float64 @go(MaxRetries,*float64)

	// Per-retry timeout.
	// +kubebuilder:validation:Required
	perRetryTimeout: [...#PerRetryTimeoutParameters] @go(PerRetryTimeout,[]PerRetryTimeoutParameters)

	// List of TCP retry events. The only valid value is connection-error.
	// +kubebuilder:validation:Optional
	tcpRetryEvents?: [...null | string] @go(TCPRetryEvents,[]*string)
}

#RetryPolicyPerRetryTimeoutObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#RetryPolicyPerRetryTimeoutParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#RouteObservation: {
	// ARN of the route.
	arn?: null | string @go(Arn,*string)

	// Creation date of the route.
	createdDate?: null | string @go(CreatedDate,*string)

	// ID of the route.
	id?: null | string @go(ID,*string)

	// Last update date of the route.
	lastUpdatedDate?: null | string @go(LastUpdatedDate,*string)

	// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Resource owner's AWS account ID.
	resourceOwner?: null | string @go(ResourceOwner,*string)

	// Route specification to apply.
	spec?: [...#RouteSpecObservation] @go(Spec,[]RouteSpecObservation)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)

	// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
	virtualRouterName?: null | string @go(VirtualRouterName,*string)
}

#RouteParameters: {
	// Name of the service mesh in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.Mesh
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	// +kubebuilder:validation:Optional
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the route. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Route specification to apply.
	// +kubebuilder:validation:Optional
	spec?: [...#RouteSpecParameters] @go(Spec,[]RouteSpecParameters)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Name of the virtual router in which to create the route. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualRouter
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualRouterName?: null | string @go(VirtualRouterName,*string)
}

#RouteSpecObservation: {
	// GRPC routing information for the route.
	grpcRoute?: [...#SpecGRPCRouteObservation] @go(GRPCRoute,[]SpecGRPCRouteObservation)

	// HTTP routing information for the route.
	httpRoute?: [...#SpecHTTPRouteObservation] @go(HTTPRoute,[]SpecHTTPRouteObservation)

	// HTTP/2 routing information for the route.
	http2Route?: [...#SpecHttp2RouteObservation] @go(Http2Route,[]SpecHttp2RouteObservation)

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	priority?: null | float64 @go(Priority,*float64)

	// TCP routing information for the route.
	tcpRoute?: [...#TCPRouteObservation] @go(TCPRoute,[]TCPRouteObservation)
}

#RouteSpecParameters: {
	// GRPC routing information for the route.
	// +kubebuilder:validation:Optional
	grpcRoute?: [...#SpecGRPCRouteParameters] @go(GRPCRoute,[]SpecGRPCRouteParameters)

	// HTTP routing information for the route.
	// +kubebuilder:validation:Optional
	httpRoute?: [...#SpecHTTPRouteParameters] @go(HTTPRoute,[]SpecHTTPRouteParameters)

	// HTTP/2 routing information for the route.
	// +kubebuilder:validation:Optional
	http2Route?: [...#SpecHttp2RouteParameters] @go(Http2Route,[]SpecHttp2RouteParameters)

	// Priority for the route, between 0 and 1000.
	// Routes are matched based on the specified value, where 0 is the highest priority.
	// +kubebuilder:validation:Optional
	priority?: null | float64 @go(Priority,*float64)

	// TCP routing information for the route.
	// +kubebuilder:validation:Optional
	tcpRoute?: [...#TCPRouteParameters] @go(TCPRoute,[]TCPRouteParameters)
}

#SpecGRPCRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#GRPCRouteActionObservation] @go(Action,[]GRPCRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#GRPCRouteMatchObservation] @go(Match,[]GRPCRouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#RetryPolicyObservation] @go(RetryPolicy,[]RetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#TimeoutObservation] @go(Timeout,[]TimeoutObservation)
}

#SpecGRPCRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	action: [...#GRPCRouteActionParameters] @go(Action,[]GRPCRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#GRPCRouteMatchParameters] @go(Match,[]GRPCRouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#RetryPolicyParameters] @go(RetryPolicy,[]RetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#TimeoutParameters] @go(Timeout,[]TimeoutParameters)
}

#SpecHTTPRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#HTTPRouteActionWeightedTargetObservation] @go(WeightedTarget,[]HTTPRouteActionWeightedTargetObservation)
}

#SpecHTTPRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	weightedTarget: [...#HTTPRouteActionWeightedTargetParameters] @go(WeightedTarget,[]HTTPRouteActionWeightedTargetParameters)
}

#SpecHTTPRouteMatchObservation: {
	// Client request headers to match on.
	header?: [...#MatchHeaderObservation] @go(Header,[]MatchHeaderObservation)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHTTPRouteMatchParameters: {
	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	header?: [...#MatchHeaderParameters] @go(Header,[]MatchHeaderParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	method?: null | string @go(Method,*string)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	prefix?: null | string @go(Prefix,*string)

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	scheme?: null | string @go(Scheme,*string)
}

#SpecHTTPRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#SpecHTTPRouteActionObservation] @go(Action,[]SpecHTTPRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHTTPRouteMatchObservation] @go(Match,[]SpecHTTPRouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#HTTPRouteRetryPolicyObservation] @go(RetryPolicy,[]HTTPRouteRetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#HTTPRouteTimeoutObservation] @go(Timeout,[]HTTPRouteTimeoutObservation)
}

#SpecHTTPRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	action: [...#SpecHTTPRouteActionParameters] @go(Action,[]SpecHTTPRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Required
	match: [...#SpecHTTPRouteMatchParameters] @go(Match,[]SpecHTTPRouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#HTTPRouteRetryPolicyParameters] @go(RetryPolicy,[]HTTPRouteRetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#HTTPRouteTimeoutParameters] @go(Timeout,[]HTTPRouteTimeoutParameters)
}

#SpecHttp2RouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#ActionWeightedTargetObservation] @go(WeightedTarget,[]ActionWeightedTargetObservation)
}

#SpecHttp2RouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	weightedTarget: [...#ActionWeightedTargetParameters] @go(WeightedTarget,[]ActionWeightedTargetParameters)
}

#SpecHttp2RouteMatchObservation: {
	// Client request headers to match on.
	header?: [...#HeaderObservation] @go(Header,[]HeaderObservation)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	method?: null | string @go(Method,*string)

	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	prefix?: null | string @go(Prefix,*string)

	// Client request header scheme to match on. Valid values: http, https.
	scheme?: null | string @go(Scheme,*string)
}

#SpecHttp2RouteMatchParameters: {
	// Client request headers to match on.
	// +kubebuilder:validation:Optional
	header?: [...#HeaderParameters] @go(Header,[]HeaderParameters)

	// Client request header method to match on. Valid values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.
	// +kubebuilder:validation:Optional
	method?: null | string @go(Method,*string)

	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Value sent by the client must begin with the specified characters. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	prefix?: null | string @go(Prefix,*string)

	// Client request header scheme to match on. Valid values: http, https.
	// +kubebuilder:validation:Optional
	scheme?: null | string @go(Scheme,*string)
}

#SpecHttp2RouteObservation: {
	// Action to take if a match is determined.
	action?: [...#SpecHttp2RouteActionObservation] @go(Action,[]SpecHttp2RouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#SpecHttp2RouteMatchObservation] @go(Match,[]SpecHttp2RouteMatchObservation)

	// Retry policy.
	retryPolicy?: [...#Http2RouteRetryPolicyObservation] @go(RetryPolicy,[]Http2RouteRetryPolicyObservation)

	// Types of timeouts.
	timeout?: [...#Http2RouteTimeoutObservation] @go(Timeout,[]Http2RouteTimeoutObservation)
}

#SpecHttp2RouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	action: [...#SpecHttp2RouteActionParameters] @go(Action,[]SpecHttp2RouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Required
	match: [...#SpecHttp2RouteMatchParameters] @go(Match,[]SpecHttp2RouteMatchParameters)

	// Retry policy.
	// +kubebuilder:validation:Optional
	retryPolicy?: [...#Http2RouteRetryPolicyParameters] @go(RetryPolicy,[]Http2RouteRetryPolicyParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#Http2RouteTimeoutParameters] @go(Timeout,[]Http2RouteTimeoutParameters)
}

#TCPRouteActionObservation: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	weightedTarget?: [...#TCPRouteActionWeightedTargetObservation] @go(WeightedTarget,[]TCPRouteActionWeightedTargetObservation)
}

#TCPRouteActionParameters: {
	// Targets that traffic is routed to when a request matches the route.
	// You can specify one or more targets and their relative weights with which to distribute traffic.
	// +kubebuilder:validation:Required
	weightedTarget: [...#TCPRouteActionWeightedTargetParameters] @go(WeightedTarget,[]TCPRouteActionWeightedTargetParameters)
}

#TCPRouteActionWeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#TCPRouteActionWeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.VirtualNode
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	weight?: null | float64 @go(Weight,*float64)
}

#TCPRouteMatchObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)
}

#TCPRouteMatchParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)
}

#TCPRouteObservation: {
	// Action to take if a match is determined.
	action?: [...#TCPRouteActionObservation] @go(Action,[]TCPRouteActionObservation)

	// Criteria for determining an gRPC request match.
	match?: [...#TCPRouteMatchObservation] @go(Match,[]TCPRouteMatchObservation)

	// Types of timeouts.
	timeout?: [...#TCPRouteTimeoutObservation] @go(Timeout,[]TCPRouteTimeoutObservation)
}

#TCPRouteParameters: {
	// Action to take if a match is determined.
	// +kubebuilder:validation:Required
	action: [...#TCPRouteActionParameters] @go(Action,[]TCPRouteActionParameters)

	// Criteria for determining an gRPC request match.
	// +kubebuilder:validation:Optional
	match?: [...#TCPRouteMatchParameters] @go(Match,[]TCPRouteMatchParameters)

	// Types of timeouts.
	// +kubebuilder:validation:Optional
	timeout?: [...#TCPRouteTimeoutParameters] @go(Timeout,[]TCPRouteTimeoutParameters)
}

#TCPRouteTimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TCPRouteTimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#TCPRouteTimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPRouteTimeoutIdleObservation] @go(Idle,[]TCPRouteTimeoutIdleObservation)
}

#TCPRouteTimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TCPRouteTimeoutIdleParameters] @go(Idle,[]TCPRouteTimeoutIdleParameters)
}

#TimeoutIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#TimeoutObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#IdleObservation] @go(Idle,[]IdleObservation)

	// Per request timeout.
	perRequest?: [...#PerRequestObservation] @go(PerRequest,[]PerRequestObservation)
}

#TimeoutParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#IdleParameters] @go(Idle,[]IdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#PerRequestParameters] @go(PerRequest,[]PerRequestParameters)
}

#TimeoutPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TimeoutPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#WeightedTargetObservation: {
	// The port number to match from the request.
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	weight?: null | float64 @go(Weight,*float64)
}

#WeightedTargetParameters: {
	// The port number to match from the request.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Virtual node to associate with the weighted target. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	virtualNode?: null | string @go(VirtualNode,*string)

	// Relative weight of the weighted target. An integer between 0 and 100.
	// +kubebuilder:validation:Required
	weight?: null | float64 @go(Weight,*float64)
}

// RouteSpec defines the desired state of Route
#RouteSpec: {
	forProvider: #RouteParameters @go(ForProvider)
}

// RouteStatus defines the observed state of Route.
#RouteStatus: {
	atProvider?: #RouteObservation @go(AtProvider)
}

// Route is the Schema for the Routes API. Provides an AWS App Mesh route resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#Route: {
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.spec)",message="spec is a required parameter"
	spec:    #RouteSpec   @go(Spec)
	status?: #RouteStatus @go(Status)
}

// RouteList contains a list of Routes
#RouteList: {
	items: [...#Route] @go(Items,[]Route)
}
