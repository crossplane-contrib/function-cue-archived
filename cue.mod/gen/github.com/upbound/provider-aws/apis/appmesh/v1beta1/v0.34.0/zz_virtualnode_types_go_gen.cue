// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-aws/apis/appmesh/v1beta1

package v1beta1

#AwsCloudMapObservation: {
	// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// Name of the AWS Cloud Map namespace to use.
	// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
	namespaceName?: null | string @go(NamespaceName,*string)

	// attribute of the dns object to hostname.
	serviceName?: null | string @go(ServiceName,*string)
}

#AwsCloudMapParameters: {
	// String map that contains attributes with values that you can use to filter instances by any custom attribute that you specified when you registered the instance. Only instances that match all of the specified key/value pairs will be returned.
	// +kubebuilder:validation:Optional
	attributes?: {[string]: null | string} @go(Attributes,map[string]*string)

	// Name of the AWS Cloud Map namespace to use.
	// Use the aws_service_discovery_http_namespace resource to configure a Cloud Map namespace. Must be between 1 and 1024 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/servicediscovery/v1beta1.HTTPNamespace
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("name",false)
	// +kubebuilder:validation:Optional
	namespaceName?: null | string @go(NamespaceName,*string)

	// attribute of the dns object to hostname.
	// +kubebuilder:validation:Required
	serviceName?: null | string @go(ServiceName,*string)
}

#BackendDefaultsClientPolicyObservation: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#BackendDefaultsClientPolicyTLSObservation] @go(TLS,[]BackendDefaultsClientPolicyTLSObservation)
}

#BackendDefaultsClientPolicyParameters: {
	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#BackendDefaultsClientPolicyTLSParameters] @go(TLS,[]BackendDefaultsClientPolicyTLSParameters)
}

#BackendDefaultsClientPolicyTLSCertificateObservation: {
	// Local file certificate.
	file?: [...#ClientPolicyTLSCertificateFileObservation] @go(File,[]ClientPolicyTLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSCertificateSdsObservation] @go(Sds,[]ClientPolicyTLSCertificateSdsObservation)
}

#BackendDefaultsClientPolicyTLSCertificateParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ClientPolicyTLSCertificateFileParameters] @go(File,[]ClientPolicyTLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ClientPolicyTLSCertificateSdsParameters] @go(Sds,[]ClientPolicyTLSCertificateSdsParameters)
}

#BackendDefaultsClientPolicyTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#BackendDefaultsClientPolicyTLSCertificateObservation] @go(Certificate,[]BackendDefaultsClientPolicyTLSCertificateObservation)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#BackendDefaultsClientPolicyTLSValidationObservation] @go(Validation,[]BackendDefaultsClientPolicyTLSValidationObservation)
}

#BackendDefaultsClientPolicyTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Optional
	certificate?: [...#BackendDefaultsClientPolicyTLSCertificateParameters] @go(Certificate,[]BackendDefaultsClientPolicyTLSCertificateParameters)

	// Whether the policy is enforced. Default is true.
	// +kubebuilder:validation:Optional
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	// +kubebuilder:validation:Optional
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	// +kubebuilder:validation:Required
	validation: [...#BackendDefaultsClientPolicyTLSValidationParameters] @go(Validation,[]BackendDefaultsClientPolicyTLSValidationParameters)
}

#BackendDefaultsClientPolicyTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]ClientPolicyTLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#ClientPolicyTLSValidationTrustObservation] @go(Trust,[]ClientPolicyTLSValidationTrustObservation)
}

#BackendDefaultsClientPolicyTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]ClientPolicyTLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Required
	trust: [...#ClientPolicyTLSValidationTrustParameters] @go(Trust,[]ClientPolicyTLSValidationTrustParameters)
}

#BackendObservation: {
	// Virtual service to use as a backend for a virtual node.
	virtualService?: [...#BackendVirtualServiceObservation] @go(VirtualService,[]BackendVirtualServiceObservation)
}

#BackendParameters: {
	// Virtual service to use as a backend for a virtual node.
	// +kubebuilder:validation:Required
	virtualService: [...#BackendVirtualServiceParameters] @go(VirtualService,[]BackendVirtualServiceParameters)
}

#BackendVirtualServiceObservation: {
	// Client policy for the backend.
	clientPolicy?: [...#VirtualServiceClientPolicyObservation] @go(ClientPolicy,[]VirtualServiceClientPolicyObservation)

	// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
	virtualServiceName?: null | string @go(VirtualServiceName,*string)
}

#BackendVirtualServiceParameters: {
	// Client policy for the backend.
	// +kubebuilder:validation:Optional
	clientPolicy?: [...#VirtualServiceClientPolicyParameters] @go(ClientPolicy,[]VirtualServiceClientPolicyParameters)

	// Name of the virtual service that is acting as a virtual node backend. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	virtualServiceName?: null | string @go(VirtualServiceName,*string)
}

#BaseEjectionDurationObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#BaseEjectionDurationParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#ClientPolicyTLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ClientPolicyTLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Required
	privateKey?: null | string @go(PrivateKey,*string)
}

#ClientPolicyTLSCertificateObservation: {
	// Local file certificate.
	file?: [...#TLSCertificateFileObservation] @go(File,[]TLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSCertificateSdsObservation] @go(Sds,[]TLSCertificateSdsObservation)
}

#ClientPolicyTLSCertificateParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#TLSCertificateFileParameters] @go(File,[]TLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#TLSCertificateSdsParameters] @go(Sds,[]TLSCertificateSdsParameters)
}

#ClientPolicyTLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ClientPolicyTLSCertificateObservation] @go(Certificate,[]ClientPolicyTLSCertificateObservation)

	// Whether the policy is enforced. Default is true.
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	validation?: [...#ClientPolicyTLSValidationObservation] @go(Validation,[]ClientPolicyTLSValidationObservation)
}

#ClientPolicyTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Optional
	certificate?: [...#ClientPolicyTLSCertificateParameters] @go(Certificate,[]ClientPolicyTLSCertificateParameters)

	// Whether the policy is enforced. Default is true.
	// +kubebuilder:validation:Optional
	enforce?: null | bool @go(Enforce,*bool)

	// One or more ports that the policy is enforced for.
	// +kubebuilder:validation:Optional
	ports?: [...null | float64] @go(Ports,[]*float64)

	// TLS validation context.
	// +kubebuilder:validation:Required
	validation: [...#ClientPolicyTLSValidationParameters] @go(Validation,[]ClientPolicyTLSValidationParameters)
}

#ClientPolicyTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#TLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]TLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#TLSValidationTrustObservation] @go(Trust,[]TLSValidationTrustObservation)
}

#ClientPolicyTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#TLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]TLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Required
	trust: [...#TLSValidationTrustParameters] @go(Trust,[]TLSValidationTrustParameters)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Required
	exact: [...null | string] @go(Exact,[]*string)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation)
}

#ClientPolicyTLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Required
	match: [...#ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters)
}

#ClientPolicyTLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ClientPolicyTLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ClientPolicyTLSValidationTrustObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#ValidationTrustAcmObservation] @go(Acm,[]ValidationTrustAcmObservation)

	// Local file certificate.
	file?: [...#ClientPolicyTLSValidationTrustFileObservation] @go(File,[]ClientPolicyTLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ClientPolicyTLSValidationTrustSdsObservation] @go(Sds,[]ClientPolicyTLSValidationTrustSdsObservation)
}

#ClientPolicyTLSValidationTrustParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#ValidationTrustAcmParameters] @go(Acm,[]ValidationTrustAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ClientPolicyTLSValidationTrustFileParameters] @go(File,[]ClientPolicyTLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ClientPolicyTLSValidationTrustSdsParameters] @go(Sds,[]ClientPolicyTLSValidationTrustSdsParameters)
}

#ClientPolicyTLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ClientPolicyTLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#ConnectionPoolGRPCObservation: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolGRPCParameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Required
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolHTTPObservation: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)
}

#ConnectionPoolHTTPParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Required
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// Number of overflowing requests after max_connections Envoy will queue to upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Optional
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)
}

#ConnectionPoolHttp2Observation: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#ConnectionPoolHttp2Parameters: {
	// Maximum number of inflight requests Envoy can concurrently support across hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Required
	maxRequests?: null | float64 @go(MaxRequests,*float64)
}

#DNSObservation: {
	// DNS host name for your virtual node.
	hostname?: null | string @go(Hostname,*string)
}

#DNSParameters: {
	// DNS host name for your virtual node.
	// +kubebuilder:validation:Required
	hostname?: null | string @go(Hostname,*string)
}

#GRPCIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#GRPCIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#GRPCPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#GRPCPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#HTTPIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#HTTPPerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#HTTPPerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#Http2IdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#Http2IdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#Http2PerRequestObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#Http2PerRequestParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#IntervalObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#IntervalParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#ListenerConnectionPoolObservation: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#ConnectionPoolGRPCObservation] @go(GRPC,[]ConnectionPoolGRPCObservation)

	// Connection pool information for HTTP listeners.
	http?: [...#ConnectionPoolHTTPObservation] @go(HTTP,[]ConnectionPoolHTTPObservation)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#ConnectionPoolHttp2Observation] @go(Http2,[]ConnectionPoolHttp2Observation)

	// Connection pool information for TCP listeners.
	tcp?: [...#TCPObservation] @go(TCP,[]TCPObservation)
}

#ListenerConnectionPoolParameters: {
	// Connection pool information for gRPC listeners.
	// +kubebuilder:validation:Optional
	grpc?: [...#ConnectionPoolGRPCParameters] @go(GRPC,[]ConnectionPoolGRPCParameters)

	// Connection pool information for HTTP listeners.
	// +kubebuilder:validation:Optional
	http?: [...#ConnectionPoolHTTPParameters] @go(HTTP,[]ConnectionPoolHTTPParameters)

	// Connection pool information for HTTP2 listeners.
	// +kubebuilder:validation:Optional
	http2?: [...#ConnectionPoolHttp2Parameters] @go(Http2,[]ConnectionPoolHttp2Parameters)

	// Connection pool information for TCP listeners.
	// +kubebuilder:validation:Optional
	tcp?: [...#TCPParameters] @go(TCP,[]TCPParameters)
}

#ListenerHealthCheckObservation: {
	// Number of consecutive successful health checks that must occur before declaring listener healthy.
	healthyThreshold?: null | float64 @go(HealthyThreshold,*float64)

	// Time period in milliseconds between each health check execution.
	intervalMillis?: null | float64 @go(IntervalMillis,*float64)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)

	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)

	// Amount of time to wait when receiving a response from the health check, in milliseconds.
	timeoutMillis?: null | float64 @go(TimeoutMillis,*float64)

	// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
	unhealthyThreshold?: null | float64 @go(UnhealthyThreshold,*float64)
}

#ListenerHealthCheckParameters: {
	// Number of consecutive successful health checks that must occur before declaring listener healthy.
	// +kubebuilder:validation:Required
	healthyThreshold?: null | float64 @go(HealthyThreshold,*float64)

	// Time period in milliseconds between each health check execution.
	// +kubebuilder:validation:Required
	intervalMillis?: null | float64 @go(IntervalMillis,*float64)

	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)

	// Port used for the port mapping.
	// +kubebuilder:validation:Optional
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	// +kubebuilder:validation:Required
	protocol?: null | string @go(Protocol,*string)

	// Amount of time to wait when receiving a response from the health check, in milliseconds.
	// +kubebuilder:validation:Required
	timeoutMillis?: null | float64 @go(TimeoutMillis,*float64)

	// Number of consecutive failed health checks that must occur before declaring a virtual node unhealthy.
	// +kubebuilder:validation:Required
	unhealthyThreshold?: null | float64 @go(UnhealthyThreshold,*float64)
}

#ListenerPortMappingObservation: {
	// Port used for the port mapping.
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	protocol?: null | string @go(Protocol,*string)
}

#ListenerPortMappingParameters: {
	// Port used for the port mapping.
	// +kubebuilder:validation:Required
	port?: null | float64 @go(Port,*float64)

	// Protocol used for the port mapping. Valid values are http, http2, tcp and grpc.
	// +kubebuilder:validation:Required
	protocol?: null | string @go(Protocol,*string)
}

#ListenerTLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#ListenerTLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Required
	privateKey?: null | string @go(PrivateKey,*string)
}

#ListenerTLSCertificateObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TLSCertificateAcmObservation] @go(Acm,[]TLSCertificateAcmObservation)

	// Local file certificate.
	file?: [...#ListenerTLSCertificateFileObservation] @go(File,[]ListenerTLSCertificateFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSCertificateSdsObservation] @go(Sds,[]ListenerTLSCertificateSdsObservation)
}

#ListenerTLSCertificateParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#TLSCertificateAcmParameters] @go(Acm,[]TLSCertificateAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ListenerTLSCertificateFileParameters] @go(File,[]ListenerTLSCertificateFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ListenerTLSCertificateSdsParameters] @go(Sds,[]ListenerTLSCertificateSdsParameters)
}

#ListenerTLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSValidationObservation: {
	// SANs for a TLS validation context.
	subjectAlternativeNames?: [...#ListenerTLSValidationSubjectAlternativeNamesObservation] @go(SubjectAlternativeNames,[]ListenerTLSValidationSubjectAlternativeNamesObservation)

	// TLS validation context trust.
	trust?: [...#ListenerTLSValidationTrustObservation] @go(Trust,[]ListenerTLSValidationTrustObservation)
}

#ListenerTLSValidationParameters: {
	// SANs for a TLS validation context.
	// +kubebuilder:validation:Optional
	subjectAlternativeNames?: [...#ListenerTLSValidationSubjectAlternativeNamesParameters] @go(SubjectAlternativeNames,[]ListenerTLSValidationSubjectAlternativeNamesParameters)

	// TLS validation context trust.
	// +kubebuilder:validation:Required
	trust: [...#ListenerTLSValidationTrustParameters] @go(Trust,[]ListenerTLSValidationTrustParameters)
}

#ListenerTLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#ListenerTLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Required
	exact: [...null | string] @go(Exact,[]*string)
}

#ListenerTLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#ListenerTLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]ListenerTLSValidationSubjectAlternativeNamesMatchObservation)
}

#ListenerTLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Required
	match: [...#ListenerTLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]ListenerTLSValidationSubjectAlternativeNamesMatchParameters)
}

#ListenerTLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ListenerTLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)
}

#ListenerTLSValidationTrustObservation: {
	// Local file certificate.
	file?: [...#ListenerTLSValidationTrustFileObservation] @go(File,[]ListenerTLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#ListenerTLSValidationTrustSdsObservation] @go(Sds,[]ListenerTLSValidationTrustSdsObservation)
}

#ListenerTLSValidationTrustParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#ListenerTLSValidationTrustFileParameters] @go(File,[]ListenerTLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#ListenerTLSValidationTrustSdsParameters] @go(Sds,[]ListenerTLSValidationTrustSdsParameters)
}

#ListenerTLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#ListenerTimeoutObservation: {
	// Connection pool information for gRPC listeners.
	grpc?: [...#TimeoutGRPCObservation] @go(GRPC,[]TimeoutGRPCObservation)

	// Connection pool information for HTTP listeners.
	http?: [...#TimeoutHTTPObservation] @go(HTTP,[]TimeoutHTTPObservation)

	// Connection pool information for HTTP2 listeners.
	http2?: [...#TimeoutHttp2Observation] @go(Http2,[]TimeoutHttp2Observation)

	// Connection pool information for TCP listeners.
	tcp?: [...#TimeoutTCPObservation] @go(TCP,[]TimeoutTCPObservation)
}

#ListenerTimeoutParameters: {
	// Connection pool information for gRPC listeners.
	// +kubebuilder:validation:Optional
	grpc?: [...#TimeoutGRPCParameters] @go(GRPC,[]TimeoutGRPCParameters)

	// Connection pool information for HTTP listeners.
	// +kubebuilder:validation:Optional
	http?: [...#TimeoutHTTPParameters] @go(HTTP,[]TimeoutHTTPParameters)

	// Connection pool information for HTTP2 listeners.
	// +kubebuilder:validation:Optional
	http2?: [...#TimeoutHttp2Parameters] @go(Http2,[]TimeoutHttp2Parameters)

	// Connection pool information for TCP listeners.
	// +kubebuilder:validation:Optional
	tcp?: [...#TimeoutTCPParameters] @go(TCP,[]TimeoutTCPParameters)
}

#LoggingAccessLogFileObservation: {
	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	path?: null | string @go(Path,*string)
}

#LoggingAccessLogFileParameters: {
	// File path to write access logs to. You can use /dev/stdout to send access logs to standard out. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Required
	path?: null | string @go(Path,*string)
}

#LoggingAccessLogObservation: {
	// Local file certificate.
	file?: [...#LoggingAccessLogFileObservation] @go(File,[]LoggingAccessLogFileObservation)
}

#LoggingAccessLogParameters: {
	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#LoggingAccessLogFileParameters] @go(File,[]LoggingAccessLogFileParameters)
}

#OutlierDetectionObservation: {
	// Base amount of time for which a host is ejected.
	baseEjectionDuration?: [...#BaseEjectionDurationObservation] @go(BaseEjectionDuration,[]BaseEjectionDurationObservation)

	// Time interval between ejection sweep analysis.
	interval?: [...#IntervalObservation] @go(Interval,[]IntervalObservation)

	// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
	// Minimum value of 0. Maximum value of 100.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
	maxServerErrors?: null | float64 @go(MaxServerErrors,*float64)
}

#OutlierDetectionParameters: {
	// Base amount of time for which a host is ejected.
	// +kubebuilder:validation:Required
	baseEjectionDuration: [...#BaseEjectionDurationParameters] @go(BaseEjectionDuration,[]BaseEjectionDurationParameters)

	// Time interval between ejection sweep analysis.
	// +kubebuilder:validation:Required
	interval: [...#IntervalParameters] @go(Interval,[]IntervalParameters)

	// Maximum percentage of hosts in load balancing pool for upstream service that can be ejected. Will eject at least one host regardless of the value.
	// Minimum value of 0. Maximum value of 100.
	// +kubebuilder:validation:Required
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// Number of consecutive 5xx errors required for ejection. Minimum value of 1.
	// +kubebuilder:validation:Required
	maxServerErrors?: null | float64 @go(MaxServerErrors,*float64)
}

#ServiceDiscoveryObservation: {
	// Any AWS Cloud Map information for the virtual node.
	awsCloudMap?: [...#AwsCloudMapObservation] @go(AwsCloudMap,[]AwsCloudMapObservation)

	// DNS service name for the virtual node.
	dns?: [...#DNSObservation] @go(DNS,[]DNSObservation)
}

#ServiceDiscoveryParameters: {
	// Any AWS Cloud Map information for the virtual node.
	// +kubebuilder:validation:Optional
	awsCloudMap?: [...#AwsCloudMapParameters] @go(AwsCloudMap,[]AwsCloudMapParameters)

	// DNS service name for the virtual node.
	// +kubebuilder:validation:Optional
	dns?: [...#DNSParameters] @go(DNS,[]DNSParameters)
}

#SpecBackendDefaultsObservation: {
	// Client policy for the backend.
	clientPolicy?: [...#BackendDefaultsClientPolicyObservation] @go(ClientPolicy,[]BackendDefaultsClientPolicyObservation)
}

#SpecBackendDefaultsParameters: {
	// Client policy for the backend.
	// +kubebuilder:validation:Optional
	clientPolicy?: [...#BackendDefaultsClientPolicyParameters] @go(ClientPolicy,[]BackendDefaultsClientPolicyParameters)
}

#SpecListenerObservation: {
	// Connection pool information for the listener.
	connectionPool?: [...#ListenerConnectionPoolObservation] @go(ConnectionPool,[]ListenerConnectionPoolObservation)

	// Health check information for the listener.
	healthCheck?: [...#ListenerHealthCheckObservation] @go(HealthCheck,[]ListenerHealthCheckObservation)

	// Outlier detection information for the listener.
	outlierDetection?: [...#OutlierDetectionObservation] @go(OutlierDetection,[]OutlierDetectionObservation)

	// Port mapping information for the listener.
	portMapping?: [...#ListenerPortMappingObservation] @go(PortMapping,[]ListenerPortMappingObservation)

	// Transport Layer Security (TLS) client policy.
	tls?: [...#SpecListenerTLSObservation] @go(TLS,[]SpecListenerTLSObservation)

	// Timeouts for different protocols.
	timeout?: [...#ListenerTimeoutObservation] @go(Timeout,[]ListenerTimeoutObservation)
}

#SpecListenerParameters: {
	// Connection pool information for the listener.
	// +kubebuilder:validation:Optional
	connectionPool?: [...#ListenerConnectionPoolParameters] @go(ConnectionPool,[]ListenerConnectionPoolParameters)

	// Health check information for the listener.
	// +kubebuilder:validation:Optional
	healthCheck?: [...#ListenerHealthCheckParameters] @go(HealthCheck,[]ListenerHealthCheckParameters)

	// Outlier detection information for the listener.
	// +kubebuilder:validation:Optional
	outlierDetection?: [...#OutlierDetectionParameters] @go(OutlierDetection,[]OutlierDetectionParameters)

	// Port mapping information for the listener.
	// +kubebuilder:validation:Required
	portMapping: [...#ListenerPortMappingParameters] @go(PortMapping,[]ListenerPortMappingParameters)

	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#SpecListenerTLSParameters] @go(TLS,[]SpecListenerTLSParameters)

	// Timeouts for different protocols.
	// +kubebuilder:validation:Optional
	timeout?: [...#ListenerTimeoutParameters] @go(Timeout,[]ListenerTimeoutParameters)
}

#SpecListenerTLSObservation: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	certificate?: [...#ListenerTLSCertificateObservation] @go(Certificate,[]ListenerTLSCertificateObservation)

	// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
	mode?: null | string @go(Mode,*string)

	// TLS validation context.
	validation?: [...#ListenerTLSValidationObservation] @go(Validation,[]ListenerTLSValidationObservation)
}

#SpecListenerTLSParameters: {
	// Virtual node's client's Transport Layer Security (TLS) certificate.
	// +kubebuilder:validation:Required
	certificate: [...#ListenerTLSCertificateParameters] @go(Certificate,[]ListenerTLSCertificateParameters)

	// Listener's TLS mode. Valid values: DISABLED, PERMISSIVE, STRICT.
	// +kubebuilder:validation:Required
	mode?: null | string @go(Mode,*string)

	// TLS validation context.
	// +kubebuilder:validation:Optional
	validation?: [...#ListenerTLSValidationParameters] @go(Validation,[]ListenerTLSValidationParameters)
}

#SpecLoggingObservation: {
	// Access log configuration for a virtual node.
	accessLog?: [...#LoggingAccessLogObservation] @go(AccessLog,[]LoggingAccessLogObservation)
}

#SpecLoggingParameters: {
	// Access log configuration for a virtual node.
	// +kubebuilder:validation:Optional
	accessLog?: [...#LoggingAccessLogParameters] @go(AccessLog,[]LoggingAccessLogParameters)
}

#TCPIdleObservation: {
	// Unit of time. Valid values: ms, s.
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	value?: null | float64 @go(Value,*float64)
}

#TCPIdleParameters: {
	// Unit of time. Valid values: ms, s.
	// +kubebuilder:validation:Required
	unit?: null | string @go(Unit,*string)

	// Number of time units. Minimum value of 0.
	// +kubebuilder:validation:Required
	value?: null | float64 @go(Value,*float64)
}

#TCPObservation: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	maxConnections?: null | float64 @go(MaxConnections,*float64)
}

#TCPParameters: {
	// Maximum number of outbound TCP connections Envoy can establish concurrently with all hosts in upstream cluster. Minimum value of 1.
	// +kubebuilder:validation:Required
	maxConnections?: null | float64 @go(MaxConnections,*float64)
}

#TLSCertificateAcmObservation: {
	// ARN for the certificate.
	certificateArn?: null | string @go(CertificateArn,*string)
}

#TLSCertificateAcmParameters: {
	// ARN for the certificate.
	// +kubebuilder:validation:Required
	certificateArn?: null | string @go(CertificateArn,*string)
}

#TLSCertificateFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	privateKey?: null | string @go(PrivateKey,*string)
}

#TLSCertificateFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)

	// Private key for a certificate stored on the file system of the mesh endpoint that the proxy is running on.
	// +kubebuilder:validation:Required
	privateKey?: null | string @go(PrivateKey,*string)
}

#TLSCertificateSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSCertificateSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#TLSValidationSubjectAlternativeNamesMatchObservation: {
	// Values sent must match the specified values exactly.
	exact?: [...null | string] @go(Exact,[]*string)
}

#TLSValidationSubjectAlternativeNamesMatchParameters: {
	// Values sent must match the specified values exactly.
	// +kubebuilder:validation:Required
	exact: [...null | string] @go(Exact,[]*string)
}

#TLSValidationSubjectAlternativeNamesObservation: {
	// Criteria for determining a SAN's match.
	match?: [...#TLSValidationSubjectAlternativeNamesMatchObservation] @go(Match,[]TLSValidationSubjectAlternativeNamesMatchObservation)
}

#TLSValidationSubjectAlternativeNamesParameters: {
	// Criteria for determining a SAN's match.
	// +kubebuilder:validation:Required
	match: [...#TLSValidationSubjectAlternativeNamesMatchParameters] @go(Match,[]TLSValidationSubjectAlternativeNamesMatchParameters)
}

#TLSValidationTrustFileObservation: {
	// Certificate chain for the certificate.
	certificateChain?: null | string @go(CertificateChain,*string)
}

#TLSValidationTrustFileParameters: {
	// Certificate chain for the certificate.
	// +kubebuilder:validation:Required
	certificateChain?: null | string @go(CertificateChain,*string)
}

#TLSValidationTrustObservation: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	acm?: [...#TrustAcmObservation] @go(Acm,[]TrustAcmObservation)

	// Local file certificate.
	file?: [...#TLSValidationTrustFileObservation] @go(File,[]TLSValidationTrustFileObservation)

	// A Secret Discovery Service certificate.
	sds?: [...#TLSValidationTrustSdsObservation] @go(Sds,[]TLSValidationTrustSdsObservation)
}

#TLSValidationTrustParameters: {
	// TLS validation context trust for an AWS Certificate Manager (ACM) certificate.
	// +kubebuilder:validation:Optional
	acm?: [...#TrustAcmParameters] @go(Acm,[]TrustAcmParameters)

	// Local file certificate.
	// +kubebuilder:validation:Optional
	file?: [...#TLSValidationTrustFileParameters] @go(File,[]TLSValidationTrustFileParameters)

	// A Secret Discovery Service certificate.
	// +kubebuilder:validation:Optional
	sds?: [...#TLSValidationTrustSdsParameters] @go(Sds,[]TLSValidationTrustSdsParameters)
}

#TLSValidationTrustSdsObservation: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	secretName?: null | string @go(SecretName,*string)
}

#TLSValidationTrustSdsParameters: {
	// Name of the secret secret requested from the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or certificate chain.
	// +kubebuilder:validation:Required
	secretName?: null | string @go(SecretName,*string)
}

#TimeoutGRPCObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#GRPCIdleObservation] @go(Idle,[]GRPCIdleObservation)

	// Per request timeout.
	perRequest?: [...#GRPCPerRequestObservation] @go(PerRequest,[]GRPCPerRequestObservation)
}

#TimeoutGRPCParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#GRPCIdleParameters] @go(Idle,[]GRPCIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#GRPCPerRequestParameters] @go(PerRequest,[]GRPCPerRequestParameters)
}

#TimeoutHTTPObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#HTTPIdleObservation] @go(Idle,[]HTTPIdleObservation)

	// Per request timeout.
	perRequest?: [...#HTTPPerRequestObservation] @go(PerRequest,[]HTTPPerRequestObservation)
}

#TimeoutHTTPParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#HTTPIdleParameters] @go(Idle,[]HTTPIdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#HTTPPerRequestParameters] @go(PerRequest,[]HTTPPerRequestParameters)
}

#TimeoutHttp2Observation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#Http2IdleObservation] @go(Idle,[]Http2IdleObservation)

	// Per request timeout.
	perRequest?: [...#Http2PerRequestObservation] @go(PerRequest,[]Http2PerRequestObservation)
}

#TimeoutHttp2Parameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#Http2IdleParameters] @go(Idle,[]Http2IdleParameters)

	// Per request timeout.
	// +kubebuilder:validation:Optional
	perRequest?: [...#Http2PerRequestParameters] @go(PerRequest,[]Http2PerRequestParameters)
}

#TimeoutTCPObservation: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	idle?: [...#TCPIdleObservation] @go(Idle,[]TCPIdleObservation)
}

#TimeoutTCPParameters: {
	// Idle timeout. An idle timeout bounds the amount of time that a connection may be idle.
	// +kubebuilder:validation:Optional
	idle?: [...#TCPIdleParameters] @go(Idle,[]TCPIdleParameters)
}

#TrustAcmObservation: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#TrustAcmParameters: {
	// One or more ACM ARNs.
	// +kubebuilder:validation:Required
	certificateAuthorityArns: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#ValidationTrustAcmObservation: {
	// One or more ACM ARNs.
	certificateAuthorityArns?: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#ValidationTrustAcmParameters: {
	// One or more ACM ARNs.
	// +kubebuilder:validation:Required
	certificateAuthorityArns: [...null | string] @go(CertificateAuthorityArns,[]*string)
}

#VirtualNodeObservation: {
	// ARN of the virtual node.
	arn?: null | string @go(Arn,*string)

	// Creation date of the virtual node.
	createdDate?: null | string @go(CreatedDate,*string)

	// ID of the virtual node.
	id?: null | string @go(ID,*string)

	// Last update date of the virtual node.
	lastUpdatedDate?: null | string @go(LastUpdatedDate,*string)

	// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the virtual node. Must be between 1 and 255 characters in length.
	name?: null | string @go(Name,*string)

	// Resource owner's AWS account ID.
	resourceOwner?: null | string @go(ResourceOwner,*string)

	// Virtual node specification to apply.
	spec?: [...#VirtualNodeSpecObservation] @go(Spec,[]VirtualNodeSpecObservation)

	// Key-value map of resource tags.
	tags?: {[string]: null | string} @go(Tags,map[string]*string)

	// Map of tags assigned to the resource, including those inherited from the provider default_tags configuration block.
	tagsAll?: {[string]: null | string} @go(TagsAll,map[string]*string)
}

#VirtualNodeParameters: {
	// Name of the service mesh in which to create the virtual node. Must be between 1 and 255 characters in length.
	// +crossplane:generate:reference:type=github.com/upbound/provider-aws/apis/appmesh/v1beta1.Mesh
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	meshName?: null | string @go(MeshName,*string)

	// AWS account ID of the service mesh's owner. Defaults to the account ID the AWS provider is currently connected to.
	// +kubebuilder:validation:Optional
	meshOwner?: null | string @go(MeshOwner,*string)

	// Name to use for the virtual node. Must be between 1 and 255 characters in length.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Virtual node specification to apply.
	// +kubebuilder:validation:Optional
	spec?: [...#VirtualNodeSpecParameters] @go(Spec,[]VirtualNodeSpecParameters)

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	tags?: {[string]: null | string} @go(Tags,map[string]*string)
}

#VirtualNodeSpecObservation: {
	// Backends to which the virtual node is expected to send outbound traffic.
	backend?: [...#BackendObservation] @go(Backend,[]BackendObservation)

	// Defaults for backends.
	backendDefaults?: [...#SpecBackendDefaultsObservation] @go(BackendDefaults,[]SpecBackendDefaultsObservation)

	// Listeners from which the virtual node is expected to receive inbound traffic.
	listener?: [...#SpecListenerObservation] @go(Listener,[]SpecListenerObservation)

	// Inbound and outbound access logging information for the virtual node.
	logging?: [...#SpecLoggingObservation] @go(Logging,[]SpecLoggingObservation)

	// Service discovery information for the virtual node.
	serviceDiscovery?: [...#ServiceDiscoveryObservation] @go(ServiceDiscovery,[]ServiceDiscoveryObservation)
}

#VirtualNodeSpecParameters: {
	// Backends to which the virtual node is expected to send outbound traffic.
	// +kubebuilder:validation:Optional
	backend?: [...#BackendParameters] @go(Backend,[]BackendParameters)

	// Defaults for backends.
	// +kubebuilder:validation:Optional
	backendDefaults?: [...#SpecBackendDefaultsParameters] @go(BackendDefaults,[]SpecBackendDefaultsParameters)

	// Listeners from which the virtual node is expected to receive inbound traffic.
	// +kubebuilder:validation:Optional
	listener?: [...#SpecListenerParameters] @go(Listener,[]SpecListenerParameters)

	// Inbound and outbound access logging information for the virtual node.
	// +kubebuilder:validation:Optional
	logging?: [...#SpecLoggingParameters] @go(Logging,[]SpecLoggingParameters)

	// Service discovery information for the virtual node.
	// +kubebuilder:validation:Optional
	serviceDiscovery?: [...#ServiceDiscoveryParameters] @go(ServiceDiscovery,[]ServiceDiscoveryParameters)
}

#VirtualServiceClientPolicyObservation: {
	// Transport Layer Security (TLS) client policy.
	tls?: [...#ClientPolicyTLSObservation] @go(TLS,[]ClientPolicyTLSObservation)
}

#VirtualServiceClientPolicyParameters: {
	// Transport Layer Security (TLS) client policy.
	// +kubebuilder:validation:Optional
	tls?: [...#ClientPolicyTLSParameters] @go(TLS,[]ClientPolicyTLSParameters)
}

// VirtualNodeSpec defines the desired state of VirtualNode
#VirtualNodeSpec: {
	forProvider: #VirtualNodeParameters @go(ForProvider)
}

// VirtualNodeStatus defines the observed state of VirtualNode.
#VirtualNodeStatus: {
	atProvider?: #VirtualNodeObservation @go(AtProvider)
}

// VirtualNode is the Schema for the VirtualNodes API. Provides an AWS App Mesh virtual node resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
#VirtualNode: {
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.spec)",message="spec is a required parameter"
	spec:    #VirtualNodeSpec   @go(Spec)
	status?: #VirtualNodeStatus @go(Status)
}

// VirtualNodeList contains a list of VirtualNodes
#VirtualNodeList: {
	items: [...#VirtualNode] @go(Items,[]VirtualNode)
}
